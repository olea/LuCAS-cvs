@c ---------------------------------------------------------------------
@node Administracion del Repositorio
@unnumbered Administracion del Repositorio

@comment Este cap@'{@dotless{i}}tulo ha sido traducido por
@comment Emilio Murcia Pacheco <emmurcia@@terra.es>
@comment  
@comment Se ceden todos los derechos bajo la licencia de documentaci@'on de 
@comment la GNU (fdl) que se puede encontrar en http://www.gnu.org/


En @ref{Una introduccion a CVS}, usted ha aprendido bastante de CVS para usarlo
de forma eficaz como participante de un proyecto.  Sin embargo, si va a ser
administrador de un proyecto, necesitar@'a conocer c@'omo instalar CVS y
administrar repositorios.  En este cap@'{@dotless{i}}tulo descorreremos la cortina y
observaremos en detalle c@'omo se estructura el repositorio, y c@'omo lo utiliza
CVS.  Aprender@'a los pasos m@'as importantes por los que pasa CVS
durante las actualizaciones y env@'{@dotless{i}}os ("commits"), y c@'omo puede modificar su
comportamiento.  Comprendiendo c@'omo trabaja CVS, ser@'a tambi@'en capaz de
encontrar las causas de los problemas, y resolverlos de forma mantenible.

Esto puede parecer muy complicado, pero recuerde que CVS ya ha probado
ser bastante duradero, y seguramente seguir@'a us@'andose durante muchos a@~nos m@'as.
Lo que aprenda ahora le ser@'a de utilidad durante mucho tiempo.  CVS tambi@'en
tiende a hacerse m@'as indispensable cuanto m@'as lo use.  Si va a depender tanto
de algo (y h@'agame caso, as@'{@dotless{i}} ser@'a), realmente vale la pena que llegue a
conocerlo.

Con esto en mente, vamos a comenzar por el principio: poniendo CVS en su
sistema.

@menu
* Consiguiendo e instalando CVS::                 Poniendo CVS en su sistema.
* Anatomia de una distribucion CVS::              Qu@'e hay en la distribuci@'on CVS.
* Iniciando un repositorio::                      Poniendo a punto un repositorio.
* El servidor de autentificacion de contrasen~as:: Un m@'etodo de acceso remoto.
* Acceso anonimo::                                Garantizando acceso al p@'ublico.
* Estructura del repositorio::                    C@'omo se organiza el repositorio.
* Formato RCS::                                   C@'omo funciona el almacenamiento en el repositorio.
* Qu@'e ocurre cuando elimina un fichero::          CVS reserva un @'atico para los ficheros antiguos.
* El directorio administrativo CVSROOT/::         Ficheros de configuraci@'on del servidor en tiempo de ejecuci@'on.                                                                  
* Correos de env@'{@dotless{i}}o de cambios::                   Fijando env@'{@dotless{i}}os autom@'aticos de notificaciones.
* Averiguando m@'as::                               Otras fuentes de informaci@'on.
@end menu

@c -----------------------------------------------------
@node Consiguiendo e instalando CVS
@section Consiguiendo e instalando CVS

En muchos casos, no tendr@'a que salir a buscar CVS, porque ya estar@'a
en su sistema.  Si posee una de las distribuciones principales de Linux
o FreeBSD, seguramente est@'a instalado en /usr/bin o alguna otra localizaci@'on
probable.  Si no, los usuarios de Red Hat Linux pueden encontrar por lo
general un RPM ("Red Hat Package", o Paquete de Red Hat) con la @'ultima versi@'on
de CVS (o casi la @'ultima) en sus distribuciones.  Y los usuarios de Debian
pueden instalar el @'ultimo paquete Debian con estas @'ordenes:

@example
floss$ apt-get update
floss$ apt-get install cvs
@end example

Si CVS no est@'a ya en su m@'aquina, probablemente tendr@'a que compilarlo a partir
del c@'odigo fuente.  Si no es un usuario de Unix, seguramente encuentre m@'as
f@'acil conseguir un binario precompilado para su sistema operativo (m@'as adelante
se detalla este aspecto).  Afortunadamente, CVS est@'a totalmente
@dfn{autoconfigurado} -- es decir, utiliza el mecanismo de autoconfiguraci@'on de
GNU, con lo que la compilaci@'on a partir de las fuentes es sorprendentemente
sencilla.

@menu
* Consiguiendo y compilando CVS bajo Unix::
* Consiguiendo e instalando CVS bajo Windows::
* Consiguiendo e instalando CVS en un Macintosh::
* Limitaciones de las versiones Windows y Macintosh::
@end menu

@c ---------------------------
@node Consiguiendo y compilando CVS bajo Unix
@subsection Consiguiendo y compilando CVS bajo Unix

En el momento de escribir esto, existen dos sitios principales de los que
se puede descargar CVS.  Uno es el servidor FTP de la Fundaci@'on para el
Software Libre, @uref{ftp://ftp.gnu.org/gnu/cvs/}, que ofrece CVS como
herramienta oficial GNU.  El otro es el sitio de descarga de Cyclic Software.
Cyclic Software es, si no el "administrador" de CVS, s@'{@dotless{i}} el "administrador de
los administradores", proporcionando un servidor de repositorio y acceso para
descargar a usuarios y desarrolladores.  Distribuyen versiones desde
@uref{http://download.cyclic.com/pub/}.

Cualquiera de los dos sitios es bueno.  En el siguiente ejemplo, uso el sitio
de Cyclic Software.  Si dirige su cliente FTP (seguramente su navegador Web)
hacia all@'{@dotless{i}}, ver@'a una lista de directorios, algo como esto:

@example
Index of /pub
    cvs-1.10.5/            18-Feb-99 21:36      -
    cvs-1.10.6/            17-May-99 10:34      -
    cvs-1.10/              09-Dec-98 17:26      -
    macintosh/             23-Feb-99 00:53      -
    os2/                   09-Dec-98 17:26      -
    packages/              09-Dec-98 17:26      -
    rcs/                   09-Dec-98 17:26      -
    tkcvs/                 09-Dec-98 17:26      -
    training/              09-Dec-98 17:26      -
    unix/                  09-Dec-98 17:26      -
    vms/                   09-Dec-98 17:26      -
@end example

Preste atenci@'on a los directorios que empiezan por "cvs-" (puede ignorar
la mayor@'{@dotless{i}}a de los dem@'as).  Hay tres directorios de este tipo, lo que significa
que se enfrenta a una elecci@'on: Descargar la versi@'on llamada "estable",
o ir a por una versi@'on intermedia m@'as reciente (pero menos probada).  Las
versiones estables tienen s@'olo un punto decimal, como en "cvs-1.10", mientras
que las versiones intermedias tienen incrementos de versi@'on menores a@~nadidos
al final, como en "1.10.5".

El sitio de GNU s@'olo ofrece las versiones principales, no las intermedias,
as@'{@dotless{i}} que no ver@'a todas las anteriores si consigue CVS desde aqu@'{@dotless{i}}.  En general,
las versiones intermedias han sido bastante seguras, y a veces
resuelven problemas encontrados en las versiones principales.  La mejor
pol@'{@dotless{i}}tica es ir a por la versi@'on intermedia m@'as alta, pero si encuentra
cualquier problema con ella, prep@'arese para bajar a la versi@'on anterior, tantas
veces como sea necesario.  La versi@'on m@'as alta listada en el ejemplo anterior
es cvs-1.10.6.  Entrando en ese directorio, veremos esto:

@example
Index of /pub/cvs-1.10.6
    cvs-1.10.6.tar.gz      17-May-99 08:44   2.2M
@end example

Esto es -- el c@'odigo fuente completo de CVS.  Desc@'arguelo a su m@'aquina
y estar@'a preparado para compilar.  En este punto, si ya esta familiarizado
con el proceso de compilaci@'on est@'andar para herramientas GNU, sabr@'a qu@'e hacer
y probablemente no necesite leer nada desde aqu@'{@dotless{i}} a la secci@'on
@ref{Anatomia de una distribucion CVS}.  Por otra parte, si no est@'a seguro
de c@'omo continuar, siga leyendo....

Los siguientes ejemplos e instrucciones de compilaci@'on asumen que posee una
distribuci@'on est@'andar de Unix.  Cualquiera de las versiones libres de Unix
(por ejemplo, FreeBSD o Linux) deber@'{@dotless{i}}a funcionar sin problemas, como deber@'{@dotless{i}}a
ocurrir en las principales versiones comerciales de Unix (como SunOS/Solaris,
AIX, HP-UX, o Ultrix).  Incluso si estas instrucciones no funcionan para usted
exactamente como est@'an escritas, no renuncie a la esperanza.  Aunque cubrir los
detalles de compilar en cada sistema operativo est@'a fuera de los objetivos de
este libro, dar@'e indicaciones de otras fuentes de ayuda m@'as adelante en este
cap@'{@dotless{i}}tulo.

De todas formas, para seguir adelante con la compilaci@'on, primero descomprima
el fichero tar usando GNU unzip y tar (si no los tiene instalados en su
sistema, puede conseguir gunzip de @uref{ftp://ftp.gnu.org/gnu/gzip/} y la
versi@'on GNU de tar de @uref{ftp://ftp.gnu.org/gnu/tar/}):

@example
floss$ gunzip cvs-1.10.6.tar.gz
floss$ tar xvf cvs-1.10.6.tar
@end example

Ver@'a muchos nombres de fichero volando por su pantalla.

Ahora tendr@'a un nuevo directorio en su m@'aquina -- cvs-1.10.6 --, que contendr@'a
el c@'odigo fuente de CVS.  Entre al directorio y configure CVS para su sistema,
usando el gui@'on "configure" proporcionado:

@example
floss$ cd cvs-1.10.6
floss$  ./configure
creating cache ./config.cache
checking for gcc... gcc
checking whether we are using GNU C... yes
checking whether gcc accepts -g... yes
checking how to run the C preprocessor... gcc -E
  (etc)
@end example

Cuando la orden "configure" finalice, el @'arbol fuente sabr@'a todo lo que
necesita saber para compilarse en su m@'aquina.  El siguiente paso consiste
en escribir:

@example
floss$ make
@end example

Ver@'a muchas l@'{@dotless{i}}neas de salida en su pantalla, despu@'es escriba:

@example
floss$ make install
@end example

Ver@'a a@'un m@'as l@'{@dotless{i}}neas de salida volando; cuando haya acabado del todo, CVS
estar@'a instalado en su sistema.  (Seguramente necesitar@'a hacer este @'ultimo
paso como superusuario.)

Por defecto, el ejecutable de CVS acabar@'a siendo @file{/usr/local/bin/cvs}.
Esto asume que usted tiene un programa "make" decente instalado en su sistema
(de nuevo, si no tiene uno, consiga el "make" del proyecto GNU en
@uref{ftp://ftp.gnu.org/gnu/make/}).

Si quiere que CVS se instale en una ruta distinta de /usr/local/bin, deber@'{@dotless{i}}a
cambiar la forma en que ejecuta el paso inicial de configuraci@'on.  Por ejemplo,

@example
floss$ ./configure --prefix=/usr
@end example

da lugar a que CVS est@'e instalado como /usr/bin/cvs (siempre acaba en
PREFIX/bin/cvs).  El prefijo por defecto es /usr/local, que est@'a bien para
la mayor@'{@dotless{i}}a de las instalaciones.

Nota Para Usuarios Experimentados: Aunque las versiones antiguas de CVS
consist@'{@dotless{i}}an en m@'as que un mero ejecutable puesto que depend@'{@dotless{i}}an de tener
instalado RCS tambi@'en, este no ha sido el caso desde la Versi@'on 1.10.
Por ello, no necesita preocuparse por ninguna librer@'{@dotless{i}}a o ejecutable
aparte de cvs mismo.

Si solamente pretende usar CVS para acceder a repositorios remotos, lo
anterior es todo lo que necesita hacer.  Si adem@'as planea servir un
repositorio desde su sistema, ser@'an necesarios algunos pasos adicionales
que se explican m@'as adelante en este cap@'{@dotless{i}}tulo.

@c ---------------------------
@node Consiguiendo e instalando CVS bajo Windows
@subsection Consiguiendo e instalando CVS bajo Windows

A menos que sea realmente fan@'atico respecto a tener el c@'odigo fuente de
su ejecutable, no necesitar@'a compilar CVS a partir de las fuentes en su
caja Windows.  Al contrario que en Unix, probablemente las herramientas
necesarias para compilar no existan en su sistema, por lo que una compilaci@'on
implicar@'{@dotless{i}}a primero conseguir estas herramientas.  Dado que eso est@'a fuera de
los objetivos de este libro, simplemente dar@'e unas instrucciones para conseguir
un binario de CVS precompilado.

Antes de nada hay que notar que las distribuciones binarias de CVS
para Windows generalmente se hacen s@'olo para las versiones principales
de CVS -- no para las intermedias -- y no se encuentran en el sitio
FTP de GNU.  As@'{@dotless{i}} que necesitar@'a ir al sitio de descarga de Cyclic
Software, donde en el directorio de la versi@'on principal,
@uref{http://download.cyclic.com/pub/cvs-1.10/}, ver@'a un subdirectorio
adicional

@example
Index of /pub/cvs-1.10
    cvs-1.10.tar.gz        14-Aug-98 09:35   2.4M
    windows/
@end example

dentro del cual hay un fichero ZIP:

@example
Index of /pub/cvs-1.10/windows
    cvs-1.10-win.zip       14-Aug-98 10:10   589k
@end example

Este fichero ZIP contiene una distribuci@'on binaria de CVS.  Desc@'arguela
y descomprima este fichero ZIP:

@example
floss$ unzip cvs-1.10-win.zip

Archive:  cvs-1.10-win.zip
  inflating: cvs.html
  inflating: cvs.exe
  inflating: README
  inflating: FAQ
  inflating: NEWS
  inflating: patch.exe
  inflating: win32gnu.dll
@end example

El fichero README contiene instrucciones detalladas.  Para la mayor@'{@dotless{i}}a de
las instalaciones, pueden resumirse como sigue: Ponga todos los ficheros EXE
y DLL en un directorio incluido en su PATH.  Adem@'as, si va a usar el m@'etodo
pserver para acceder a un repositorio remoto, quiz@'a necesite a@~nadir lo
siguiente a su fichero @file{C:\AUTOEXEC.BAT} y reiniciar:

@example
set HOME=C:
@end example

Esto le dice a CVS d@'onde almacenar el fichero .cvspass.

Actualmente CVS bajo Windows no puede servir repositorios a m@'aquinas
remotas; puede ser un cliente (conect@'andose a repositorios remotos), y
operar en modo local (usando un repositorio en la misma m@'aquina).  Por
lo general, este libro asume que CVS bajo Windows funciona como cliente.
Sin embargo, no deber@'{@dotless{i}}a ser demasiado dif@'{@dotless{i}}cil poner a punto un
repositorio local bajo Windows despu@'es de leer las instrucciones
orientadas a Unix del resto de este cap@'{@dotless{i}}tulo.

Si s@'olo accede a repositorios remotos, puede que ni siquiera necesite
ejecutar CVS.  Existe una utilidad llamada WinCvs que implementa s@'olo la
parte cliente de CVS.  Se distribuye por separado de CVS pero, como CVS,
est@'a disponible libremente bajo la Licencia P@'ublica General (GPL) de GNU.
Hay m@'as informaci@'on disponible en @uref{http://www.wincvs.org}.

@c -------------------------
@node Consiguiendo e instalando CVS en un Macintosh
@subsection Consiguiendo e instalando CVS en un Macintosh

CVS est@'a disponible para Macintosh, pero no como parte de la
distribuci@'on principal.  De momento, hay realmente disponibles tres
clientes CVS para Macintosh por separado:

@itemize
@item MacCvs -- @uref{http://www.wincvs.org}
@item MacCVSClient -- @uref{http://www.glink.net.hk/~jb/MacCVSClient}
      o @uref{http://www.cyclic.com/maccvsclient/}
@item MacCVS Pro -- @uref{http://www.maccvs.org}
@end itemize

Francamente, no s@'e cu@'al es el mejor.  Pru@'ebelos todos, no necesariamente
en el orden dado, y vea cu@'al le gusta.  MacCVS Pro parece tener un
desarrollo activo.  MacCvs aparentemente es un proyecto compa@~nero de
WinCVS y comparte p@'agina web con @'el. (En el momento de escribir esto, un
aviso en la p@'agina de WinCVS afirma: "El desarrolo de MacCvs se reanudar@'a
pronto.", ignoro lo que signifique esto.)

@c -------------------------------------------------------------
@node Limitaciones de las versiones Windows y Macintosh
@subsection Limitaciones de las versiones Windows y Macintosh

Las distribuciones de CVS para Windows y Macintosh est@'an por lo general
limitadas en funcionalidad.  Todas pueden actuar como clientes, en el
sentido de que pueden contactar con un servidor de repositorio para obtener
una copia v@'alida, enviar cambios, actualizar, etc.  Pero no pueden servir
repositorios por ellas mismas.  Si la configura correctamente, la versi@'on
de Windows podr@'a usar un repositorio en un disco local, pero a@'un no podr@'a
servir proyectos desde ese repositorio a otras m@'aquinas.  En general, si
desea tener un repositorio CVS accesible por red, deber@'a ejecutar el servidor
CVS en una m@'aquina Unix.

@c -----------------------------------------------------
@node Anatomia de una distribucion CVS
@section Anatomia de una distribucion CVS

Las instrucciones anteriores est@'an dise@~nadas para ponerle en marcha
r@'apidamente, pero hay mucho m@'as dentro de una distribuci@'on de fuentes de
CVS que simplemente el c@'odigo.  Aqu@'{@dotless{i}} tiene un repaso r@'apido al @'arbol
fuente, de forma que sepa qu@'e partes son recursos @'utiles y cu@'ales
pueden ignorarse.

@menu
* Ficheros informativos::           NEWS, BUGS, FAQ, etc.
* Subdirectorios::                  C@'omo est@'a organizada la distribuci@'on.
* El manual Cederqvist::            El Manual En L@'{@dotless{i}}nea De CVS.
* Otras fuentes de informaci@'on::    D@'onde m@'as encontrar ayuda.
@end menu

@c ---------------------------------------------------
@node Ficheros informativos
@subsection Ficheros informativos

En el nivel superior del @'arbol de la distribuci@'on, encontrar@'a algunos
ficheros que contienen informaci@'on @'util (y enlaces a informaci@'on m@'as
detallada).  Estos ficheros son, en orden de importancia aproximado:

@itemize

@item
@file{NEWS} -- Este fichero enumera los cambios de una versi@'on a la siguiente,
en orden cronol@'ogico inverso (es decir, la m@'as reciente al principio).  Si
ya ha estado usando CVS durante un tiempo y se ha actualizado a una nueva
versi@'on, deber@'{@dotless{i}}a mirar en el fichero NEWS para ver qu@'e nuevas funciones
est@'an disponibles.  Adem@'as, aunque la mayor@'{@dotless{i}}a de los cambios de CVS conservan
compatibilidad hacia atr@'as, de vez en cuando hay cambios no compatibles. Es
mejor leer algo acerca de ellos aqu@'{@dotless{i}} que sorprenderse cuando CVS no se comporte
como espera que lo haga.

@item
@file{BUGS} -- Este fichero contiene exactamente lo que piensa: una lista de
errores conocidos en CVS.  Generalmente no har@'an que la versi@'on de CVS sea
inutilizable, pero deber@'{@dotless{i}}a leer el fichero cada vez que instale una nueva
versi@'on.

@item
@file{DEVEL-CVS} -- Este fichero es la "constituci@'on" de CVS.  Describe
el proceso mediante el cual se aceptan los cambios en la distribuci@'on principal
de CVS y los procedimientos mediante los que una persona se convierte en
desarrollador de CVS.  No necesita leerlo si s@'olo quiere usar CVS; sin embargo,
resulta muy interesante si quiere comprender c@'omo los esfuerzos descoordinados
de gente repartida por todo el mundo convergen en un programa que funciona.  Y
por supuesto, hace falta leerlo si planea enviar un parche (sea para reparar
un error o para una nueva caracter@'{@dotless{i}}stica) a CVS.

@item
@file{HACKING} -- Pese a su nombre, el fichero HACKING no dice mucho
del dise@~no o implementaci@'on de CVS.  Es principalmente una gu@'{@dotless{i}}a de
est@'andares de programaci@'on y otros asuntos t@'ecnicos para gente que piense
en escribir un parche para CVS.  Puede verse como un ap@'endice del fichero
DEVEL-CVS.  Despu@'es de comprender la filosof@'{@dotless{i}}a b@'asica del desarrollo
de CVS, debe leer el fichero HACKING para traducir esta filosof@'{@dotless{i}}a a unas
pr@'acticas concretas de programaci@'on.

@item
@file{FAQ} -- @'Este es el documento de "Preguntas Frecuentes" (FAQ o "Frequently
Asked Questions" en ingl@'es). Desgraciadamente ha tenido una historia de
mantenimiento bastante irregular.  David Grubbs se encarg@'o de @'el hasta
1995.  En ese momento (presumiblemente) estaba muy ocupado, y el fichero
languideci@'o durante un tiempo.  Finalmente, in 1997, Pascal Molli retom@'o
el mantenimiento.  Molli tampoco tuvo tiempo para mantenerlo a mano, pero al
menos encontr@'o tiempo para ponerlo en su sistema autom@'atico FAQ-O-Matic,
que permite al p@'ublico mantener las FAQ de un modo descentralizado
(b@'asicamente, cualquiera puede editar o a@~nadir entradas mediante un formulario
Web).  Probablemente esto fue una buena idea, puesto que al menos las FAQ est@'an
siendo actualizadas de nuevo; sin embargo, la organizaci@'on general y el control
de calidad no son del mismo nivel que si una @'unica persona las mantuviera.

La versi@'on maestra de las FAQ est@'a siempre disponible en el sitio Web de Molli
(@uref{http://www.loria.fr/~molli/cvs-index.html}, bajo el enlace
"Documentation").  El fichero FAQ que se encuentra en las distribuciones CVS se
genera autom@'aticamente desde la base de datos de FAQ-O-Matic, as@'{@dotless{i}} que para
cuando llega al p@'ublico est@'a un poco anticuado. Sin embargo, puede ser de
gran ayuda si busca sugerencias y ejemplos sobre c@'omo hacer algo espec@'{@dotless{i}}fico
(como fusionar una rama enorme al tronco o "resucitar" un fichero eliminado).
La mejor forma de usarlo es como documento de referencia; puede abrirlo
en su editor favorito y hacer b@'usquedas de los t@'erminos que le interesen.
Intentar usarlo como un tutorial ser@'{@dotless{i}}a un error -- le faltan demasiados puntos
importantes sobre CVS para servir de gu@'{@dotless{i}}a completa.

@end itemize

@c -------------------------
@node Subdirectorios
@subsection Subdirectorios

La distribuci@'on CVS contiene unos cuantos subdirectorios.  En el curso de
una instalaci@'on normal no tendr@'a que navegar por ellos, pero si quiere
curiosear por las fuentes, est@'a bien saber qu@'e hace cada cosa.  Aqu@'{@dotless{i}} est@'an:

@example
contrib/
diff/
doc/
emx/
lib/
man/
os2/
src/
tools/
vms/
windows-NT/
zlib/
@end example

La mayor@'{@dotless{i}}a de ellos pueden ignorarse.  Los subdirectorios emx/, os2/,
vms/, and windows-NT/ contienen c@'odigo fuente espec@'{@dotless{i}}fico del sistema
operativo, por lo que usted s@'olo los necesitar@'{@dotless{i}}a si realmente est@'a
tratando de arreglar un problema a nivel de c@'odigo en CVS (una situaci@'on
improbable, aunque no ser@'{@dotless{i}}a la primera vez).  Los subdirectorios diff/
and zlib/ contienen implementaciones internas de CVS del programa diff
y de la biblioteca de compresi@'on GNU zip, respectivamente. (CVS usa la
@'ultima para reducir el n@'umero de bits que tiene que enviar por la red
cuando accede a repositorios remotos.)

Los subdirectorios contrib/ y tools/ contienen programas libres hechos
por terceros para usarse con CVS.  En contrib/, encontrar@'a una
ordenaci@'on de guiones de consola ("shell scripts", N. del T.) peque@~nos y
especializados (lea contrib/README para averiguar lo que hacen).  El
subdirectorio tools/ sol@'{@dotless{i}}a contener contribuciones, pero ahora contiene
un fichero README que dice en parte:

@example
Este subdirectorio antiguamente conten@'{@dotless{i}}a herramientas que pueden usarse
con CVS.  En particular, sol@'{@dotless{i}}a contener una copia de la versi@'on 1.x de
pcl-cvs. Pcl-cvs es una interfaz de Emacs para CVS.

Si est@'a buscando pcl-cvs le sugerimos la versi@'on 2.x de pcl-cvs en:
    ftp://ftp.weird.com/pub/local/
@end example

El paquete PCL-CVS a que se refiere es muy pr@'actico, y tengo m@'as que
decir sobre @'el en @ref{Herramientas de terceros}.

Los subdirectorios src/ y lib/ contienen el grueso del c@'odigo fuente
de CVS, incluido el codigo interno de CVS.  Las principales estructuras
de datos y @'ordenes est@'an implementados en src/, mientras que lib/
contiene peque@~nos m@'odulos de c@'odigo de utilidad general que usa CVS.

El subdirectorio man/ contiene las p@'aginas man de CVS (para el sistema
de manual en l@'{@dotless{i}}nea de Unix).  Cuando ejecut@'o "make install", se incorporaron
dentro de las p@'aginas man de su sistema Unix, as@'{@dotless{i}} que puede escribir

@example
floss$ man cvs
@end example

y conseguir una introducci@'on y referencia de sub@'ordenes (algo concisas) para
CVS.  Aunque son @'utiles como referencia r@'apida, las p@'aginas del manual pueden
no estar tan actualizadas ni ser tan completas como el manual Cederqvist (vea
la pr@'oxima secci@'on); sin embargo, si sirve de consuelo, es m@'as probable que
las p@'aginas del manual est@'en incompletas que realmente sean incorrectas.

@c -------------------------
@node El manual Cederqvist
@subsection El manual Cederqvist

Con esto llegamos al subdirectorio doc/, cuyo habitante m@'as importante es
el famoso @dfn{Cederqvist}.  Hoy en d@'{@dotless{i}}a seguramente sea excesivo llamarlo
"el Cederqvist".  Aunque Per Cederqvist (de Signum Support, Linkoping
Suecia, www.signum.se) escribi@'o la primera versi@'on alrededor de 1992, muchas
otras personas lo han actualizado desde entonces.  Por ejemplo, cuando los
desarrolladores a@~naden una nueva caracter@'{@dotless{i}}stica a CVS, generalmente tambi@'en
la documentan en el Cederqvist.

El Manual Cederqvist est@'a escrito en formato Texinfo, usado por el proyecto
GNU porque es relativamente f@'acil producir salidas tanto en l@'{@dotless{i}}nea como
impresas a partir de @'el (en los formatos Info y PostScript respectivamente).
El fichero maestro Texinfo es doc/cvs.texinfo, pero las distribuciones CVS
vienen con los ficheros Info y PostScript pregenerados, as@'{@dotless{i}} que no tiene
que preocuparse de ejecutar herramientas Texinfo.

Aunque el Cederqvist puede usarse como introducci@'on y tutorial, probablemente
sea m@'as @'util como documento de referencia.  Por esa raz@'on, la mayor@'{@dotless{i}}a de la
gente navega por @'el en l@'{@dotless{i}}nea en lugar de imprimirlo (aunque el fichero
PostScript es @file{doc/cvs.ps}, para aquellos que tengan papel de sobra).
Si @'esta es la primera vez que ha instalado CVS en su sistema, tendr@'a que
hacer un paso extra para asegurarse de que el manual est@'a accesible en l@'{@dotless{i}}nea.

Los ficheros Info (doc/cvs.info, doc/cvs.info-1, doc/cvs.info-2, etc.)
se instalaron cuando ejecut@'o "make install".  Aunque los ficheros se copiaron
en el @'arbol Info del sistema, puede que a@'un tenga que a@~nadir una l@'{@dotless{i}}nea
para CVS en la tabla de contenidos de Info, el nodo "Top". (Esto s@'olo ser@'a
necesario si es la primera vez que ha instalado CVS en su sistema;
de lo contrario, la entrada de instalaciones anteriores deber@'{@dotless{i}}a estar ya
en la tabla de contenidos.)

Si ha a@~nadido nueva documentaci@'on Into antes, puede que est@'e familiarizado
con el proceso.  Primero averig@"ue d@'onde se instalaron las p@'aginas Info.
Si us@'o la instalaci@'on por defecto (en /usr/local/), entonces los ficheros
Info son /usr/local/info/cvs.info*.  Si al instalar us@'o

@example
floss$ ./configure --prefix=/usr
@end example

los ficheros acabaron siendo /usr/info/cvs.*.  Despu@'es de localizar los
ficheros, necesitar@'a a@~nadir una l@'{@dotless{i}}nea para CVS en la tabla de contenidos de
Info, que est@'a en un fichero llamado dir en ese directorio (as@'{@dotless{i}} que en el
@'ultimo caso ser@'{@dotless{i}}a /usr/info/dir).  Si no tiene acceso como root p@'{@dotless{i}}dale a su
administrador que lo haga.  Aqu@'{@dotless{i}} hay un extracto de dir antes de a@~nadir
la referencia a la documentaci@'on CVS:

@example
* Bison: (bison).         The Bison parser generator.
* Cpp: (cpp).             The GNU C preprocessor.
* Flex: (flex).           A fast scanner generator
@end example

Y aqu@'{@dotless{i}} est@'a la misma zona de dir despues:

@example
* Bison: (bison).         The Bison parser generator.
* Cpp: (cpp).             The GNU C preprocessor.
* Cvs: (cvs).             Concurrent Versions System
* Flex: (flex).           A fast scanner generator
@end example

El formato de la l@'{@dotless{i}}nea es muy importante.  Debe incluir el asterisco,
los espacios y los dos puntos en @w{@samp{* Cvs:}}, y los par@'entesis y
el punto en @samp{(cvs).} detr@'as de @'el.  Si falta cualquiera de estos
elementos, el formato del Info dir estar@'a corrupto, y ser@'a incapaz
de leer el Cederqvist.

Una vez que el manual est@'e instalado y referenciado desde la tabla de
contenidos, podr@'a leerlo con cualquier navegador compatible con Info.
Los que estar@'an instalados con mayor seguridad en un sistema Unix
t@'{@dotless{i}}pico son el lector Info de l@'{@dotless{i}}nea de @'ordenes, que puede invocarse
as@'{@dotless{i}} si quiere ir directo a las p@'aginas de CVS

@example
floss$ info cvs
@end example

y el incluido en Emacs, que se invoca escribiendo

@example
M-x info
@end example

o

@example
C-h i
@end example

T@'omese el tiempo necesario para conseguir poner a punto el Cederqvist
correctamente en su sistema cuando instale CVS; acortar@'a mucho el
camino cuando tenga que buscar algo.

@c -------------------------
@node Otras fuentes de informaci@'on
@subsection Otras fuentes de informaci@'on

Adem@'as del Cederqvist, las FAQ, y los dem@'as ficheros de la propia
distribuci@'on, hay recursos de Internet dedicados a CVS.  Si va a
administrar un servidor CVS seguramente quiera unirse a la lista de
correo info-cvs.  Para suscribirse env@'{@dotless{i}}e un mensaje a
@email{info-cvs-request@@gnu.org} (la lista en s@'{@dotless{i}} es
@email{info-cvs@@gnu.org}).  El tr@'afico puede ser de medio a alto,
de unos 10 a 20 mensajes diarios, casi siempre preguntas buscando
respuestas. La mayor@'{@dotless{i}}a de ellas pueden borrarse sin leerlas (a no
ser que quiera ayudar a la gente respondiendo a sus preguntas, que
siempre est@'a bien), pero de vez en cuando alguien anuncia el
descubrimiento de un error, o un parche que implementa alguna
caracter@'{@dotless{i}}stica que usted ha estado esperando.

Tambi@'en puede apuntarse a la lista de correo formal de informes de
errores, que incluye todos los informes de error enviados. Probablemente
no sea necesario, a menos que pretenda ayudar a arreglar los errores,
que ser@'{@dotless{i}}a estupendo, o que sea terriblemente paranoico y quiera estar
enterado de todos los problemas que otros encuentren con CVS. Si quiere
apuntarse, env@'{@dotless{i}}e un mensaje a @email{bug-cvs-request@@gnu.org}.

Tambi@'en hay un grupo de noticias de Usenet, @code{comp.software.config-mgmt},
en el que se habla de control de versiones y sistemas de administraci@'on
de configuraciones en general, y donde hay mucha discusi@'on acerca de CVS.

Por @'ultimo, hay al menos tres sitios Web dedicados a CVS.  El de Cyclic
Software @uref{http://www.cyclic.com} ha sido la p@'agina principal informal
de CVS durante algunos a@~nos, y probablemente lo seguir@'a siendo en el futuro
pr@'oximo.  Cyclic Software tambi@'en proporciona espacio en el servidor y
acceso por red para el repositorio en el que se guardan las fuentes de CVS.
Las p@'aginas web de Cyclic contienen multitud de enlaces a parches
experimentales para CVS, herramientas de terceros que trabajan con CVS,
documentaci@'on, archivos de listas de correo, y todo lo dem@'as.  Si no puede
encontrar lo que necesita en la distribuci@'on, @uref{http://www.cyclic.com}
es el lugar para empezar a buscar.

Otros dos buenos sitios son el de Pascal Molli
@uref{http://www.loria.fr/~molli/cvs-index.html} y el de Sean Dreilinger
@uref{http://durak.org/cvswebsites/}.  La mayor atracci@'on del sitio de
Molli la forman, por supuesto, las FAQ, pero tambi@'en tiene enlaces a
herramientas relacionadas con CVS y archivos de listas de correo.
El sitio de Dreilinger se especializa en informaci@'on sobre el uso de
CVS para administrar documentos Web y tambi@'en tiene un motor de b@'usqueda
espec@'{@dotless{i}}fico para CVS.

@c -----------------------------------------------------
@node Iniciando un repositorio
@section Iniciando un repositorio

Una vez que el ejecutable CVS est@'e instalado en su sistema, podr@'a empezar
a usarlo en seguida como cliente para acceder a repositorios remotos, siguiendo
los procedimientos descritos en @ref{Una introduccion a CVS}.  Sin embargo,
si quiere servir revisiones desde su m@'aquina, tendr@'a que crear un repositorio
en ella.  La orden para hacerlo es

@example
floss$ cvs -d /usr/local/nuevorepos init
@end example

donde @file{/usr/local/nuevorepos} es la ruta a donde usted quiera que est@'e
el repositorio (por supuesto, deber@'a tener permiso de escritura en ese
directorio, lo que podr@'{@dotless{i}}a implicar ejecutar la orden como root).  En cierto
modo puede parecer poco intuitivo que la localizaci@'on del repositorio nuevo se
especifique antes de la suborden init en lugar de despu@'es de @'el, pero usando
la opci@'on -d sigue siendo consistente con otras @'ordenes CVS.

La orden acabar@'a silenciosamente despu@'es de ejecutarse.  Vamos a examinar el
nuevo directorio:

@example
floss$ ls -ld /usr/local/nuevorepos
drwxrwxr-x   3 root     root         1024 Jun 19 17:59 /usr/local/nuevorepos/
floss$ cd /usr/local/nuevorepos
floss$ ls
CVSROOT
floss$ cd CVSROOT
floss$ ls
checkoutlist     config,v        history     notify     taginfo,v
checkoutlist,v   cvswrappers     loginfo     notify,v   verifymsg
commitinfo       cvswrappers,v   loginfo,v   rcsinfo    verifymsg,v
commitinfo,v     editinfo        modules     rcsinfo,v
config           editinfo,v      modules,v   taginfo

floss$
@end example

El @'unico subdirectorio del repositorio nuevo -- CVSROOT/ -- contiene
varios ficheros de administraci@'on que controlan el comportamiento de CVS.
M@'as adelante examinaremos esos ficheros uno a uno; por ahora, nuestro
objetivo s@'olo es conseguir que el repositorio funcione.  En este caso,
"funcionar" significa que los usuarios puedan importar, actualizar,
obtener copias de trabajo y enviar cambios a los proyectos.

No hay que confundir la variable de entorno CVSROOT introducida en @ref{Una
introduccion a CVS} con este subdirectorio CVSROOT del repositorio.  No tienen
nada que ver -- es una coincidencia desafortunada que compartan el mismo
nombre.  La primera es una forma de evitarles a los usuarios tener que teclear
@w{@samp{-d <situaci@'on-del-repositorio>}} cada vez que usen CVS; el segundo
es el directorio de administraci@'on de un repositorio.

Una vez que el repositorio se haya creado, deber@'a ocuparse de sus permisos.
CVS no requiere de ning@'un permiso est@'andar particular o sistema de propiedad
de ficheros; simplemente necesita acceso de escritura al repositorio.
Sin embargo -- en parte por razones de seguridad, pero sobre todo por su propia
salud como administrador -- recomiendo encarecidamente que siga los siguientes
pasos:

@enumerate

@item
A@~nada un grupo de Unix @code{cvs} a su sistema.  Cualquier usuario que
necesite acceder al repositorio deber@'{@dotless{i}}a estar en el grupo.  Por ejemplo,
la l@'{@dotless{i}}nea del fichero @file{/etc/group} de mi m@'aquina es:

@example
cvs:*:105:kfogel,sussman,jimb,noel,lefty,fitz,craig,anonymous,jluis
@end example

@item
Haga que la propiedad y permisos del repositorio reflejen este
nuevo grupo:

@example
floss$ cd /usr/local/nuevorepos
floss$ chgrp -R cvs .
floss$ chmod ug+rwx . CVSROOT
@end example

@end enumerate

Ahora cualquiera de los usuarios listados en el grupo podr@'a empezar un
proyecto ejecutando @w{@code{cvs import}} como se describi@'o en
@ref{Una introduccion a CVS}. Las @'ordenes "checkout", "update" y "commit"
tambi@'en deber@'{@dotless{i}}an funcionar.  Tambi@'en podr@'an entrar en el repositorio desde
localizaciones remotas usando el m@'etodo @code{:ext:}, asumiendo
que tienen acceso por rsh o ssh a la m@'aquina del repositorio.
(Se habr@'a percatado de que las @'ordenes "chgrp" y "chmod" en el ejemplo de
arriba le dieron acceso de escritura a un usuario llamado @code{anonymous},
que no es lo que uno esperar@'{@dotless{i}}a.  La raz@'on es que incluso los usuarios
an@'onimos y de s@'olo lectura del repositorio necesitan acceso de escritura
a nivel del sistema, para que sus procesos CVS puedan crear ficheros de
bloqueo temporales dentro del repositorio.  CVS no asegura la restricci@'on
de "s@'olo lectura" del acceso an@'onimo por medio de permisos de ficheros Unix
sino por otros medios, de lo que se hablar@'a en @ref{Acceso anonimo}.)

Si su repositorio est@'a destinado a servir proyectos al p@'ublico en general,
en cuyo caso los contribuidores no tendr@'an necesariamente cuentas en la
m@'aquina del repositorio, deber@'{@dotless{i}}a configurar ahora el servidor de
autentificaci@'on de contrase@~nas
(@pxref{El servidor de autentificacion de contrasen~as}).  Es
necesario para acceso an@'onimo de s@'olo lectura, y seguramente sea la
manera m@'as f@'acil de asegurar acceso al env@'{@dotless{i}}o de cambios a ciertas personas
sin tener que darles cuentas completas en la m@'aquina.

@c -----------------------------------------------------
@node El servidor de autentificacion de contrasen~as
@section El servidor de autentificacion de contrasen~as

Antes de seguir los pasos necesarios para configurar el servidor de
contrase@~nas vamos a examinar c@'omo funcionan este tipo de conexiones en teor@'{@dotless{i}}a.
Cuando un cliente remoto CVS usa el m@'etodo @code{:pserver:} para conectarse
a un repositorio, el cliente est@'a contactando en realidad con un n@'umero de
puerto espec@'{@dotless{i}}fico en la m@'aquina servidora -- en concreto el n@'umero de puerto
2401 (que es 49 al cuadrado, si le interesan este tipo de cosas).  El puerto
2401 es el puerto designado por defecto para el servidor pserver de CVS, aunque
se podr@'{@dotless{i}}a configurar para usar un puerto diferente siempre que el cliente
y el servidor est@'en de acuerdo en ello.

El servidor CVS en realidad no est@'a esperando conexiones a ese puerto
-- el servidor no empezar@'a hasta que realmente llegue una conexi@'on. En vez de
ello, el programa Unix "inetd" (InterNET Daemon) est@'a escuchando en ese puerto,
y necesita saber que cuando reciba una petici@'on de conexi@'on ahi, deber@'{@dotless{i}}a
iniciar el servidor CVS y conectarlo al cliente entrante.

Esto se consigue modificando los ficheros de configuraci@'on de inetd:
@file{/etc/services} y @file{/etc/inetd.conf}.  El fichero de servicios
asigna n@'umeros de puerto a nombres de servicios e inetd.conf le dice a
inetd qu@'e hacer para un nombre de servicio dado.

Primero ponga una l@'{@dotless{i}}nea como @'esta en /etc/services (despu@'es de asegurarse
de que la l@'{@dotless{i}}nea no existe ya):

@example
cvspserver	2401/tcp
@end example

Luego, escriba esto en /etc/inetd.conf:

@example
cvspserver stream tcp nowait root /usr/local/bin/cvs cvs \
   --allow-root=/usr/local/nuevorepos pserver
@end example

(En el fichero real, esto deber@'a ser una @'unica l@'{@dotless{i}}nea larga, sin barra
inversa \).  Si su sistema usa una envoltura de TCP ("tcp wrapper", N. del T.),
puede que quiera usar algo como esto en vez de lo anterior:

@example
cvspserver stream tcp nowait root /usr/sbin/tcpd /usr/local/bin/cvs \
   --allow-root=/usr/local/nuevorepos pserver
@end example

Ahora reinicie inetd para que tenga en cuenta los cambios en sus ficheros
de configuraci@'on (si no sabe c@'omo reiniciar el demonio, simplemente reinicie
la m@'aquina -- esto tambi@'en funcionar@'a).

Esto es suficiente para permitir conexiones, pero tambi@'en querr@'a configurar
contrase@~nas especiales de CVS -- separadas de las contrase@~nas de login de
los usuarios -- de modo que la gente pueda acceder al repositorio sin
poner en peligro la seguridad general del sistema.

El fichero de contrase@~nas de CVS es CVSROOT/passwd en el repositorio.
No se cre@'o por defecto cuando ejecut@'o cvs init, porque CVS no sabe seguro
si usar@'a pserver.  Incluso si el fichero de contrase@~nas se ha creado, CVS
no tendr@'a forma de saber los nombres de usuario y contrase@~nas a crear.
As@'{@dotless{i}} que usted tendr@'a que crear uno por s@'{@dotless{i}} mismo; aqu@'{@dotless{i}} hay una muestra de
fichero CVSROOT/passwd:

@example
kfogel:rKa5jzULzmhOo
anonymous:XR4EZcEs0szik
melissa:tGX1fS8sun6rY:pubcvs
@end example

El formato es tan simple como parece.  Cada l@'{@dotless{i}}nea es:

@c por hacer: ¿quitar los corchetes angulares aqu@'{@dotless{i}}?
@example
<NOMBREUSUARIO>:<CONTRASE@~NA_CIFRADA>:<NOMBREUSUARIO_SISTEMA_OPCIONAL>
@end example

Los dos puntos adicionales seguidos de un nombre de usuario de sistema
opcional le dicen a CVS que las conexiones autentificadas con NOMBREUSUARIO
deber@'{@dotless{i}}an ejecutarse como la cuenta de sistema NOMBREUSUARIO_SISTEMA  -- en
otras palabras, que la sesi@'on CVS s@'olo ser@'{@dotless{i}}a capaz de hacer en el repositorio
las cosas que alguien conectado como NOMBREUSUARIO_SISTEMA podr@'{@dotless{i}}a hacer.

Si no se da un nombre de usuario de sistema, NOMBREUSUARIO deber@'a coincidir
con un nombre de cuenta real del sistema, y la sesi@'on se ejecutar@'a con los
permisos de ese usuario.  En cualquier caso, la contrase@~na cifrada no deber@'{@dotless{i}}a
ser la misma que la contrase@~na real de acceso del usuario.  Deber@'{@dotless{i}}a ser
una contrase@~na independiente usada s@'olo para conexiones a CVS pserver.

La contrase@~na se cifra usando el mismo algoritmo que las contrase@~nas
est@'andar de Unix, almacenadas en /etc/passwd.  Puede que se pregunte en
este punto, ¿c@'omo se consigue una versi@'on cifrada de una contrase@~na?
Para las contrase@~nas de sistema Unix, la orden passwd se encarga del
cifrado en /etc/passwd por usted.  Por desgracia no hay una orden
equivalente a passwd en cvs (se ha propuesto varias veces, pero nadie
se ha puesto a escribirlo -- ¿lo har@'a usted. quiz@'a?).

Esto es un inconveniente, pero s@'olo peque@~no.  Si no hay otra opci@'on,
siempre podr@'a cambiar temporalmente la contrase@~na de sistema de un
usuario usando passwd, copiar y pegar el texto cifrado de /etc/passwd
en CVSROOT/passwd, y restaurar la antigua contrase@~na (en ciertos sistemas
las contrase@~nas cifradas se encuentran en /etc/shadow y s@'olo el
administrador o root puede leerlas.)

Este proceso es factible pero bastante inc@'omodo.  Ser@'{@dotless{i}}a mucho m@'as f@'acil
tener una utilidad de l@'{@dotless{i}}nea de @'ordenes que tomara una contrase@~na en texto
plano como su argumento y diera como salida la versi@'on cifrada.  Aqu@'{@dotless{i}} est@'a
esa herramienta, escrita en Perl:

@example
#!/usr/bin/perl

srand (time());
my $randletter = "(int (rand (26)) + (int (rand (1) + .5) % 2 ? 65 : 97))";
my $salt = sprintf ("%c%c", eval $randletter, eval $randletter);
my $plaintext = shift;
my $crypttext = crypt ($plaintext, $salt);

print "$@{crypttext@}\n";
@end example

Yo guardo el gui@'on anterior en @file{/usr/local/bin/cryptout.pl}:

@example
floss$ ls -l /usr/local/bin/cryptout.pl

-rwxr-xr-x   1   root   root   265  Jun 14 20:41 /usr/local/bin/cryptout.pl
floss$ cryptout.pl "some text"
sB3A79YDX5L4s

floss$
@end example

Si usara la salida de este ejemplo para crear la siguiente entrada en
CVSROOT/passwd

@example
jluis:sB3A79YDX5L4s:craig
@end example

entonces la gente podr@'{@dotless{i}}a conectarse al repositorio con la siguiente orden:

@example
remote$ cvs -d :pserver:jluis@@floss.red-bean.com:/usr/local/nuevorepos login
@end example

Escribir@'{@dotless{i}}an entonces @code{some text} como contrase@~na y a partir de
entonces podr@'{@dotless{i}}an ejecutar @'ordenes CVS con los mismos privilegios de acceso
que el usuario de sistema @code{craig}.

Si alguien intenta autentificarse con un nombre de usuario y contrase@~na que
no aparecen en CVSROOT/passwd, CVS comprobar@'a si ese nombre de usuario y
contrase@~na est@'an presentes en /etc/passwd.  Si lo est@'an (y si la contrase@~na
coincide, por supuesto), CVS proporcionar@'a el acceso.  Se comporta de esta
forma para comodidad del administrador, para no tener que a@~nadir entradas
a CVSROOT/passwd por separado para los usuarios comunes del sistema.
Sin embargo, este comportamiento tambi@'en es un agujero de seguridad, porque
significa que si uno de esos usuarios se conecta al servidor CVS, su
contrase@~na de acceso al sistema circular@'a por la red en texto claro,
potencialmente vulnerable a los ojos de husmeadores de contrase@~nas.
Un poco m@'as adelante, aprender@'a c@'omo desactivar este comportamiento
"problem@'atico", para que CVS consulte s@'olo su propio fichero passwd.
Tanto si lo deja activado o desactivado, probablemente deber@'{@dotless{i}}a
obligar a los usuarios de CVS que tambi@'en tengan cuentas en el sistema a
mantener contrase@~nas distintas para las dos funciones.

Aunque el fichero passwd autentifica para todo el repositorio, con un poco
de trabajo adicional podr@'a usarlo incluso para proporcionar acceso
espec@'{@dotless{i}}fico de proyecto.  Aqu@'{@dotless{i}} hay un m@'etodo:

Suponga que quiere proporcionar acceso a algunos desarrolladores
remotos al proyecto @code{foo}, y a otros acceso al proyecto @code{bar},
y no quiere que los desarrolladores de un proyecto tengan acceso al env@'{@dotless{i}}o
de cambios al otro.  Puede conseguir esto creando cuentas de usuario y
grupos espec@'{@dotless{i}}ficos de proyecto en el sistema y luego referirse a esas
cuentas en el fichero CVSROOT/passwd.

Aqu@'{@dotless{i}} est@'a el extracto relevante de /etc/passwd en cuesti@'on

@example
cvs-foo:*:600:600:Cuenta P@'ublica CVS para el Proyecto Foo:/usr/local/cvs:/bin/false
cvs-bar:*:601:601:Cuenta P@'ublica CVS para el Proyecto Bar:/usr/local/cvs:/bin/false
@end example

y de /etc/group

@example
cvs-foo:*:600:cvs-foo
cvs-bar:*:601:cvs-bar
@end example

y, finalmente, CVSROOT/passwd:

@example
kcunderh:rKa5jzULzmhOo:cvs-foo
jmankoff:tGX1fS8sun6rY:cvs-foo
brebard:cAXVPNZN6uFH2:cvs-foo
xwang:qp5lsf7nzRzfs:cvs-foo
dstone:JDNNF6HeX/yLw:cvs-bar
twp:glUHEM8KhcbO6:cvs-bar
ffranklin:cG6/6yXbS9BHI:cvs-bar
yyang:YoEqcCeCUq1vQ:cvs-bar
@end example

Algunos de los nombres de usuario de CVS se refieren a las cuentas de
usuario de sistema @code{cvs-foo} y otras a @code{cvs-bar}.  Dado que
CVS se ejecuta bajo la ID de usuario de la cuenta de sistema, simplemente
tendr@'a que asegurarse de que en las partes de inter@'es del repositorio
s@'olo pueden escribir los usuarios y grupos adecuados.  Si se asegura de
que las cuentas de usuario de sistema est@'en bien atadas (sin contrase@~na de
acceso al sistema v@'alida, con @file{/bin/false} como shell), el sistema ser@'a
razonablemente seguro (¡pero mire m@'as adelante en este cap@'{@dotless{i}}tulo acerca de los
permisos CVSROOT!).  Adem@'as, CVS registra los cambios e informes de cambios
bajo el nombre de usuario de CVS, no bajo el nombre de usuario de sistema,
as@'{@dotless{i}} que usted podr@'a saber qui@'en es responsable de un cambio dado.


@c -----------------------------------------------------
@node Acceso anonimo
@section Acceso anonimo

Hasta ahora s@'olo hemos visto c@'omo usar el servidor de autentificaci@'on
de contrase@~nas para dar acceso total al repositorio (aunque es cierto que
se puede restringir ese acceso mediante permisos de fichero Unix cuidadosamente
elegidos).  Pasar a acceso an@'onimo y de s@'olo lectura es un paso simple:
s@'olo hay que a@~nadir un nuevo fichero, o quiz@'a dos, en CVSROOT/.  Los nombres
de los ficheros son @code{readers} y @code{writers} -- el primero contiene
una lista de nombres de usuario que pueden leer el repositorio solamente, y el
segundo los usuarios que pueden leer y escribir.

Si lista un nombre de usuario en CVSROOT/readers, ese usuario tendr@'a acceso
de s@'olo lectura a todos los proyectos del repositorio.  Si lista un nombre de
usuario en CVSROOT/writers, ese usuario tendr@'a acceso a escritura, y todos
los usuarios de pserver que no est@'en listados en writers tendr@'an acceso de
s@'olo lectura (es decir, si el fichero writers existe, implica acceso de s@'olo
lectura para todos los que no est@'en listados en @'el).  Si el mismo nombre de
usuario se encuentra listado en los dos ficheros, CVS resuelve el conflicto
del modo m@'as conservador: el usuario tendr@'a acceso de s@'olo lectura.

El formato de los ficheros es muy simple: un usuario por l@'{@dotless{i}}nea (no olvide
poner una nueva l@'{@dotless{i}}nea en blanco despu@'es del @'ultimo usuario).  Un fichero
readers de muestra ser@'{@dotless{i}}a:

@example
anonymous
splotnik
guest
jbrowse
@end example

Hay que notar que los ficheros se refieren a nombres de usuario de CVS, no
de sistema.  Si usa alias de usuario en el fichero CVSROOT/passwd (poniendo
un nombre de usuario de sistema despu@'es de los segundos dos puntos), el
nombre de usuario m@'as a la izquierda es el que hay que listar en el fichero
readers o writers.

Para ser preciso, hay una descripci@'on formal del comportamiento del servidor
para decidir si dar acceso de s@'olo lectura o de lectura y escritura:

Si existe un fichero readers y este usuario est@'a listado en @'el, se le
dar@'a acceso de s@'olo lectura.  Si existe un fichero writers y este usuario
no est@'a listado en @'el, se le dar@'a tambi@'en acceso de s@'olo lectura (esto
es cierto incluso si existe un fichero readers pero esa persona no est@'a
listada en @'el).  Si esa persona est@'a listada en ambos, se le dar@'a acceso
de s@'olo lectura.  En todos los dem@'as casos, a esa persona se le dar@'a
acceso completo de lectura y escritura.

As@'{@dotless{i}}, un repositorio t@'{@dotless{i}}pico con acceso a CVS an@'onimo tendr@'a esto (o algo
parecido) en CVSROOT/passwd

@example
anonymous:XR4EZcEs0szik
@end example

esto (o algo parecido) en /etc/passwd

@example
anonymous:!:1729:105:Usuario CVS An@'onimo:/usr/local/nuevorepos:/bin/false
@end example

y esto en CVSROOT/readers:

@example
anonymous
@end example

Y, por supuesto, la configuraci@'on mencionada anteriormente en /etc/services
y /etc/inetd.conf.  ¡Y eso es todo!

Hay que remarcar que algunos sistemas Unix antiguos no permiten nombres de
usuario mayores de ocho caracteres.  Una forma de arreglar esto ser@'{@dotless{i}}a llamar
al usuario @code{anon} en lugar de @code{anonymous} en CVSROOT/passwd y
los ficheros de sistema, porque la gente asume a menudo que anon es una
abreviatura de anonymous de todas formas.  Pero ser@'{@dotless{i}}a mejor poner algo
como esto en el fichero CVSROOT/passwd

@example
anonymous:XR4EZcEs0szik:cvsanon
@end example

(y luego, por supuesto, usar @code{cvsanon} en los ficheros de sistema).
De este modo ser@'a capaz de publicar una direcci@'on de repositorio que use
@code{anonymous}, que es m@'as o menos el est@'andar ahora.  La gente
que acceda al repositorio con

@example
cvs -d :pserver:anonymous@@cvs.foobar.com:/usr/local/nuevorepos (etc...)
@end example

realmente ejecutar@'{@dotless{i}}an en el servidor como cvsanon (o lo que sea).  Pero
no necesitar@'{@dotless{i}}an conocer o preocuparse de c@'omo est@'an configuradas las cosas
en el lado del servidor -- s@'olo ver@'{@dotless{i}}an la direcci@'on publicada.

@c -----------------------------------------------------
@node Estructura del repositorio
@section Estructura del repositorio

El nuevo repositorio a@'un no tiene proyectos en @'el.  Vamos a volver a
ejecutar la importaci@'on inicial de @ref{Una introduccion a CVS},
observando lo que le ocurre al repositorio.  (Por simplicidad, todos
las @'ordenes asumen que la variable de entorno CVSROOT tiene el valor
/usr/local/nuevorepos, as@'{@dotless{i}} que no hay necesidad de especificar el
repositorio con -d en importaciones y comprobaciones.)

@example
floss$ ls /usr/local/nuevorepos
CVSROOT/
floss$ pwd
/home/jluis/src/
floss$ ls
miproyecto/
floss$ cd miproyecto
floss$ cvs import -m "importaci@'on inicial a CVS" miproyecto jluis start
N miproyecto/README.txt
N miproyecto/hello.c
cvs import: Importing /usr/local/nuevorepos/miproyecto/a-subdir
N miproyecto/a-subdir/loquesea.c
cvs import: Importing /usr/local/nuevorepos/miproyecto/a-subdir/subsubdir
N miproyecto/a-subdir/subsubdir/fish.c
cvs import: Importing /usr/local/nuevorepos/miproyecto/b-subdir
N miproyecto/b-subdir/random.c

No conflicts created by this import

floss$ ls /usr/local/nuevorepos
CVSROOT/  miproyecto/
floss$ cd /usr/local/nuevorepos/miproyecto
floss$ ls
README.txt,v  a-subdir/     b-subdir/	  hello.c,v
floss$ cd a-subdir
floss$ ls
subsubdir/    loquesea.c,v
floss$ cd ..

floss$
@end example

Antes de importar, el repositorio conten@'{@dotless{i}}a s@'olo su @'area de administraci@'on,
CVSROOT.  Despu@'es de la importaci@'on ha aparecido un nuevo directorio
-- @file{miproyecto} --.  Los ficheros y subdirectorios existentes en ese
nuevo directorio se parecen sospechosamente a los del proyecto que hemos
importado, excepto que los ficheros tienen el sufijo @code{,v}.  @'Estos son
ficheros de control de versi@'on en formato RCS (la @code{,v} quiere decir
"versi@'on"), y son el esqueleto del repositorio.  Cada fichero RCS almacena
la historia de revisiones de su correspondiente fichero del proyecto,
incluyendo todas las ramas y marcas.

@c -----------------------------------------------------
@node Formato RCS
@section Formato RCS

No necesita conocer nada del formato RCS para usar CVS (aunque hay un
escrito excelente incluido en la distribuci@'on fuente, vea doc/RCSFILES).
Sin embargo, una comprensi@'on b@'asica del formato puede ser de inmensa
ayuda para resolver problemas con CVS, as@'{@dotless{i}} que echaremos un peque@~no vistazo
a uno de los ficheros, @file{hello.c,v}.  Aqu@'{@dotless{i}} est@'a su contenido:

@example
head     1.1;
branch   1.1.1;
access   ;
symbols  start:1.1.1.1 jluis:1.1.1;
locks    ; strict;
comment  @@ * @@;

1.1
date     99.06.20.17.47.26;  author jluis;  state Exp;
branches 1.1.1.1;
next;

1.1.1.1
date     99.06.20.17.47.26;  author jluis;  state Exp;
branches ;
next;

desc
@@@@

1.1
log
@@Initial revision
@@
text
@@#include <stdio.h>

void
main ()
@{
  printf ("¡Hola, mundo!\n");
@}
@@

1.1.1.1
log
@@importaci@'on inicial a CVS
@@
text
@@@@
@end example

¡Uff!  La mayor@'{@dotless{i}}a de esto se puede ignorar; no hace falta que se preocupe
de la relaci@'on entre 1.1 y 1.1.1.1, por ejemplo, o de la rama implicada 1.1.1
-- en realidad no son significativas, desde un punto de vista del usuario o
incluso del administrador.  Lo que deber@'{@dotless{i}}a comprender es el formato en general.
Al comienzo hay una colecci@'on de cabeceras:

@example
head     1.1;
branch   1.1.1;
access   ;
symbols  start:1.1.1.1 jluis:1.1.1;
locks    ; strict;
comment  @@ * @@;
@end example

M@'as abajo hay grupos de metainformaci@'on sobre cada revisi@'on (pero a@'un sin
mostrar el contenido de esa revisi@'on), como:

@example
1.1
date     99.06.20.17.47.26;  author jluis;  state Exp;
branches 1.1.1.1;
next     ;
@end example

Y finalmente, el informe de cambios ("log message", N. del T.) y texto de una
revisi@'on real:

@example
1.1
log
@@Initial revision
@@
text
@@#include <stdio.h>

void
main ()
@{
  printf ("¡Hola, mundo!\n");
@}
@@

1.1.1.1
log
@@importaci@'on inicial a CVS
@@
text
@@@@
@end example

Si lo mira de cerca ver@'a que el contenido de la primera revisi@'on se
guarda bajo la cabecera 1.1, pero en ella el informe de cambios es "Initial
revision", mientras que el mensaje que usamos en realidad a la hora de
importar fue "importaci@'on inicial a CVS".  No es necesario que se preocupe
por esta discrepancia ahora.  Ocurre porque las importaciones son
circunstancias especiales: para que importaciones repetidas en el
mismo proyecto tengan un efecto @'util, la importaci@'on en realidad coloca
la revisi@'on inicial en el tronco principal y en una rama especial (las
razones para ello se aclarar@'an cuando veamos derivaciones comerciales
en @ref{CVS avanzado}).  Por ahora puede tratar @code{1.1} y
@code{1.1.1.1} como la misma cosa.

El fichero se vuelve a@'un m@'as revelador despu@'es de que enviemos con commit
la primera modificaci@'on a hello.c:

@example
floss$ cvs -Q co miproyecto
floss$ cd miproyecto
floss$ emacs hello.c
    (haga algunos cambios al fichero)

floss$ cvs ci -m "ahora tambi@'en dice adi@'os"
cvs commit: Examining .
cvs commit: Examining a-subdir
cvs commit: Examining a-subdir/subsubdir
cvs commit: Examining b-subdir
Checking in hello.c;
/usr/local/nuevorepos/miproyecto/hello.c,v  <--  hello.c
new revision: 1.2; previous revision: 1.1
done
@end example

Si mira en el repositorio a hello.c,v ver@'a el efecto del env@'{@dotless{i}}o de cambios:

@example
head  1.2;
access;
symbols
      start:1.1.1.1 jluis:1.1.1;
locks; strict;
comment   @@ * @@;

1.2
date   99.06.21.01.49.40;   author jluis;   state Exp;
branches;
next   1.1;

1.1
date   99.06.20.17.47.26;   author jluis;   state Exp;
branches
       1.1.1.1;
next   ;

1.1.1.1
date   99.06.20.17.47.26;   author jluis;   state Exp;
branches;
next   ;

desc
@@@@

1.2
log
@@ahora tambi@'en dice adi@'os
@@
text
@@#include <stdio.h>

void
main ()
@{
  printf ("¡Hola, mundo!\n");
  printf ("¡Adi@'os, mundo!\n");
@}
@@

1.1
log
@@Initial revision
@@
text
@@d7 1
@@

1.1.1.1
log
@@importaci@'on inicial a CVS
@@
text
@@@@
@end example

Ahora el contenido completo de la revisi@'on 1.2 est@'a guardado en el fichero,
y el texto para la revisi@'on 1.1 ha sido reemplazado por la f@'ormula cr@'{@dotless{i}}ptica:

@example
d7 1
@end example

El @w{@code{d7 1}} es un c@'odigo diff que quiere decir "empezando en la l@'{@dotless{i}}nea 7,
borrar 1 l@'{@dotless{i}}nea".  En otras palabras, ¡para obtener la Revisi@'on 1.1, borre la
l@'{@dotless{i}}nea 7 de la Revisi@'on 1.2!  Pru@'ebelo usted mismo.  Ver@'a que de hecho produce
la Revisi@'on 1.1 -- simplemente se deshace de la l@'{@dotless{i}}nea que a@~nadimos al fichero.

Esto demuestra el principio b@'asico del formato RCS: Almacena s@'olo las
diferencias entre revisiones, ahorrando con ello un mont@'on de espacio comparado
con guardar cada revisi@'on entera.  Para volver desde la @'ultima revisi@'on a la
anterior, parchea la @'ultima revisi@'on usando el diff almacenado.  Por supuesto,
esto significa que cuanto m@'as hacia atr@'as viaje en la historia de revisiones,
habr@'a que realizar m@'as operaciones de parcheo (por ejemplo, si el fichero est@'a
en la Revisi@'on 1.7 y a CVS se le pide que muestre la Revisi@'on 1.4, tendr@'a que
producir la 1.6 parcheando hacia atr@'as la 1.7, luego la 1.5 parcheando la 1.6,
y finalmente la 1.4 parcheando la 1.5).  Por suerte, las revisiones antiguas
son adem@'as las menos solicitadas, as@'{@dotless{i}} que el sistema RCS funciona bastante bien
en la pr@'actica: Cuanto m@'as reciente sea una revisi@'on, m@'as "barata" es de
obtener.

En cuanto a la informaci@'on de cabecera al principio del fichero, no necesita
saber lo que significa todo ello.  Sin embargo, los efectos de ciertas
operaciones se muestran muy claramente en las cabeceras, y una peque@~na
familiaridad con ellas puede resultar @'util.

Cuando env@'{@dotless{i}}a cambios de una nueva revisi@'on al tronco, la etiqueta @code{head}
se actualiza (note c@'omo cambi@'o a 1.2 en el ejemplo anterior, cuando se envi@'o el
cambio de la segunda revisi@'on a hello.c).  Cuando a@~nade un fichero como binario
o lo marca, esas operaciones se registran tambi@'en en las cabeceras.  Como
ejemplo, vamos a a@~nadir foo.jpg como fichero binario para despu@'es marcarlo
un par de veces:

@example
floss$ cvs add -kb foo.jpg
cvs add: scheduling file 'foo.jpg' for addition
cvs add: use 'cvs commit' to add this file permanently
floss$ cvs -q commit -m "a@~nadida una imagen aleatoria; pregunte a \
   jluis@@red-bean.com el motivo"
RCS file: /usr/local/nuevorepos/miproyecto/foo.jpg,v
done
Checking in foo.jpg;
/usr/local/nuevorepos/miproyecto/foo.jpg,v  <--  foo.jpg
initial revision: 1.1
done
floss$ cvs tag alguna_marca_aleatoria foo.jpg
T foo.jpg
floss$ cvs tag OTRA-MARCA foo.jpg
T foo.jpg
floss$
@end example

Examine ahora la secci@'on "header" de foo.jpg,v en el repositorio:

@example
head   1.1;
access;
symbols
      OTRA-MARCA:1.1
      alguna_marca_aleatoria:1.1;
locks; strict;
comment   @@# @@;
expand	@@b@@;
@end example

F@'{@dotless{i}}jese en la b en la l@'{@dotless{i}}nea "expand" del final -- se debe a haber usado el
par@'ametro -kb al a@~nadir el fichero, y quiere decir que el fichero no
sufrir@'a expansiones de palabra clave o nueva l@'{@dotless{i}}nea, que ocurrir@'{@dotless{i}}an
normalmente durante obtenciones de copia y actualizaciones si fuera un fichero
de texto normal.  Las marcas aparecen en la secci@'on "symbols", una por l@'{@dotless{i}}nea
-- ambas est@'an asociadas a la primera revisi@'on, puesto que eso es lo que se
marc@'o ambas veces.  (Esto tambi@'en ayuda a explicar por qu@'e los nombres de
marca pueden s@'olo contener letras, n@'umeros, guiones y guiones bajos.  Si la
propia marca contuviera puntos o comas, su registro RCS podr@'{@dotless{i}}a ser ambiguo,
porque no habr@'{@dotless{i}}a forma de encontrar el enlace textual entre la marca y la
revisi@'on a la que est@'a asociada.)

@c -----------------------------------------------------
@heading El formato RCS siempre va entre signos @@

El s@'{@dotless{i}}mbolo @code{@@} se usa como delimitador de campos en los ficheros RCS, lo
que significa que si aparece alguno en el texto de un fichero o en un informe
de cambios, deber@'a estar comentado (de lo contrario, CVS interpretar@'{@dotless{i}}a
incorrectamente que est@'a marcando el final de ese campo).  Se comenta
poni@'endolo doble -- es decir, CVS siempre interpreta @code{@@@@} como un
"signo @@ literal", nunca como un "fin de campo actual".  Cuando enviamos los
cambios a foo.jpg, el informe de cambios fue

@example
"a@~nadida una imagen aleatoria; pregunte a jluis@@red-bean.com el motivo"
@end example

que se almacena en foo.jpg,v as@'{@dotless{i}}:

@example
1.1
log
@@a@~nadida una imagen aleatoria; pregunte a jluis@@@@red-bean.com el motivo
@@
@end example

El signo @@ en jluis@@@@red-bean.com se descomentar@'a autom@'aticamente
cada vez que CVS obtenga el informe de cambios:

@example
floss$ cvs log foo.jpg
RCS file: /usr/local/nuevorepos/miproyecto/foo.jpg,v
Working file: foo.jpg
head: 1.1
branch: 
locks: strict
access list: 
symbolic names: 
      OTRA-MARCA: 1.1
      alguna_marca_aleatoria: 1.1
keyword substitution: b
total revisions: 1;	selected revisions: 1
description:
----------------------------
revision 1.1
date: 1999/06/21 02:56:18;  author: jluis;  state: Exp; 
a@~nadida una imagen aleatoria: pregunte a jluis@@red-bean.com el motivo
============================================================================

floss$ 
@end example

El @'unico motivo por el que deber@'{@dotless{i}}a preocuparse es por si alguna vez tiene
que editar a mano ficheros RCS (una circunstancia rara, aunque le ha pasado
a m@'as de uno) Debe acordarse entonces de usar signos dobles @@ en contenidos
de la revisi@'on e informes de cambios.  Si no lo hace, el fichero RCS estar@'a
corrupto y probablemente tendr@'a un comportamiento extra@~no e indeseable.

Hablando de editar a mano ficheros RCS, no se deje enga@~nar por los
permisos en el repositorio:

@example
floss$ ls -l
total 6
-r--r--r--   1 jluis   users         410 Jun 20 12:47 README.txt,v
drwxrwxr-x   3 jluis   users        1024 Jun 20 21:56 a-subdir/
drwxrwxr-x   2 jluis   users        1024 Jun 20 21:56 b-subdir/
-r--r--r--   1 jluis   users         937 Jun 20 21:56 foo.jpg,v
-r--r--r--   1 jluis   users         564 Jun 20 21:11 hello.c,v

floss$ 
@end example

(Para los que no est@'en familiarizados con la salida de "ls" en Unix, las
l@'{@dotless{i}}neas @code{-r--r--r--} de la izquierda b@'asicamente quieren decir que los
ficheros se pueden leer pero no cambiar.)  Aunque los ficheros parecen ser
de s@'olo lectura para todos, tambi@'en hay que tener en cuenta los permisos
de directorio:

@example
floss$ ls -ld . 
drwxrwxr-x   4 jluis   users        1024 Jun 20 22:16 ./ 
floss$
@end example

El propio directorio miproyecto/ -- y sus subdirectorios -- es accesible para
escritura por el propietario (jluis) y el grupo (users).  Esto significa
que CVS (ejecut@'andose como jluis o como cualquiera del grupo users) puede
crear y borrar ficheros en esos directorios, incluso si no puede editar
directamente los ficheros a presentes.  CVS edita un fichero RCS haciendo
una copia separada de @'el, de forma que usted haga todos sus cambios en una
copia temporal, y luego reemplaza el fichero RCS existente con el nuevo.
(Pero por favor, no pregunte por qu@'e los ficheros son de s@'olo lectura -- hay
razones hist@'oricas para ello, relacionadas con la forma en que RCS trabaja
cuando se ejecuta como programa en solitario.)

Por cierto, puede que usted no desee que el grupo de los ficheros sea
@code{users}, considerando que el directorio ra@'{@dotless{i}}z del repositorio se le
asign@'o expl@'{@dotless{i}}citamente el grupo @code{cvs}.  Puede corregir el problema
ejecutando esta orden dentro del repositorio:

@example
floss$ cd /usr/local/nuevorepos
floss$ chgrp -R cvs miproyecto
@end example

Las reglas habituales Unix de creaci@'on de ficheros rigen qu@'e grupo se
asigna a los nuevos ficheros que aparecen en el repositorio, as@'{@dotless{i}} que
de vez en cuando puede que necesite ejecutar "chgrp" o "chmod" en ciertos
ficheros o directorios del repositorio (ajustar el bit SGID con
@w{@code{chmod g+s}} es a menudo una buena estrategia: hace que los hijos
de un directorio hereden el grupo propietario del directorio, que por lo
general es lo que quiere que pase en el repositorio).  No hay reglas
r@'apidas acerca de c@'omo deber@'{@dotless{i}}a estructurar los permisos del repositorio;
depende de qui@'en est@'e trabajando en qu@'e proyectos.

@c -----------------------------------------------------
@node Qu@'e ocurre cuando elimina un fichero
@section Qu@'e ocurre cuando elimina un fichero

Cuando elimina un fichero de un proyecto, no desaparece simplemente.  CVS
debe ser capaz de recuperar esos ficheros cuando solicite una revisi@'on
antigua del proyecto.  En lugar de ello, el fichero se pone en el
@code{Attic}, @'atico literalmente:

@example
floss$ pwd
/home/jluis/src/miproyecto
floss$ ls /usr/local/nuevorepos/miproyecto/
README.txt,v  a-subdir/     b-subdir/     foo.jpg,v   hello.c,v
floss$ rm foo.jpg
floss$ cvs rm foo.jpg
cvs remove: scheduling 'foo.jpg' for removal
cvs remove: use 'cvs commit' to remove this file permanently
floss$ cvs ci -m "Eliminado foo.jpg" foo.jpg
Removing foo.jpg; 
/usr/local/nuevorepos/miproyecto/foo.jpg,v  <--  foo.jpg
new revision: delete; previous revision: 1.1
done
floss$ cd /usr/local/nuevorepos/miproyecto/
floss$ ls
Attic/      README.txt,v  a-subdir/     b-subdir/   hello.c,v
floss$ cd Attic
floss$ ls
foo.jpg,v
floss$
@end example

En cada directorio del repositorio de un proyecto, la presencia de un
subdirectorio @file{Attic/} indica que se ha borrado al menos un fichero
de ese directorio (esto quiere decir que no deber@'{@dotless{i}}a usar directorios llamados
Attic en sus proyectos).  Sin embargo, CVS no mueve simplemente el fichero
RCS a Attic/; adem@'as env@'{@dotless{i}}a el cambio con una nueva revisi@'on al fichero, con
un estado especial de revisi@'on de @code{dead}, muerto.  Aqu@'{@dotless{i}} est@'a la secci@'on
de inter@'es de Attic/foo.jpg,v:

@example
1.2
date   99.06.21.03.38.07;   author jluis;   state dead; 
branches; 
next	1.1; 
@end example

Si el fichero se vuelve a traer de nuevo a la vida, CVS tiene una forma
de registrar que estaba muerto en alg@'un punto del pasado y que ahora est@'a
vivo otra vez.

Esto quiere decir que si quiere restaurar un fichero eliminado, no puede
sacarlo del Attic/ simplemente y ponerlo de nuevo en el proyecto.  En lugar
de ello, tiene que hacer algo como lo siguiente con una copia de trabajo:

@example
floss$ pwd
/home/jluis/src/miproyecto
floss$ cvs -Q update -p -r 1.1 foo.jpg > foo.jpg
floss$ ls
CVS/       README.txt   a-subdir/   b-subdir/   foo.jpg     hello.c
floss$ cvs add -kb foo.jpg
cvs add: re-adding file foo.jpg (in place of dead revision 1.2) 
cvs add: use 'cvs commit' to add this file permanently
floss$ cvs ci -m "revivida imagen jpg" foo.jpg
Checking in foo.jpg; 
/usr/local/nuevorepos/miproyecto/foo.jpg,v  <-- foo.jpg
new revision: 1.3; previous revision: 1.2
done
floss$ cd /usr/local/nuevorepos/miproyecto/
floss$ ls
Attic/	      a-subdir/     foo.jpg,v
README.txt,v  b-subdir/     hello.c,v
floss$ ls Attic/
floss$ 
@end example

Queda mucho m@'as por saber del formato RCS, pero esto es suficiente para
que un administrador de CVS mantenga un repositorio.  Es bastante raro
que realmente haya que editar un fichero RCS; normalmente s@'olo tendr@'a
que ajustar permisos de ficheros en el repositorio, al menos si mi propia
experiencia sirve de gu@'{@dotless{i}}a.  Sin embargo, cundo CVS empieze a comportarse
de forma realmente extra@~na (raro, pero no completamente fuera de lo
posible), puede que quiera mirar dentro de los ficheros RCS para averiguar
qu@'e est@'a pasando.

@c -----------------------------------------------------
@node El directorio administrativo CVSROOT/
@section El directorio administrativo CVSROOT/

Los ficheros de nuevorepos/CVSROOT/ no son parte de ning@'un proyecto, sino
que se usan para controlar el comportamiento de CVS en el repositorio.
La mejor forma de editar esos ficheros es obtener una copia de trabajo de
CVSROOT con "checkout", igual que para un proyecto normal:

@example
floss$ cvs co CVSROOT
cvs checkout: Updating CVSROOT
U CVSROOT/checkoutlist
U CVSROOT/commitinfo
U CVSROOT/config
U CVSROOT/cvswrappers
U CVSROOT/editinfo
U CVSROOT/loginfo
U CVSROOT/modules
U CVSROOT/notify
U CVSROOT/rcsinfo
U CVSROOT/taginfo
U CVSROOT/verifymsg
floss$ 
@end example

Miraremos los ficheros en order aproximado de importancia.  F@'{@dotless{i}}jese en
que cada uno de los ficheros viene con un comentario explicativo al
comienzo (el convenio para comentarios es el mismo para todos ellos: un
signo @code{#} al principio de la l@'{@dotless{i}}nea indica un comentario, y CVS
ignora estas l@'{@dotless{i}}neas cuando procesa los ficheros).  Recuerde que cualquier
cambio que haga a los ficheros de administraci@'on de la copia de trabajo
obtenida no afectar@'a al comportamiento de CVS hasta que env@'{@dotless{i}}e los cambios.

Si usted es extremadamente consciente de la seguridad, puede que quiera
configurar los permisos de fichero en CVSROOT para que sean diferentes de
los permisos en cualquier parte del repositorio, para tener bien controlado
qui@'en puede enviar cambios a CVSROOT.  Como ver@'a un poco m@'as adelante, el
ser capaz de modificar los ficheros de CVSROOT b@'asicamente le da a cualquier
usuario CVS -- incluso a los remotos -- la capacidad de ejecutar cualquier
orden en la m@'aquina del repositorio.

@menu
* El Fichero config::
* El Fichero modules::
* Los Ficheros commitinfo y loginfo y rcsinfo::
* Los Ficheros verifymsg y rcsinfo::
* El Fichero taginfo::
* El Fichero cvswrappers::
* El Fichero editinfo::
* El Fichero notify::
* El Fichero checkoutlist::
@end menu

@c --------------------------------------
@node El Fichero config
@subsection El Fichero config
@cindex config file

El fichero @dfn{config} le permite configurar ciertos par@'ametros de
comportamiento global.  Sigue un formato muy estricto

@example
PAR@'AMETRO=VALOR
(etc) 
@end example

sin permitirse espacios adicionales.  Por ejemplo, aqu@'{@dotless{i}} hay un posible fichero
config:

@example
SystemAuth=yes
TopLevelAdmin=no
PreservePermissions=no
@end example

(Una entrada ausente equivaldr@'{@dotless{i}}a a @code{no}.)

El par@'ametro @code{SystemAuth} controla si CVS deber@'{@dotless{i}}a mirar en el fichero
de sistema passwd si falla al encontrar un determinado nombre de usuario en
el fichero CVSROOT/passwd.  Las distribuciones de CVS vienen con @'el puesto a
@code{no} para ser conservadoras en cuanto a la seguridad del sistema.

@code{TopLevelAdmin} le dice a CVS si hacer un directorio CVS/ hermano
cuando obtiene una copia de trabajo.  Este directorio CVS/ podr@'{@dotless{i}}a no estar
dentro de la copia de trabajo, sino junto a ella.  Ser@'{@dotless{i}}a conveniente
habilitarlo si usted tiende (y los usuarios del repositorio tienden) a obtener
copias de muchos proyectos diferentes en el mismo repositorio.  De lo contrario
deber@'{@dotless{i}}a dejarlo desactivado, ya que puede ser desconcertante ver que aparece
un directorio CVS/ adicional donde no lo espera.

@code{PreservePermissions} controla si se conservan los permisos de
fichero y otra metainformaci@'on en la historia de revisiones.  @'Esta es
una caracter@'{@dotless{i}}stica algo oscura que seguramente no valga la pena describir
en detalle.  Si est@'a interesado vea el nodo @cite{Special Files} en el
Cederqvist (@dfn{nodo} es una palabra de Texinfo para una posici@'on
particular en un documento Info.  Para ir a un nodo mientras se lee Info,
teclee @kbd{g} seguido del nombre del nodo, desde cualquier parte del
documento).

@code{LockDir} tambi@'en es una caracter@'{@dotless{i}}stica usada raramente.  En
circunstancias especiales, querr@'a decirle a CVS que cree sus ficheros de
bloqueo en alg@'un sitio distinto de los subdirectorios del proyecto, para evitar
problemas de permisos.  Estos ficheros de bloqueo impiden que CVS tropiece
consigo mismo al realizar m@'ultiples operaciones en el mismo directorio del
repositorio a la vez.  En general, nunca tendr@'a que preocuparse por ello, pero
a veces puede que los usuarios tengan problemas actualizando u obteniendo
copias de trabajo desde un directorio del repositorio porque son incapaces de
crear un fichero de bloqueo (CVS necesita crear un fichero de bloqueo, incluso
en operaciones de s@'olo lectura, para evitar situaciones en las que podr@'{@dotless{i}}a
acabar leyendo mientras otra invocaci@'on de CVS est@'a escribiendo).  El remedio
habitual para esto es cambiar los permisos del repositorio, pero cuando esto
no es factible, el par@'ametro LockDir puede resultar pr@'actico.

No hay m@'as par@'ametros por el momento, pero puede que en versiones futuras de
CVS se a@~nadan otros nuevos; deber@'{@dotless{i}}a comprobar siempre el Cederqvist o el propio
fichero config de la distribuci@'on para ver los cambios.
@c por hacer: ¡o el fichero NEWS!

@c ----------------------------
@node El Fichero modules
@subsection El Fichero modules
@cindex modules file

En modules puede definir aliases y grupos alternativos de proyectos en el
repositorio.  La l@'{@dotless{i}}nea de module m@'as b@'asica es de la forma:

@example
NOMBRE_M@'ODULO   DIRECTORIO_EN_REPOSITORIO
@end example

por ejemplo,

@example
mp    miproyecto
asub  miproyecto/a-subdir
@end example

(Las rutas dadas a la derecha son relativas al directorio ra@'{@dotless{i}}z del repositorio.)
Esto les da a los desarrolladores un nombre alternativo con el que obtener una
copia de un proyecto o parte de un proyecto:

@example
floss$ cvs co mp
cvs checkout: Updating mp
U mp/README.txt
U mp/foo.jpg
U mp/hello.c
cvs checkout: Updating mp/a-subdir
U mp/a-subdir/loquesea.c
cvs checkout: Updating mp/a-subdir/subsubdir
U mp/a-subdir/subsubdir/fish.c
cvs checkout: Updating mp/b-subdir
U mp/b-subdir/random.c
@end example

o

@example
floss$ cvs -d /usr/local/nuevorepos/ co asub
cvs checkout: Updating asub
U asub/loquesea.c
cvs checkout: Updating asub/subsubdir
U asub/subsubdir/fish.c
@end example

Note c@'omo en ambos casos el nombre del m@'odulo pas@'o a ser el nombre del
directorio creado para la copia de trabajo.  En el caso de asub, ni siquiera
se preocup@'o del directorio intermedio miproyecto/, sino que en lugar de ello
cre@'o un asub/ en un nivel superior, aunque ven@'{@dotless{i}}a de miproyecto/a-subdir en el
repositorio.  Las actualizaciones, env@'{@dotless{i}}os de cambios y todos las @'ordenes CVS
funcionar@'an normalmente en esas copias de trabajo -- lo @'unico raro que tienen
son sus nombres.

Poniendo nombres de ficheros despu@'es del nombre de directorio podr@'a definir
un m@'odulo consistente s@'olo en algunos de los ficheros de un directorio del
repositorio dado. Por ejemplo

@example
readme  miproyecto  README.txt
@end example

y

@example
no-readme  miproyecto  hello.c  foo.jpg
@end example

permitir@'{@dotless{i}}an las siguientes obtenciones de copia respectivamente:

@example
floss$ cvs -q co readme
U readme/README.txt
floss$ cvs -q co no-readme
U no-readme/hello.c
U no-readme/foo.jpg
floss$
@end example

Puede definir un m@'odulo que incluya m@'ultiples directorios de repositorio
usando la opci@'on -a (para @code{alias}), pero f@'{@dotless{i}}jese en que se investigar@'an
los directorios bajo sus nombres originales.  Por ejemplo, esta l@'{@dotless{i}}nea

@example
dosproyectos  -a  miproyecto  tuproyecto
@end example

le permitir@'{@dotless{i}}a hacer esto (asumiendo que tanto miproyecto/ como tuproyecto/
est@'an en el repositorio):

@example
floss$ cvs co dosproyectos
U miproyecto/README.txt
U miproyecto/foo.jpg
U miproyecto/hello.c
U miproyecto/a-subdir/loquesea.c
U miproyecto/a-subdir/subsubdir/fish.c
U miproyecto/b-subdir/random.c
U tuproyecto/README
U tuproyecto/foo.c
U tuproyecto/un-subdir/fichero1.c
U tuproyecto/un-subdir/fichero2.c
U tuproyecto/un-subdir/otro-subdir/bla.c
@end example

El nombre @code{dosproyectos} es un recurso conveniente para meterse en los
dos proyectos, pero no afecta a los nombres de las copias de trabajo.
(Por cierto, no hay necesidad de que los m@'odulos alias se refieran a
m@'ultiples directorios; podr@'{@dotless{i}}amos haber omitido dosproyectos, en cuyo caso a@'un
se habr@'{@dotless{i}}a obtenido una copia de miproyecto bajo el nombre @code{miproyecto}.)

Los m@'odulos pueden incluso referirse a otros m@'odulos, poni@'endoles como
prefijo un signo &:

@example
mp    miproyecto
asub  miproyecto/a-subdir
dosproyectos -a miproyecto tuproyecto
dp  &dosproyectos
@end example

Hacer un checkout de @code{dp} tendr@'{@dotless{i}}a exactamente el mismo resultado que
el de @code{dosproyectos}.

Hay algunos otros trucos que puede hacer con m@'odulos, la mayor@'{@dotless{i}}a de ellos
m@'as infrecuentes que los que se acaban de presentar.  Vea el nodo modules
en el Cederqvist para obtener informaci@'on sobre ellos.

@c ----------------------------------------------------------
@node Los Ficheros commitinfo y loginfo y rcsinfo
@subsection Los Ficheros commitinfo y loginfo y rcsinfo

La mayor@'{@dotless{i}}a de los dem@'as ficheros de administraci@'on proporcionan
@dfn{puntos de comtrol} ("hooks", N. del T.) program@'aticos en varias partes
del proceso de env@'{@dotless{i}}o de cambios (por ejemplo, la capacidad de validar informes
de cambios o estados de fichero antes de permitir el env@'{@dotless{i}}o, o la capacidad de
notificar a un grupo de desarrolladores cada vez que se haga un env@'{@dotless{i}}o en cierto
directorio del repositorio).

Por lo general, los ficheros comparten una sintaxis com@'un.  Cada l@'{@dotless{i}}nea es
de la forma:

@example
EXPRESI@'ON_REGULAR    PROGRAMA_A_EJECUTAR
@end example

La expresi@'on regular se probar@'a con el directorio en el que se est@'a haciendo
el env@'{@dotless{i}}o (con el nombre de directorio relativo al nivel m@'as alto del
repositorio).  Si coincide se ejecutar@'a el programa designado.  Al programa
se le pasar@'an los nombres de cada uno de los ficheros del env@'{@dotless{i}}o; puede
hacer lo que le parezca con esos nombres, incluso abrir los ficheros y
examinar sus contenidos.  Si el programa devuelve un estado de salida
distinto de cero, se impide que se haga el env@'{@dotless{i}}o.

Las (@dfn{expresiones regulares} son un sistema para describir de forma concisa
clases de cadenas.  Si no est@'a familiarizado con las expresiones regulares,
puede hacerlo con el siguiente resumen: @code{foo} coincidir@'{@dotless{i}}a con todos los
ficheros con nombres conteniendo @code{foo}; y @code{foo.*bar} coincidir@'{@dotless{i}}a con
todos los ficheros con nombres conteniendo @code{foo}, seguido de cualquier
n@'umero de caracteres, y seguido por la cadena @code{bar}.  Es por ello que las
subcadenas normales coinciden consigo mismas, pero @code{.} y @code{*} son
especiales.  @code{.} coincide con cualquier caracter, y @code{*} quiere decir
"coincide con cualquier n@'umero de veces, incluyendo cero, del caracter
precedente".  Los signos @code{^} y @code{$} indican "encuentra al principio y
final de la cadena", respectivamente; por tanto, @code{^foo.*bar.*baz$}
encontrar@'{@dotless{i}}a las cadenas que comenzaran con @code{foo}, que contuvieran
@code{bar} en medio, y que acabaran con @code{baz}.  Esto es todo lo que vamos
a profundizar; este resumen es una peque@~na parte muy abreviada de la sintaxis
completa de las expresiones regulares.)

@cindex commitinfo
El fichero @dfn{commitinfo} est@'a para puntos de control gen@'ericos que quiera
ejecutar en todos los env@'{@dotless{i}}os.  Aqu@'{@dotless{i}} hay algunas l@'{@dotless{i}}neas commitinfo de ejemplo:

@example
^a-subdir*     /usr/local/bin/comprobar-asubdir.sh
ou             /usr/local/bin/validar-proyecto.pl
@end example

As@'{@dotless{i}} que cualquier env@'{@dotless{i}}o en miproyecto/a-subdir/ coincidir@'{@dotless{i}}a con la primera
l@'{@dotless{i}}nea, por lo que se ejecutar@'{@dotless{i}}a el gui@'on comprobar-asubdir.sh.  Un env@'{@dotless{i}}o en
cualquier proyecto cuyo nombre (nombre real de directorio del repositorio,
no necesariamente nombre del m@'odulo) contenga la cadena @code{ou} ejecutar@'{@dotless{i}}a
el gui@'on validar-proyecto.pl, a menos que el env@'{@dotless{i}}o ya haya coincidido
con la l@'{@dotless{i}}nea a-subdir anterior.

En lugar de una expresi@'on regular se puede usar la palabra @code{DEFAULT}
o @code{ALL}.  La l@'{@dotless{i}}nea DEFAULT (o la primera l@'{@dotless{i}}nea DEFAULT si hay m@'as de
una) se ejecutar@'a si no coincide ninguna expresi@'on regular, y cada una de
las l@'{@dotless{i}}neas ALL se ejecutar@'a adem@'as de todas las l@'{@dotless{i}}neas que puedan coincidir.

Los nombres de ficheros que se pasan al programa no se refieren a ficheros
RCS -- hacen referencia a ficheros normales, cuyos contenidos son exactamente
los mismos que los de la copia de trabajo de la que se est@'an enviando cambios.
El @'unico aspecto inusual es que CVS los tiene guardados temporalmente dentro
del repositorio, as@'{@dotless{i}} que estar@'an disponibles para los programas que se est@'en
ejecutando en la m@'aquina en la que est@'a el repositorio.

@cindex loginfo
El fichero @dfn{loginfo} es similar a commitinfo, excepto en que en lugar
de actuar en los contenidos de los ficheros, act@'ua en los informes de cambios.
El lado izquierdo del fichero loginfo contiene expresiones regulares, quiz@'a
incluyendo l@'{@dotless{i}}neas DEFAULT y ALL.  El programa invocado a la derecha recibe
el informe de cambios en su entrada est@'andar; puede hacer lo que quiera con esa
entrada.

El programa de la derecha tambi@'en puede admitir un n@'umero arbitrario de
argumentos de l@'{@dotless{i}}nea de @'ordenes.  Uno de esos argumentos puede ser un c@'odigo
especial @code{%}, a expandir por CVS en tiempo de ejecuci@'on como sigue:

@example
%s    ------>      nombre(s) de fichero(s) afectados por el env@'{@dotless{i}}o de cambios
%V    ------>      n@'umero(s) de revisi@'on antes del env@'{@dotless{i}}o de cambios
%v    ------>      n@'umero(s) de revisi@'on despu@'es del env@'{@dotless{i}}o de cambios
@end example

La expansi@'on empieza siempre con el subdirectorio del repositorio (relativo
al nivel superior del repositorio), seguido de la informaci@'on del fichero.
Por ejemplo, si los ficheros afectados por el env@'{@dotless{i}}o de cambios fueran foo, bar
y baz, todos en @file{miproyecto/a-subdir}, @code{%s} se expandir@'{@dotless{i}}a en:

@example
miproyecto/a-subdir  foo  bar  baz
@end example

mientras que @code{%V} se expandir@'{@dotless{i}}a para mostrar los n@'umeros de revisi@'on
antiguos:

@example
miproyecto/a-subdir  1.7  1.134  1.12
@end example

y @code{%v} los n@'umeros de revisi@'on nuevos:

@example
miproyecto/a-subdir  1.8  1.135  1.13
@end example

Puede combinar expresiones con @code{%} delimit@'andolas con llaves siguiendo
al signo @code{%} -- esto las expandir@'a en series de sublistas separadas
por comas, cada una conteniendo la informaci@'on correspondiente a un fichero
del env@'{@dotless{i}}o.  Por ejemplo, @code{%@{sv@}} se expandir@'{@dotless{i}}a en

@example
miproyecto/a-subdir  foo,1.8  bar,1.135  baz,1.13
@end example

y @code{%@{sVv@}} se expandir@'{@dotless{i}}a en

@example
miproyecto/a-subdir  foo,1.7,1.8  bar,1.134,1.135  baz,1.12,1.13
@end example

(Puede que tenga que mirar con cuidado para distinguir las comas de los puntos
decimales en estos ejemplos.)

Aqu@'{@dotless{i}} hay un fichero loginfo de ejemplo:

@example
^miproyecto$   /usr/local/nuevorepos/CVSROOT/log.pl \
   -m miproyecto-devel@@foobar.com %s
ou             /usr/local/bin/ou-notify.pl  %@{sv@}
DEFAULT        /usr/local/bin/default-notify.pl  %@{sVv@}
@end example

En la primera l@'{@dotless{i}}nea, cualquier env@'{@dotless{i}}o de cambios en el subdirectorio miproyecto
del repositorio invoca @file{log.pl}, pas@'andole una direcci@'on de correo
electr@'onico (a la que @file{log.pl} enviar@'a un correo con el informe de
cambios), seguido del repositorio, seguido de todos los ficheros del env@'{@dotless{i}}o.

En la segunda l@'{@dotless{i}}nea, cualquier env@'{@dotless{i}}o de cambios en un subdirectorio del
repositorio que contenga la cadena @code{ou} invocar@'a el gui@'on (imaginario)
@file{notificar-ou.pl}, pas@'andole el repositorio seguido de los nombres de los
ficheros y de los nuevos n@'umeros de revisi@'on de los ficheros del env@'{@dotless{i}}o.

La tercera l@'{@dotless{i}}nea invoca el gui@'on (tambi@'en imaginario)
@file{notificar-defecto.pl} para cualquier env@'{@dotless{i}}o que no coincida con ninguna
de las dos l@'{@dotless{i}}nes anteriores, pas@'andole toda la informaci@'on posible (ruta al
repositorio, nombres de fichero, revisiones antiguas y revisiones nuevas).

@c ----------------------------------------------
@node Los Ficheros verifymsg y rcsinfo
@subsection Los Ficheros verifymsg y rcsinfo

A veces puede que solamente quiera un programa que verifique que los
informes de cambios se ajustan a un cierto est@'andar y que detenga el env@'{@dotless{i}}o si
no se cumple ese est@'andar.  Esto puede conseguirse usando @code{verifymsg},
posiblemente con algo de ayuda de @code{rcsinfo}.

El fichero @dfn{verifymsg} es la combinaci@'on habitual de expresiones
regulares y programas.  El programa recibe el informe de cambios por la entrada
est@'andar; es de suponer que realizar@'a ciertas comprobaciones para verificar
que el informe de cambios cumple ciertos criterios, y finalmente sale con
estado cero o distinto de cero.  En este @'ultimo caso, el env@'{@dotless{i}}o fallar@'a.

Mientras tanto, el lado izquierdo de rcsinfo tiene las expresiones regulares
habituales, pero el lado derecho se@~nala a ficheros de plantilla en vez de a
programas.  Un fichero de plantilla podr@'{@dotless{i}}a ser algo como esto

@example
Condici@'on: 
Arreglar: 
Comentarios: 
@end example

o alguna otra colecci@'on de campos que se supone que un desarrollador debe
rellenar para formar un informe de cambios v@'alido.  La plantilla no es muy @'util
si todo el mundo hace env@'{@dotless{i}}os de cambios usando la opci@'on -m expl@'{@dotless{i}}citamente,
pero muchos desarrolladores prefieren no hacerlo.  En lugar de ello, ejecutan

@example
floss$ cvs commit
@end example

y esperan que CVS lance autom@'aticamente un editor de texto (como se
especifica en la variable de entorno EDITOR).  Ah@'{@dotless{i}} escriben un informe de
cambios, guardan el fichero y se salen del editor, despu@'es de lo cual CVS
contin@'ua con el env@'{@dotless{i}}o.

En ese escenario, se insertar@'{@dotless{i}}a una plantilla rcsinfo en el editor antes
de que el usuario comience a escribir, de forma que se mostrar@'{@dotless{i}}an los
campos junto con un recordatorio para rellenarlos.  Entonces, cuando el
usuario haga un env@'{@dotless{i}}o de cambios, se invocar@'a el programa apropiado en
@file{verifymsg}.  Presumiblemente comprobar@'a que el informe sigue ese
formato, y su estado de salida reflejar@'a los resultados de su investigaci@'on
(con cero indicando @'exito).

Como ayuda a los programas de verificaci@'on, la ruta a la plantilla del
fichero rcsinfo se a@~nade como @'ultimo argumento en la l@'{@dotless{i}}nea de @'ordenes
de @code{verifymsg}; de esa forma el programa puede basar su proceso de
verificaci@'on en la propia plantilla si se desea.

Observe que cuando alguien obtiene una copia de trabajo en
una m@'aquina remota, el fichero de plantilla rcsinfo correspondiente se
env@'{@dotless{i}}a al cliente tambi@'en (se almacena en el subdirectorio CVS/ de la
copia de trabajo).  Sin embargo esto significa que si se cambia el
fichero rcsinfo del servidor despu@'es de esto, el cliente no ver@'a los
cambios sin volver a obtener una copia del proyecto (con actualizar
simplemente no funcionar@'a).

F@'{@dotless{i}}jese tambi@'en en que en el fichero verifymsg no se admite la palabra
clave ALL (aunque DEFAULT sigue valiendo).  Esto es para hacer m@'as
sencillo saltarse guiones de verificaci@'on por defecto y aplicar otros
espec@'{@dotless{i}}ficos para los subdirectorios.

@c -------------------------------------------
@node El Fichero taginfo
@subsection El fichero taginfo

Lo que loginfo hace con los informes de cambios, taginfo lo hace con las
marcas.  El lado izquierdo de taginfo est@'a formado por expresiones regulares
como siempre, y al lado derecho hay programas.  A cada programa se le pasan
autom@'aticamente argumentos cuando se invoca una "CVS tag", en este orden:

@example
arg 1:          nombre de marca
arg 2:          operaci@'on ("a@~nadir" => tag, "mover" => tag -F, "borrar" => \
   tag -d)
arg 3:          repositorio
arg 4, 5, etc:  revisi@'on del fichero [revisi@'on del fichero ...]
@end example

Si el programa devuelve un resultado distinto de cero, la marca se aborta.

No hemos cubierto la opci@'on -F para marcas antes de ahora, pero es
exactamente lo que implica lo de arriba: una forma de mover una marca de
una revisi@'on a otra.  Por ejemplo, si se a@~nade la marca @code{Funciona_Bien}
a la Revisi@'on 1.7 de un fichero y quiere a@~nadirla en su lugar a la
Revisi@'on 1.11, har@'{@dotless{i}}a esto

@example
cvs tag -r 1.11 -F Funciona_Bien foo.c
@end example

que elimina la marca de 1.7, o dondequiera que estuviera anteriormente
en ese fichero, y la pone en 1.11.

@c ------------------------------------------
@node El Fichero cvswrappers
@subsection El Fichero cvswrappers

El fichero de nombre redundante cvswrappers le da una forma de especificar
que ciertos ficheros deber@'{@dotless{i}}an tratarse como binarios, basado en sus nombres
de fichero.  CVS no asume que todos los ficheros .jpg sean im@'agenes JPG, por
ejemplo, as@'{@dotless{i}} que no usa autom@'aticamente -kb cuando a@~nade ficheros JPG.
No obstante, algunos proyectos encontrar@'{@dotless{i}}an muy @'util simplemente designar
todos los ficheros JPG como binarios.  @'Esta es la l@'{@dotless{i}}nea de cvswrappers para
hacerlo:

@example
*.jpg -k 'b'
@end example

La @code{b} est@'a separada y entre comillas porque no es el @'unico modo
de expansi@'on de palabras clave RCS posible; tambi@'en podr@'{@dotless{i}}a especificarse
@code{o}, que indica que no se expandan palabras clave con el signo
@code{$}, sino hacer conversi@'on de nueva l@'{@dotless{i}}nea.  Sin embargo, @code{b}
es el par@'ametro m@'as frecuente.

Hay algunos otros modos que se pueden especificar desde el fichero
wrappers, pero se utilizan en situaciones tan raras que posiblemente no
valga la pena documentarlos aqu@'{@dotless{i}} (es decir: el autor nunca ha tenido
que usarlos).  Vea el nodo @cite{Wrappers} en el Cederqvist si siente
curiosidad.

@c ----------------------------------------------------
@node El Fichero editinfo
@subsection El Fichero editinfo

Este fichero est@'a obsoleto, pese a que sigue estando incluido en las
distribuciones.  Ign@'orelo.

@c ----------------------------------------------------
@node El Fichero notify
@subsection El Fichero notify

Este fichero se usa junto con las caracter@'{@dotless{i}}sticas de @code{alarmas} de CVS,
que se describen en @ref{CVS avanzado}.  Nada de ello tendr@'a sentido hasta
que comprenda qu@'e son las alarmas (son una caracter@'{@dotless{i}}stica @'util pero
no esencial), as@'{@dotless{i}} que vea @ref{CVS avanzado} para obtener detalles sobre
este fichero y sobre las alarmas.

@c ----------------------------------------------------
@node El Fichero checkoutlist
@subsection El Fichero checkoutlist

Si mira en CVSROOT/, ver@'a qu@'e copias de trabajo de los ficheros existen,
junto a sus ficheros de revisi@'on RCS:

@example
floss$ ls /usr/local/nuevorepos/CVSROOT
checkoutlist     config,v       history     notify     taginfo
checkoutlist,v   cvswrappers    loginfo     notify,v   taginfo,v
commitinfo       cvswrappers,v  loginfo,v   passwd     verifymsg
commitinfo,v     editinfo       modules     rcsinfo    verifymsg,v
config           editinfo,v     modules,v   rcsinfo,v

floss$ 
@end example

CVS presta s@'olo atenci@'on a las versiones de trabajo, no a los ficheros RCS,
cuando est@'a buscando una gu@'{@dotless{i}}a sobre c@'omo comportarse.  Por tanto, siempre que
haga un env@'{@dotless{i}}o de cambios de su copia de trabajo de CVSROOT/ (de la que podr@'{@dotless{i}}a
obtenerse incluso, despu@'es de todo, una copia de trabajo desde otra m@'aquina
distinta), CVS actualiza autom@'aticamente todos los ficheros cambiados en el
propio repositorio.  Sabr@'a que esto ocurre porque CVS mostrar@'a un mensaje al
final de estos env@'{@dotless{i}}os:

@example
floss$ cvs ci -m "a@~nadidos m@'odulos mp y asub" modules
Checking in modules; 
/usr/local/nuevorepos/CVSROOT/modules,v  <--  modules
new revision: 1.2; previous revision: 1.1
done
cvs commit: Rebuilding administrative file database
@end example

CVS se entera autom@'aticamente de lo que pasa con los ficheros est@'andar de
administraci@'on, y los reconstruir@'a en CVSROOT/ cuando sea necesario.  Si
decide poner ficheros personalizados en CVSROOT/ (como programas o ficheros
de plantilla rcsinfo), tendr@'a que decirle expl@'{@dotless{i}}citamente a CVS que los
trate del mismo modo.

@'Este es el prop@'osito del fichero checkoutlist.  Tiene un formato distinto
al de la mayor@'{@dotless{i}}a de los ficheros que hemos visto hasta ahora

@example
NOMBRE_FICHERO     MENSAJE_DE_ERROR_SI_NO_PUEDE_OBTENERSE_COPIA_DEL_FICHERO
@end example

por ejemplo,

@example
log.pl           imposible obtener copia de / actualizar log.pl en CVSROOT

bugfix.tmpl      imposible obtener copia de / actualizar bugfix.tmpl en CVSROOT
@end example

Tradicionalmente algunos ficheros de CVSROOT no se someten a control de
revisi@'on.  Uno de ellos es el fichero @dfn{history}, que mantiene un registro
en vivo de todas las acciones en el repositorio para usarse con las @'ordenes
@w{@code{cvshistory}} (que lista actividades de marcas, obtenciones de copias
y actualizaciones para un fichero o un directorio del proyecto dado). A
prop@'osito, si simplemente elimina el fichero @file{history} CVS detendr@'a
servicialmente ese registro.

Nota: a veces el fichero history es la causa de problemas con los permisos,
y la forma m@'as f@'acil de resolverlos es o eliminarlo o hacerlo modificable por
todo el mundo.

Otro fichero de administraci@'on @code{no sujeto a revisi@'on} es passwd, dado que
obtener una copia suya por la red comprometer@'{@dotless{i}}a las contrase@~nas (aunque est@'en
cifradas).  Tendr@'a que decidir bas@'andose en su propia situaci@'on de seguridad
si quiere a@~nadir passwd a checkoutlist o no; por defecto no est@'a.

Dos notas finales sobre el directorio CVSROOT/: Es posible, si comete un
error lo bastante grande, que env@'{@dotless{i}}e cambios de un fichero administrativo que
est@'e estropeado de tal forma que impida que se haga cualquier otro env@'{@dotless{i}}o.
Si hace esto, ¡por supuesto que no ser@'a capaz de enviar una versi@'on corregida
del fichero administrativo!. La soluci@'on es ir y editar a mano la copia de
trabajo del repositorio del fichero administrativo para corregir el problema;
puede que el repositorio entero est@'e inaccesible hasta que haga esto.

Adem@'as, en aras de la seguridad, aseg@'urese de que en el directorio CVSROOT/
s@'olo pueden escribir usuarios en quienes conf@'{@dotless{i}}a (con @code{confianza} quiero
decir que conf@'{@dotless{i}}e tanto en sus intenciones como en su capacidad para no
poner en peligro sus contrase@~nas).  Los ficheros @file{*info} le dan a la
gente la capacidad de invocar programas en general, as@'{@dotless{i}} que cualquiera
que pueda hacer env@'{@dotless{i}}os o editar ficheros en el directorio CVSROOT/ puede
en la pr@'actica ejecutar cualquier orden del sistema.  Esto es algo que
siempre debe tener en mente.

@c -------------------------------------------------------
@node Correos de env@'{@dotless{i}}o de cambios
@section Correos de env@'{@dotless{i}}o de cambios

Con el fichero loginfo es como se configuran los correos de env@'{@dotless{i}}o de cambios
-- correos autom@'aticos que se env@'{@dotless{i}}an a todos los que trabajan en un proyecto
siempre que se realiza un env@'{@dotless{i}}o de cambios.  (Puede que no parezca
intuitivo que esto se haga en loginfo en vez de en commitinfo,
pero la raz@'on para ello es que se quiere incluir el informe de cambios en el
correo).  El programa para hacer el env@'{@dotless{i}}o -- @file{contrib/log.pl} en
la distribuci@'on fuente de CVS -- puede instalarse en cualquier parte
del sistema.  Yo lo pongo en el subdirectorio CVSROOT/ del repositorio,
pero es cuesti@'on de gustos.

Puede que necesite editar ligeramente @file{log.pl} para conseguir que
funcione en su sistema, posiblemente cambiando la primera l@'{@dotless{i}}nea para
que se@~nale a su int@'erprete Perl, y quiz@'a cambiando la l@'{@dotless{i}}nea

@example
$mailcmd = "| Mail -s 'Actualizaci@'on CVS: $modulepath'";
@end example

para que llame a su gestor de correo favorito, que puede llamarse @code{Mail}
o no.  Una vez que lo haya configurado a su gusto, podr@'a a@~nadir l@'{@dotless{i}}neas como
estas a su loginfo:

@example
listerizer CVSROOT/log.pl %s -f CVSROOT/commitlog -m listerizer@@red-bean.com
RoadMail   CVSROOT/log.pl %s -f CVSROOT/commitlog -m roadmail@@red-bean.com
bk/*score  CVSROOT/log.pl %s -f CVSROOT/commitlog -m \
                                        bkscore-devel@@red-bean.com
@end example

El @code{%s} se expande a los nombres de los ficheros afectados por el env@'{@dotless{i}}o
de cambios; la opci@'on -f para @file{log.pl} requiere un nombre de fichero
al que el informe de cambios se a@~nadir@'a (de forma que CVSROOT/commitlog ser@'a un
fichero siempre creciente de informes de cambios); y el modificador -m admite
una direcci@'on de correo electr@'onico, a la que @file{log.pl} enviar@'a un
mensaje sobre el env@'{@dotless{i}}o de cambios.  La direcci@'on es generalmente una lista de
correo, pero puede especificar la opci@'on -m tantas veces como sean necesarias
en una l@'{@dotless{i}}nea de @'ordenes para log.pl.

@c --------------------------------------------------------------
@node Averiguando m@'as
@section Averiguando m@'as

Aunque este cap@'{@dotless{i}}tulo trata de dar una introducci@'on a la instalaci@'on y
administraci@'on de CVS, me he dejado cosas que o bien se usan muy raramente
como para que valga la pena mencionarlas o bien ya est@'an bien documentadas en
el manual Cederqvist.  La @'ultima categor@'{@dotless{i}}a incluye la puesta a punto de los
otros m@'etodos de acceso remoto: RSH/SSH, kserver (Kerberos 4) y GSSAPI
(que incluye Kerberos 5 entre otras cosas).  Deber@'{@dotless{i}}a notarse que no hay que
hacer nada especial para las conexiones con RSH/SSH, aparte de asegurarse
de que el usuario en cuesti@'on puede entrar en la m@'aquina del repositorio
usando RSH o SSH.  Si pueden y CVS est@'a instalado tanto en el cliente como
en el servidor, y tienen los permisos adecuados para usar el repositorio
directamente desde la m@'aquina servidora, deber@'{@dotless{i}}an poder acceder al
repositorio remotamente por medio del m@'etodo :ext:.

Las descripciones de algunas caracter@'{@dotless{i}}sticas especializadas de CVS se han
dejado para cap@'{@dotless{i}}tulos posteriores, para que puedan introducirse en contextos
en los que su utilidad es evidente.  Pueden encontrarse consejos generales
de soluci@'on de problemas de CVS en @ref{Problemas y Soluciones}.  Aunque
no es necesario leerse el manual Cederqvist entero, deber@'{@dotless{i}}a familiarizarse
con @'el; ser@'a una herramienta de referencia de valor incalculable.  Si por
alguna raz@'on no tiene Info en su m@'aquina y no quiere imprimir el manual, puede
hojearlo en l@'{@dotless{i}}nea en @uref{http://durak.org/cvswebsites/doc/} o
@uref{http://www.loria.fr/~molli/cvs/doc/cvs_toc.html}.
