@c ---------------------------------------------------------
@node Problemas y Soluciones
@unnumbered Problemas y Soluciones

@comment Este cap@'{@dotless{i}}tulo ha sido traducido por:
@comment Juan Jos@'e Amor Iglesias <jjamor@@hispalinux.es>
@comment se ceden todos los derechos bajo la licencia de documentaci@'on de
@comment la GNU (fdl) que se puede encontrar en http://www.gnu.org/
@comment  
@comment $Id: chapter-8.texi,v 1.5 2002/12/05 19:10:27 jfs Exp $


Coment@'e en cap@'{@dotless{i}}tulos anteriores que CVS no es un software de "caja
negra". Las cajas negras no le permiten ver lo que hay dentro; no le dan
acceso interno que le permita arreglar (o estropear) cosas. La causa es
que la caja negra normalmente no necesitar@'a ser revisada por usted. Casi
siempre, el software funcionar@'a correctamente, por lo que los usuarios
no necesitar@'an acceso interno. Pero cuando las cajas negras fallan,
tienden a hacerlo completamente. Cualquier problema ser@'a un "exitazo",
puesto que no hay muchas opciones para reparar.

CVS es m@'as bien como una caja perfectamente transparente. Sus partes
"m@'oviles" est@'an expuestas directamente al entorno, y fallos de ese
entorno (permisos inesperados en ficheros, comandos interrumpidos,
procesos en competencia, etc) pueden a veces influir en el mecanismo
interno y producir fallos. Pero aunque CVS no siempre funciona a la
perfecci@'on, raramente falla por completo. Tiene la ventaja de tener una
"degradaci@'on gradual": el porcentaje de fallos es proporcional al n@'umero
y severidad de problemas con el entorno. Si tenemos suficiente idea
acerca de lo que CVS est@'a tratando de hacer -- y c@'omo lo quiere hacer --
sabremos qu@'e hacer cuando las cosas van mal.

Aunque no puedo listar todos los problemas que puede encontrar, he
incluido algunos de los m@'as habituales. Este cap@'{@dotless{i}}tulo est@'a dividido en
dos partes: la primera describe aquellas partes del entorno a las que
CVS es m@'as sensible (principalmente, permisos del repositorio y de la copia
de trabajo del @'area administrativa), y la segunda describe algunos de
los problemas que se encuentran con m@'as frecuencia y sus
soluciones. Observando c@'omo se gestionan esas situaciones, obtendremos
una capacidad para acercarnos a la soluci@'on de otros problemas con CVS
no descritos aqu@'{@dotless{i}}.

@menu
* Causas Usualmente Sospechosas::            Cosas que suelen causar problemas.
* Trucos Habituales::                        T@'ecnicas de diagnosis habituales.
* Algunos Problemas de la Vida Real (con Soluciones):: Compendio de problemas t@'{@dotless{i}}picos.
@end menu

@c ---------------------------------------------------------------
@node Causas Usualmente Sospechosas
@section Causas Usualmente Sospechosas

Como administradores de CVS (l@'ease "m@'edicos del CVS"), encontraremos que
el 90 por ciento de los problemas de nuestros usuarios estar@'an causados
por copias de trabajo inconsistentes, y el otro 90 por ciento por
permisos incorrectos en el repositorio. No obstante, antes de investigar
cualquier situaci@'on concreta, mostraremos una vista r@'apida de la copia
de trabajo del @'area administrativa y revisaremos algunas cosas
importantes acerca de los permisos en el repositorio.

@menu
* La Copia de Trabajo del @'Area Administrativa::
* Permisos del Repositorio::
@end menu

@c ----------------------------------------------------------------
@node La Copia de Trabajo del @'Area Administrativa
@subsection La Copia de Trabajo del @'Area Administrativa

Ya vimos la estructura de la copia de trabajo en @ref{Una 
introduccion a CVS}; en esta secci@'on entraremos un poco m@'as en detalle.
Casi todos los detalles conciernen a los ficheros de los directorios
administrativos bajo CVS/. Ya conocemos los ficheros Entries, Root y
Repository, pero en el directorio CVS/ tambi@'en puede haber otros
ficheros, seg@'un las circunstancias. Describir@'e esos ficheros aqu@'{@dotless{i}},
parcialmente para que no nos sorprenda encontrarlos, y tambi@'en para que
sepamos c@'omo corregir errores que eventualmente se produzcan en ellos. 

@heading @file{CVS/Entries.Log}

A veces, aparecer@'a un extra@~no fichero @file{CVS/Entries.Log}. El @'unico
prop@'osito de este fichero es hacer de cache temporal de los cambios
menores de CVS/Entries, hasta que haya suficientes cambios acumulados
para modificar este fichero. CVS no es capaz de editar directamente el
fichero Entries, por el contrario tiene que leerlo y sobreescribirlo por
completo para cualquier cambio. Para evitar excesiva carga, CVS a veces
guarda los cambios peque@~nos en Entries.log, hasta la pr@'oxima vez que
necesite reescribir el fichero Entries.

El formato de Entries.log es como el de Entries, salvo que adem@'as
incluye una letra al principio de cada l@'{@dotless{i}}nea. @code{A} significa que la
l@'{@dotless{i}}nea ser@'a a@~nadida al fichero Entries, y @code{R} significa que esa
l@'{@dotless{i}}nea ser@'a borrada.

Casi siempre podemos ignorar el fichero Entries.log; es raro que un
administrador tenga que entender la informaci@'on que contiene. Sin
embargo, si estamos depurando alg@'un problema que nos pide examinar el
fichero Entries, probablemente tengamos que echar un vistazo tambi@'en a
Entries.log.

@heading @file{CVS/Entries.Backup}

El fichero CVS/Entries.backup es el que usa CVS para escribir un fichero
Entries nuevo, antes de renombrarlo a @file{Entries} (similarmente al
mecanismo de escribir en ficheros temporales RCS y luego renombrarlos
convenientemente). Debido a que se renombra a Entries cuando est@'a
acabado, ser@'an pocas las veces que veremos el fichero Entries.Backup; si
lo vemos alguna vez se deber@'a probablemente a la interrupci@'on de un
proceso CVS en medio de alguna operaci@'on.

@heading @file{CVS/Entries.Static}

Si existe el fichero CVS/Entries.Static, significa que el directorio
completo no ha sido extraido del repositorio. (Cuando CVS sabe que un
directorio est@'a en un estado incompleto, @'el no a@~nadir@'a ficheros
adicionales a ese directorio.)

El fichero Entries.Static existe durante las operaciones de checkout y
actualizaci@'on, y se borra inmediatamente al completar la operaci@'on. Si
vemos el fichero, significar@'a que CVS fue interrumpido, y su existencia
impide a CVS crear cualquier fichero nuevo en la copia de
trabajo. (Ahora bien , ejecutando @w{@code{cvs update -d}} se soluciona
el problema y se borra Entries.Static.)

La ausencia de Entries.Static no implica necesariamente que la copia de
trabajo incluya todos los ficheros del proyecto. Tan pronto se crea un
nuevo directorio en el repositorio del proyecto, y alguien actualiza su
copia sin incluir el flag -d a la orden update, el nuevo directorio no
se crear@'a en la copia de trabajo. Localmente, CVS no sabe que existe el
nuevo directorio, luego @'el mismo borrar@'a el fichero Entries.Static
cuando la actualizaci@'on termine, aunque el nuevo directorio no se haya
creado en la copia de trabajo.

@heading @file{CVS/Tag}

Si existe el fichero CVS/Tag, nombrar@'a a un tag asociado, en cierto
sentido, con el directorio. Digo "en cierto sentido" ya que, como
sabemos, CVS no mantiene informaci@'on sobre versiones de directorios y,
hablando con precisi@'on, no puede asociar tags a ellos. Los tags se
asocian solo a ficheros normales o, m@'as precisamente, a revisiones
concretas de ficheros normales.

Sin embargo, si cada fichero de un directorio est@'a en un tag concreto,
CVS presupone que el directorio tambi@'en est@'a en ese tag. Por ejemplo, si
@'{@dotless{i}}bamos a extraer de CVS una copia de trabajo de una rama concreta:

@example
floss$ cvs co -r Bugfix_Rama_1
@end example

y luego insertamos un fichero en ella, querremos que la versi@'on inicial
del fichero est@'e en esa rama tambi@'en. Por razones similares, CVS
tambi@'en necesita conocer si el directorio tiene un tag de que no es rama
(non-branch) o la fecha puesta en @'el.

Los ficheros de tags contienen una l@'{@dotless{i}}nea. El primer car@'acter de la l@'{@dotless{i}}nea
es un c@'odigo de una letra que indica qu@'e clase de tag es, y el resto es
el nombre del tag. Actualmente, CVS solo utiliza las siguientes tres
letras como c@'odigo:

@itemize

@item
T -- Tag de rama

@item
N -- Tag de que no es rama (regular tag)

@item
D -- Fecha "pegada", que se utiliza si un comando como

@example
floss$ cvs checkout -D 1999-05-15 myproj
@end example

o

@example
floss$ cvs update -D 1999-05-15 myproj
@end example

se ejecuta.

@end itemize

(Si vemos cualquier otro c@'odigo de una letra, simplemente nos indicar@'a
que CVS ha a@~nadido un nuevo tipo de tag posteriormente a la escritura de
este libro.)

El fichero Tag no debe ser borrado manualmente; en su lugar use @w{@code{cvs
update -A}}.

@heading Rarezas

Hay otros ficheros que ocasionalmente se encontrar@'an en un directorio CVS/:

@itemize
@item CVS/Checkin.prog, CVS/Update.prog
@item CVS/Notify, CVS/Notify.tmp
@item CVS/Base/, CVS/Baserev, CVS/Baserev.tmp
@item CVS/Template
@end itemize

Estos ficheros no son, normalmente, causa de problemas, por lo que
simplemente los vamos a listar (v@'ease @ref{Referencia de CVS} para conocer
su significado completo).

@c -------------------------------------------------------------------
@heading Portabilidad y extensiones futuras.

Conforme se a@~nadan nuevas caracter@'{@dotless{i}}sticas a CVS, podr@'an aparecer nuevos
ficheros (no listados aqu@'{@dotless{i}}) en las @'areas administrativas. Conforme
dichos ficheros sean a@~nadidos, probablemente ser@'an documentados en el
manual de Cederqvist, en la secci@'on @cite{Working Directory
Storage}. Tambi@'en podemos mirar en el c@'odigo fuente, en src/cvs.h, si
preferimos aprender a partir de las fuentes.

Finalmente, observemos que todos los ficheros CVS/* -- actuales y
futuros -- siguen las convenciones de final de l@'{@dotless{i}}nea apropiadas al
sistema en uso (por ejemplo, LF para Unix o CR/LF para Windows). Esto
significa que si llevamos una copia de trabajo desde una plataforma a
otra, puede suceder que CVS no pueda manejarla (adem@'as, podemos tener
otros problemas, debido a que los ficheros controlados por el sistema de
versiones pueden tener ellos mismos un fin de l@'{@dotless{i}}nea inapropiado).

@c --------------------------------------------------------
@node Permisos del Repositorio
@subsection Permisos del Repositorio

CVS no necesita ning@'un esquema espec@'{@dotless{i}}fico de permisos -- puede manejar
una amplia variedad de esquemas. Sin embargo, para evitar situaciones
confusas, se debe configurar el repositorio siguiendo como m@'{@dotless{i}}nimo los
siguientes criterios:

@itemize 

@item
Si un usuario quiere alg@'un tipo de acceso -- incluso acceso solo-lectura
-- a un determinado directorio del repositorio, normalmente necesitar@'a
permisos de escritura a nivel de sistema sobre ese directorio. Esto es
necesario ya que CVS crea ficheros cerrojo temporales en el repositorio
para asegurarse la consistencia de los datos. Aun en operaciones de solo
lectura (como la extracci@'on o actualizaci@'on de una copia de trabajo), se
crear@'an cerrojos, para asegurar que los datos permanecen constantes
durante la operaci@'on.

Como se indica en @ref{Administracion del Repositorio}, podemos salvar este
requisito ajustando el par@'ametro LockDir del fichero CVSROOT/config. Por
ejemplo:

@example
LockDir=/usr/local/cvslocks
@end example

Por supuesto, habr@'a que asegurarse de que todos los usuarios de CVS
pueden escribir sobre /usr/local/cvslocks. De otro modo, el directorio
ser@'a el del repositorio; si somos muy estrictos con la seguridad,
deber@'{@dotless{i}}amos cambiar este directorio por otro.

@item
Asegur@'emosnos de que el fichero CVSROOT/history es escribible por todo
el mundo, ya que si este fichero existe, casi todas las operaciones de CVS
intentar@'an concatenar su hist@'orico en este fichero, y si no lo pueden
hacer terminar@'an con error.

Por desgracia (e inexplicablemente), el fichero de hist@'orico no se crea
escribible por todo el mundo cuando se crea un repositorio nuevo con cvs
init. Al menos con la versi@'on actual de CVS, debemos cambiar los
permisos de manera expl@'{@dotless{i}}cita una vez creado el repositorio (o
simplemente borrarlo, si no queremos que se almacenen los hist@'oricos).

(Este problema puede terminar pronto -- acabo de enviar un parche a los
mantenedores de CVS para que se cree el hist@'orico con los permisos
apropiados cuando se crea. Luego si usamos una versi@'on de CVS posterior
a septiembre de 1999, probablemente el problema habr@'a desaparecido.)

@item
Por razones de seguridad, hay que asegurarse de que los usuarios de CVS
no tienen acceso de escritura a nivel de Unix al directorio CVSROOT.
Si alguien tiene acceso de inserci@'on en CVSROOT, podr@'{@dotless{i}}a editar cualquier
fichero disparador de su elecci@'on (commitinfo, loginfo, etc), invocando
cualquier programa que desee. En general, el acceso a CVSROOT por parte
de un usuario de CVS implica la posibilidad de ejecutar cualquier
comando del sistema.


@end itemize

@c -------------------------------------------------------
@node Trucos Habituales
@section Trucos Habituales

Este cap@'{@dotless{i}}tulo est@'a organizado como una serie de preguntas y respuestas,
de manera similar a una FAQ (Preguntas Frecuentes) de Internet. Todas
ellas se basan en la experiencia habitual con CVS. Pero antes de mostrar
casos m@'as individuales, tomemos unos minutos para considerar los
problemas de CVS desde un punto de vista m@'as general.

El primer paso en la resoluci@'on de un problema con CVS es determinar si
sucede en una copia de trabajo o es un problema del repositorio. La
mejor t@'ecnica para hacerlo, es ver si el problema se repite en
copias de trabajo distintas del mismo repositorio. Si sucede as@'{@dotless{i}}, ser@'a
probablemente un problema del repositorio; en otro caso estar@'a limitado
a la copia local.

Los problemas con las copias de trabajo suelen encontrarse m@'as
frecuentemente, simplemente porque son m@'as numerosas que los
repositorios y no porque sean m@'as "inestables". Aunque con algo de
paciencia se pueden resolver la mayor@'{@dotless{i}}a de los problemas, muchas veces
la soluci@'on m@'as sencilla y eficiente ser@'a borrar y volver a crear la
copia de trabajo.

Por supuesto, si crear la copia de trabajo resulta tedioso, o hay muchas
cosas pendientes de enviar al repositorio como para permitirse el lujo
de borrarlo, o simplemente somos de los que queremos averiguar el por
qu@'e de las cosas, siempre podemos intentarlo. En primer lugar,
normalmente miraremos los subdirectorios CVS/, comprobando los ficheros
y sus permisos. A veces, los permisos se hacen misteriosamente de solo
lectura o simplemente sin permisos de lectura. Sospechamos que es debido
a que los usuarios se equivocan con alguna orden Unix relacionada y
cambian los permisos sin saberlo.

Los problemas en el repositorio se suelen producir por permisos
incorrectos en ficheros y directorios. Si sospechamos que el problema
pueda deberse a esto, primero miremos cu@'al es el UID efectivo en el
repositorio de la persona que origina el problema. Con usuarios locales
y remotos, suele ser un problema con el usuario que se especific@'o
durante la creaci@'on de la copia de trabajo. Si se usa el m@'etodo pserver
con alias de usuario (v@'ease la secci@'on @ref{Acceso anonimo} en el cap@'{@dotless{i}}tulo
@ref{Administracion del Repositorio}), el ID de usuario efectivo estar@'a en el
fichero CVSROOT/passwd. Si no se ve esto a tiempo puede provocarnos una
gran p@'erdida de tiempo buscando la soluci@'on al problema en otros sitios.

Y ahora veamos problemas m@'as concretos...

@c ---------------------------------------------------------------
@node Algunos Problemas de la Vida Real (con Soluciones)
@section Algunos Problemas de la Vida Real (con Soluciones)

Las siguientes son situaciones que se me han dado en mi experiencia como
administrador de CVS (m@'as algunas cosas que no son problemas realmente,
simplemente cuestiones que he oido por ah@'{@dotless{i}} y creo interesante contar
aqu@'{@dotless{i}}). La lista pretende ser bastante completa y puede repetir cosas que
ya hayamos visto en cap@'{@dotless{i}}tulos anteriores.

Las situaciones se listan de acuerdo a la frecuencia con la que se
suelen dar, poniendo en primer lugar las m@'as habituales.

@menu
* CVS dice que est@'a esperando un cerrojo; ¿qu@'e significa esto?::
* CVS dice que un fichero ha fallado la comprobaci@'on Up-To-Date (actualizado); ¿qu@'e hago?::
* El m@'etodo de acceso pserver no funciona::
* El m@'etodo pserver SIGUE sin funcionar::
* Mis env@'{@dotless{i}}os (commits) parecen tener lugar a trozos y no at@'omicamente::
* CVS ignora los permisos que pongo; ¿por qu@'e lo hace?::
* El CVS de Windows dice que no puede encontrar mi fichero .cvspass ¿por qu@'e?::
* Mi copia de trabajo est@'a en diferentes ramas ¿una ayuda?::
* Cuando hago export -d a veces pierdo commits recientes::
* Obtengo un error de val-tags; ¿qu@'e hago?::
* Tengo problemas con los tags adhesivos; ¿c@'omo evitarlos?::
* Las extracciones/actualizaciones terminan con el error 'cannot expand modules'::
* No puedo desactivar los watches::
* Mis ficheros binarios se han corrompido::
* CVS no hace correctamente las conversiones de fin de l@'{@dotless{i}}nea::
* ¿C@'omo se borra un directorio del proyecto?::
* ¿Puedo copiar ficheros .cvspass o parte de ellos?::
* Acabo de enviar algunos ficheros con un mensaje hist@'orico incorrecto::
* Necesito mover ficheros sin perder el hist@'orico de revisiones::
* ¿Como puedo obtener la lista de todas las etiquetas del proyecto?::
* ¿Como obtener una lista de todos los proyectos del repositorio?::
* Algunos comandos fallan en remoto pero no en local; ¿c@'omo lo depuramos?::
* Mi problema no est@'a explicado en este cap@'{@dotless{i}}tulo::
* Creo que he descubierto un bug en CVS; ¿qu@'e hago?::
* He a@~nadido una caracter@'{@dotless{i}}stica a CVS; ¿a qui@'en la env@'{@dotless{i}}o?::
* ¿Como puedo mantenerme informado de las novedades en CVS?::
@end menu

@c ---------------------------------------------------------------------
@node CVS dice que est@'a esperando un cerrojo; ¿qu@'e significa esto?
@subsection CVS dice que est@'a esperando un cerrojo; ¿qu@'e significa esto?

Si vemos un mensaje como este:

@example
cvs update: [22:58:26] waiting for qsmith's lock in /usr/local/newrepos/myproj
@end example

significa que estamos intentando acceder a un subdirectorio del
repositorio que est@'a bloqueado por otro proceso CVS en este momento. Un
proceso est@'a corriendo en ese subdirectorio, luego puede hacerlo
inconsistente a otros procesos CVS que quieran acceder a @'el.

Sin embargo, si el mensaje de espera persiste mucho tiempo,
probablemente indique que un proceso CVS ha fallado en su limpieza
final, por alguna raz@'on. Puede pasar cuando CVS muere de pronto e
inesperadamente, por una ca@'{@dotless{i}}da de la m@'aquina del repositorio, por ejemplo.

La soluci@'on es borrar los ficheros de cerrojo a mano del subdirectorio
del repositorio en cuesti@'on. Entremos en ese lugar y busquemos ficheros
con el nombre @file{#cvs.lock} o que empiecen por @file{#cvs.wfl} o
@file{#cvs.rfl}. Comparemos las fechas de los ficheros con los instantes
de inicio de cualquier proceso CVS actual. Si los ficheros no han podido
ser creados por esos procesos (son m@'as antiguos), podemos borrarlos
tranquilamente. Los procesos CVS en espera se dar@'an cuenta del borrado
(normalmente cada 30 segundos lo revisan) y terminar@'an su operaci@'on.

V@'ease el nodo @cite{Locks} en el manual de Cederqvist para m@'as detalle.

@c ---------------------------------------------------------------------
@node CVS dice que un fichero ha fallado la comprobaci@'on Up-To-Date (actualizado); ¿qu@'e hago?
@subsection CVS dice que un fichero ha fallado la comprobaci@'on Up-To-Date (actualizado); ¿qu@'e hago?

Evitemos el p@'anico -- solo significa que el fichero ha cambiado en el
repositorio desde la @'ultima vez que nos lo bajamos o actualizamos.

Ejecutemos @w{@code{cvs update}} en el fichero para mezclar los cambios
del repositorio con los que hayamos hecho nosotros. Si los cambios
recibidos entran en conflicto con los nuestros, ed@'{@dotless{i}}tese el fichero para
resolver los conflictos. A continuaci@'on intentemos de nuevo enviar los
cambios al repositorio -- tendr@'a exito, a menos que otra persona haya
vuelto a actualizar el fichero durante su trabajo.

@c ---------------------------------------------------------------------
@node El m@'etodo de acceso pserver no funciona
@subsection El m@'etodo de acceso pserver no funciona

La causa m@'as com@'un, pero no precisamente obvia, es que hayamos olvidado
la opci@'on @code{--allow-root} en la configuraci@'on de inetd.

Recordemos este ejemplo de l@'{@dotless{i}}nea de /etc/inetd.conf:

@example
cvspserver stream tcp nowait root /usr/local/bin/cvs cvs \
          --allow-root=/usr/local/newrepos pserver
@end example

(En el fichero real ser@'a una sola l@'{@dotless{i}}nea, sin barra invertida.)

La parte @code{--allow-root=/usr/local/newrepos} es una medida de
seguridad, para asegurarnos de que la gente no pueda usar CVS para
obtener acceso pserver a repositorios que se supone no son servidos
remotamente. Cualquier repositorio que se desee accesible por pserver,
debe estar mencionado en la opci@'on @code{--allow-root}. Podemos tener
todas las opciones de este tipo que deseemos, para dar acceso a todos
los repositorios que hagan falta (mientras no llenemos la longitud
m@'axima de l@'{@dotless{i}}nea de la configuraci@'on del inetd).

V@'ease el cap@'{@dotless{i}}tulo @ref{Administracion del Repositorio} para m@'as detalle sobre
la configuraci@'on del servidor autentificado con contrase@~na.

@c ---------------------------------------------------------------------
@node El m@'etodo pserver SIGUE sin funcionar
@subsection El m@'etodo pserver SIGUE sin funcionar

De acuerdo, si el problema no es la ausencia de una opci@'on
@code{--allow-root}, veamos otras posibles causas:

@itemize

@item
El usuario no tiene una entrada en el fichero CVSROOT/passwd, y el
fichero CVSROOT/config tiene la opci@'on SystemAuth=no, por lo que CVS no
buscar@'a el usuario en el fichero de usuarios del sistema (o bien
SystemAuth=yes pero no existe ese usuario en el sistema).

@item
El usuario tiene una entrada en el fichero CVSROOT/passwd, pero no hay
usuario con ese nombre en el sistema, por lo que no se puede mapear a un
usuario v@'alido.

@item
La contrase@~na es incorrecta (aunque como CVS suele informar de esto
convenientemente, casi seguro que nuestro problema no ser@'a @'este).

@item
Todo est@'a correcto en los ficheros de claves y en /etc/inetd.conf, pero
se nos olvid@'o una entrada como @'esta en /etc/services:

@example
cvspserver      2401/tcp
@end example

por lo que inetd no es capaz de saber qu@'e puerto es cvspserver.

@end itemize

@c ---------------------------------------------------------------------
@node Mis env@'{@dotless{i}}os (commits) parecen tener lugar a trozos y no at@'omicamente
@subsection Mis env@'{@dotless{i}}os (commits) parecen tener lugar a trozos y no at@'omicamente

Esto es porque CVS hace los env@'{@dotless{i}}os a trozos, y no at@'omicamente. :-)

M@'as espec@'{@dotless{i}}ficamente, las operaciones de CVS tienen lugar directorio a
directorio. Cuando hacemos un commit (o update o cualquier cosa)
afectando a varios directorio, CVS bloquea cada directorio mientras hace
la operaci@'on en @'el, desbloque@'andolo antes de pasar al siguiente.

Para proyectos peque@~nos o medianos, raramente ser@'a esto un problema, ni
notaremos que la operaci@'on no es at@'omica. Sin embargo, en proyectos
grandes, se pueden dar escenarios como el siguiente (imaginemos que el
proyecto tiene al menos dos directorios A y B, con muchos ficheros):

@enumerate

@item
El usuario pperez inicia un env@'{@dotless{i}}o (commit), afectando a ficheros de
ambos directorios. CVS env@'{@dotless{i}}a los ficheros de B en primer lugar (porque
el usuario lo especific@'o en ese orden).

@item
El usuario jsuerte inicia una actualizaci@'on (update). Por alguna raz@'on,
supongamos que @'esta se inicia copiando el directorio A (CVS no garantiza
ning@'un orden por su cuenta). Obs@'ervse que no hay bloqueo aun porque
pperez aun no est@'a activo en A.

@item
Ahora, el env@'{@dotless{i}}o de pperez finaliza B, se va a A y finaliza A.

@item
Finalmente, la actualizaci@'on de jsuerte se va a B y finaliza.

@end enumerate

Claramente, cuando todo acaba, la copia de trabajo de jsuerte refleja
los cambios de pperez en B pero no en A. Aunque pperez intentase hacerlo
at@'omicamente, no hay forma. Ahora la copia de jsuerte est@'a en un estado
que desconoce pperez.

La soluci@'on, por supuesto, es que jsuerte haga de nuevo el cvs
update.

El fallo de no permitir transacciones at@'omicas es considerado
ampliamente como un error de CVS. La @'unica raz@'on por la que los cerrojos
no se establecen en la ra@'{@dotless{i}}z del repositorio es porque esto resultar@'{@dotless{i}}a
inaceptable para grandes proyectos con m@'ultiples desarrolladores. Para
mitigar este problema, en CVS se escogi@'o bloquear a nivel de cada
directorio, reduciendo as@'{@dotless{i}} la contenci@'on. Alguna vez alguien podr@'{@dotless{i}}a
modificar CVS para acelerar sus operaciones, de manera que se mejore
esta situaci@'on.

Para m@'as informaci@'on, v@'ease el nodo @cite{Concurrency} del manual de
Cederqvist.

@c ---------------------------------------------------------------------
@node CVS ignora los permisos que pongo; ¿por qu@'e lo hace?
@subsection CVS ignora los permisos que pongo; ¿por qu@'e lo hace?

En general, CVS no realiza un muy buen trabajo para preservar los
permisos de los ficheros. Cuando importamos un proyecto y luego lo
extraemos, no hay garant@'{@dotless{i}}a de que en la copia de trabajo obtenida los
ficheros tengan los mismos permisos que cuando fueron importados. M@'as
bien, lo que sucede es que los ficheros de la copia de trabajo se crean
con el esquema de permisos est@'andar que tengamos en nuestra cuenta de usuario.

Sin embargo, hay al menos una excepci@'on. Si queremos almacenar scripts
de shell ejecutables en el proyecto, podemos mantenerlos ejecutables en
todas las copias de trabajo sin m@'as que hacer ejecutable el fichero del
repositorio:

@example
floss$ ls -l /usr/local/mirepo/unproyecto
total 6
-r--r--r--   1 jsuerte  users         630 Aug 17 01:10 README.txt,v
-r-xr-xr-x   1 jsuerte  users        1041 Aug 17 01:10 scrub.pl,v*
-r--r--r--   1 jsuerte  users         750 Aug 17 01:10 hola.c,v
@end example

N@'otese que aunque el fichero es ejecutable, se mantiene en solo-lectura,
como debe ser en todos los ficheros de un repositorio (recordar que CVS
trabaja haciendo los cambios sobre una copia temporal del fichero RCS,
que luego reemplaza al original).

Cuando importamos o a@~nadimos un fichero ejecutable, CVS preserva los
bits de ejecuci@'on, de manera que si los permisos iniciales son
correctos, en general no habr@'a que preocuparse m@'as. Sin embargo, si
accidentalmente a@~nadimos el fichero antes de hacerlo ejecutable, debemos
ir al repositorio y cambiar los bits a mano sobre el fichero RCS.

Los permisos del repositorio siempre predominan. Si el fichero no es
ejecutable en el repositorio pero s@'{@dotless{i}} lo es en la copia de trabajo,
cuando hagamos una actualizaci@'on seguir@'a como est@'e en el repositorio.
Cuando los permisos de los ficheros cambian misteriosamente puede ser
frustrante. Si esto sucede, comprobar primero los permisos en el
repositorio y ver si podemos resolverlo ajustando los permisos sobre los
ficheros RCS.

Recientemente se a@~nadi@'o a CVS una caracter@'{@dotless{i}}stica denominada
@code{PreservePermissions} que puede aliviar alguno de estos
problemas. Sin embargo, usando esta caracter@'{@dotless{i}}stica pueden producirse
otros resultados inesperados (por lo que no recomiendo usarla
siempre). Nos debemos asegurar de leer antes los nodos @cite{config} y
@cite{Special Files} del manual de Cederqvist antes de incluir
@code{PreservePermissions=yes} en CVSROOT/config.

@c ---------------------------------------------------------------------
@node El CVS de Windows dice que no puede encontrar mi fichero .cvspass ¿por qu@'e?
@subsection El CVS de Windows dice que no puede encontrar mi fichero .cvspass ¿por qu@'e?

Para conexiones pserver, el CVS del lado cliente intenta encontrar el
fichero .cvspass en el directorio principal de la cuenta (HOME). Las
m@'aquinas con Windows no tienen un directorio "home" natural, por lo que
CVS consulta la variable @code{%HOME%}. Sin embargo, hay que ser
cuidadosos con esta variable. Esto funcionar@'a:

@example
set HOME=C:
@end example

Pero esto no:

@example
set HOME=C:\
@end example

Esta barra extra es suficiente para confundir a CVS y ser@'a incapaz de
abrir el fichero @file{C:\\.cvspass}.

La m@'as r@'apida y segura soluci@'on, pues, es poner

@example
set HOME=C:
@end example

en el fichero autoexec.bat y reiniciar. El pserver de CVS debe funcionar
ahora correctamente.

@c ---------------------------------------------------------------------
@node Mi copia de trabajo est@'a en diferentes ramas ¿una ayuda?
@subsection Mi copia de trabajo est@'a en diferentes ramas ¿una ayuda?

¿Hablamos de diferentes subdirectorios de la copia de trabajo en
diferentes ramas? Probablemente hemos ejecutado updates con la opci@'on
-r, pero en lugares distintos de la ra@'{@dotless{i}}z de la copia de trabajo.

No hay problema. Si queremos volver a lo correcto, ejecutemos esto

@example
cvs update -r HEAD
@end example

o esto

@example
cvs update -A
@end example

desde el directorio ra@'{@dotless{i}}z. O, si lo que queremos es poner la copia de
trabajo a una de las ramas, hacer esto:

@example
cvs update -r Nombre_rama
@end example

No hay problema por tener uno o dos subdirectorios de la copia de
trabajo pertenecientes a diferentes ramas, si lo que queremos es hacer
alg@'un trabajo en esa rama temporalmente solo en esos ficheros. Sin
embargo, ser@'a una buena idea normalmento volver cuando acabemos -- la
vida ser@'a mucho menos confusa cuando toda nuestra copia de trabajo
pertenezca a la misma l@'{@dotless{i}}nea de desarrollo.

@c ------------------------------------------------------------------------
@node Cuando hago export -d a veces pierdo commits recientes
@subsection Cuando hago export -d a veces pierdo commits recientes

Esto se debe a una diferencia entre el reloj de la m@'aquina del
repositorio y el local. Podemos resolverlo ajustando uno o ambos
relojes, o especificando una fecha distinta con la opci@'on -D. Es
perfectamente aceptable el especificar una fecha del futuro (tal como -D
tomorrow), si esto puede compensar la diferencia de tiempos.

@c ---------------------------------------------------------------------
@node Obtengo un error de val-tags; ¿qu@'e hago?
@subsection Obtengo un error de val-tags; ¿qu@'e hago?

Si obtenemos un error como este:

@example
cvs [export aborted]: cannot write /usr/local/myproj/CVSROOT/val-tags: \
   Operation not permitted
@end example

significa que el CVS del usuario est@'a corriendo y no tiene permiso para
escribir el fichero CVSROOT/val-tags. Este fichero almacena nombres de 
tags, para que CVS tenga una manera r@'apida de determinar qu@'e tags son
v@'alidos. Desafortunadamente, CVS a veces modifica este fichero en
operaciones que deber@'{@dotless{i}}an ser solo-lectura respecto del repositorio, como
una simple extracci@'on (check-out) del proyecto.

Esto es un error de CVS y debe haberse corregido mientras leemos
esto. Hasta entonces, la soluci@'on es hacer que el fichero val-tags sea
escribible por todo el mundo o, si esto falla, borrarlo o poner de
propietario al usuario que est@'a intentando operar. (Podr@'{@dotless{i}}amos pensar que
cambiar los permisos es suficiente, pero a veces he tenido que tambiar
tambi@'en al propietario.)

@c ---------------------------------------------------------------------
@node Tengo problemas con los tags adhesivos; ¿c@'omo evitarlos?
@subsection Tengo problemas con los tags adhesivos; ¿c@'omo evitarlos?

Algunas operaciones del CVS hacen que la copia de trabajo tengan un
@dfn{tag adhesivo}, que es un tag que corresponde a cada revisi@'on de
cada fichero (en el caso de una rama, el tag adhesivo se aplica a
cualquier fichero que se a@~nada a la copia de trabajo). Obtendremos un
@'area de trabajo con tags adhesivos cuando extraigamos o actualicemos por
tag o por fecha, por ejemplo:

@example
floss$ cvs update -r Nombre_Tag
@end example

o

@example
floss$ cvs checkout -D '1999-08-16'
@end example

Si se usa una fecha o un nombre de tag que no sea rama, la copia de
trabajo ser@'a una foto congelada de ese momento en el hist@'orico del
proyecto -- por lo que naturalmente no podremos enviar cambios de
ninguna clase desde @'el.

Para eliminar un tag adhesivo actualizaremos con el flag -A

@example
floss$ cvs update -A
@end example

que limpia todos los tags adhesivos y actualiza cada fichero a su
revisi@'on m@'as reciente.

@c ---------------------------------------------------------------------
@node Las extracciones/actualizaciones terminan con el error 'cannot expand modules'
@subsection Las extracciones/actualizaciones terminan con el error 'cannot expand modules'

Esto es un ejemplo de error fatal de CVS; probablemente alguien lo
intentar@'a corregir pronto, pero mientras tanto nos molestar@'a. El error
es similar al siguiente:

@example
floss$ cvs co -d bwf-misc user-space/bwf/writings/misc 
cvs server: cannot find module `user-space/bwf/writings/misc' - ignored
cvs [checkout aborted]: cannot expand modules
@end example

CVS aparenta estar diciendo que hay algo mal en el fichero
CVSROOT/modules. Sin embargo, lo que realmente ocurre es un problema de
permisos del repositorio. El directorio que estamos intentando extraer
no es legible, o uno de sus ancestros no lo es. En este caso, era un
ancestro:

@example
floss$ ls -ld /usr/local/cvs/user-space/bwf

drwx------  19 bwf      users        1024 Aug 17 01:24 bwf/
@end example

Como vemos no hay que preocuparse demasiado -- es simplemente otro
problema de permisos.

@c ---------------------------------------------------------------------
@node No puedo desactivar los watches
@subsection No puedo desactivar los watches

Probablemente habremos ejecutado

@example
floss$ cvs watch remove
@end example

en todos los ficheros, pero se nos olvid@'o hacer esto otro:

@example
floss$ cvs watch off
@end example

Una sugerencia para diagnosticar errores con los watches: a veces puede
clarificar mucho simplemente el entrar en el repositorio y examinar el
fichero CVS/fileattr directamente. V@'ease @ref{Administracion del Repositorio}
para m@'as informaci@'on sobre esto.

@c ---------------------------------------------------------------------
@node Mis ficheros binarios se han corrompido
@subsection Mis ficheros binarios se han corrompido

¿Nos hemos acordado de usar el modificador -kb al insertarlos? Si no fue
as@'{@dotless{i}}, CVS puede haber realizado expansiones de macros RCS o conversiones
de fin de l@'{@dotless{i}}nea. La soluci@'on m@'as simple es marcarlos como binarios,

@example
floss$ cvs admin -kb ejemplo.gif
@end example

y luego enviar una versi@'on corregida del fichero. CVS no corromper@'a
nuevos env@'{@dotless{i}}os de este fichero, puesto que ya sabe que es binario.

@c ---------------------------------------------------------------------
@node CVS no hace correctamente las conversiones de fin de l@'{@dotless{i}}nea
@subsection CVS no hace correctamente las conversiones de fin de l@'{@dotless{i}}nea

Si hemos ejecutado el cliente CVS en una plataforma no Unix, y no
tenemos las conversiones correctas de final de l@'{@dotless{i}}nea, se deber@'a
normalmente a que hemos a@~nadido los ficheros accidentalmente como
binarios (opci@'on -kb). Esto puede corregirse en el repositorio con el
comando:

@example
floss$ cvs admin -kkv FICHERO
@end example

El modificador -kkv solicita hacer la expansi@'on de macros normal y las
conversiones de fin de l@'{@dotless{i}}nea (internamente, CVS se confunde con la
diferencia entre la expansi@'on de macros y la conversi@'on de fin de
l@'{@dotless{i}}nea. Esta confusi@'on da lugar a que las opciones de -k siempre
controlan ambos aspectos a la vez).


Por desgracia, este comando de administraci@'on solo corrige el fichero en
el repositorio, es decir, nuestra copia local seguir@'a consider@'andose
como binaria. Siempre podemos editar a mano el fichero CVS/Entries
eliminando la opci@'on -kb de la l@'{@dotless{i}}nea correspondiente.

@c ---------------------------------------------------------------------
@node ¿C@'omo se borra un directorio del proyecto?
@subsection ¿C@'omo se borra un directorio del proyecto?

Bien, no podemos borrar el directorio realmente, pero podemos borrar
todos los ficheros que haya dentro (primero hacemos cvs remove y luego
commit). Una vez que el directorio est@'a vac@'{@dotless{i}}o, se eliminar@'a de las
copias de trabajo usando la opci@'on -P durante cualquier actualizaci@'on.

@c ---------------------------------------------------------------------
@node ¿Puedo copiar ficheros .cvspass o parte de ellos?
@subsection ¿Puedo copiar ficheros .cvspass o parte de ellos?

S@'{@dotless{i}}, claro. Se pueden copiar de una m@'aquina a otra, o se pueden
transferir l@'{@dotless{i}}neas individuales de un fichero .cvspass a otro. Para
servidores con acceso lento, esto puede ser m@'as r@'apido que hacer cvs
login en cada m@'aquina.

Recordemos que si transportamos un fichero .cvspass entre dos m@'aquinas
con diferentes convenciones de fin de l@'{@dotless{i}}nea, probablemente no
funcionar@'an (por supuesto, siempre se puede corregir este problema a mano).

@c ---------------------------------------------------------------------
@node Acabo de enviar algunos ficheros con un mensaje hist@'orico incorrecto
@subsection Acabo de enviar algunos ficheros con un mensaje hist@'orico incorrecto

Para resolver esto no hay que editar nada del repositorio. Simplemente
ejecutemos cvs admin con la opci@'on -m. Recu@'erdese no dejar espacios
entre -m y el argumento, y acitar el mensaje hist@'orico tal como se har@'{@dotless{i}}a
normalmente:

@example
floss$ cvs admin -m1.17:'Recientes mejoras en mi mejor programa.' hola.c
@end example

@c ---------------------------------------------------------------------
@node Necesito mover ficheros sin perder el hist@'orico de revisiones
@subsection Necesito mover ficheros sin perder el hist@'orico de revisiones

En el repositorio, copiemos (no movamos) los ficheros RCS al nuevo lugar
deseado. Esto debe respetar sus antiguas localizaciones. Ahora, desde
una copia de trabajo, hagamos lo siguiente:

@example
floss$ rm ficheroviejo1 ficheroviejo2 ...
floss$ cvs remove ficheroviejo1 ficheroviejo2 ...
floss$ cvs commit -m 'Ficheros movidos ...'
@end example

Cuando la gente haga actualizaciones, CVS borrar@'a los ficheros viejos y
los crear@'a en sus nuevos sitios, tal como si se hubiera hecho la
operaci@'on de a@~nadir normalmente (excepto por el hecho de que se siguen
usando los n@'umeros de revisi@'on anteriores).

@c ---------------------------------------------------------------------
@node ¿Como puedo obtener la lista de todas las etiquetas del proyecto?
@subsection ¿Como puedo obtener la lista de todas las etiquetas del proyecto?

Actualmente no hay forma de hacerlo con CVS. Es algo demandado por los
usuarios y se espera que en futuras versiones est@'e disponible. Puede que
pronto (incluso ya) existe un comando @w{@code{cvs tags}} o similar.

Hasta entonces, hay aproximaciones. Podemos ejecutar cvs log -h y leer
las secciones de la salida con la cabecera @code{symbolic names:}. O
bien, si estamos en la m@'aquina del repositorio, podemos mirar en el
principio de algunos ficheros RCS. Todas las etiquetas (rama y no
rama) se listan en el campo @code{symbols}:

@example
floss$ head /usr/local/nuevorep/hola.c,v
head	2.0;
access;
symbols
	Release_1_0:1.22
	Exotic_Greetings-2:1.21
	merged-Exotic_Greetings-1:1.21
	Exotic_Greetings-1:1.21
	merged-Exotic_Greetings:1.21
	Exotic_Greetings-branch:1.21.0.2
	Root-of-Exotic_Greetings:1.21
	start:1.1.1.1
	jrandom:1.1.1;
locks; strict;
comment	@@ * @@;
@end example

@c ---------------------------------------------------------------------
@node ¿Como obtener una lista de todos los proyectos del repositorio?
@subsection ¿Como obtener una lista de todos los proyectos del repositorio?

Al igual que sucede con la lista de etiquetas, no est@'a implementado en
la versi@'on actual de CVS, pero se entiende que lo estar@'a pronto. Imagino
el comando similar a cvs list, con una forma abreviada cvs ls, y
probablemente ambos analizar@'an los m@'odulos y listar@'an los subdirectorios.

Por ahora, examinando el fichero CVSROOT/modules (directamente o
ejecutando cvs checkout -c) podemos conseguirlo. Sin embargo, si nadie
ha hecho un m@'odulo para un proyecto, no veremos nada sobre ese proyecto
en el fichero modules.

@c ---------------------------------------------------------------------
@node Algunos comandos fallan en remoto pero no en local; ¿c@'omo lo depuramos?
@subsection Algunos comandos fallan en remoto pero no en local; ¿c@'omo lo depuramos?

A veces hay un problema de comunicaci@'on entre el cliente y el
servidor. Y puede ser un error de CVS.

CVS proporciona un mecanismo de trazar el protocolo entre el cliente y
el servidor. Antes de ejecutar el comando en la m@'aquina local (con la
copia de trabajo), crear la variable @code{CVS_CLIENT_LOG}. En un shell
de Bash se har@'{@dotless{i}}a as@'{@dotless{i}}:

@example
floss$ CVS_CLIENT_LOG=clog; export CVS_CLIENT_LOG
@end example

Una vez creada la variable, CVS almacenar@'a las comunicaciones entre
cliente y servidor en dos ficheros con el nombre basado en el valor de
la variable anterior:

@example
floss$ ls
CVS/        LEAME.txt    a-subdir/    b-subdir/    prueba.gif     hola.c
floss$ cvs update
? clog.in
? clog.out
cvs server: Updating .
cvs server: Updating a-subdir
cvs server: Updating a-subdir/subsubdir
cvs server: Updating b-subdir
floss$ ls
CVS/              a-subdir/    clog.in     prueba.gif
LEAME.txt        b-subdir/    clog.out    hola.c
floss$ 
@end example

El fichero @file{clog.in} contiene lo enviado por el cliente al
servidor, y el fichero @file{clog.out} contiene los mensajes del
servidor al cliente. Vemos por ejemplo el contenido de clog.out:

@example
Valid-requests Root Valid-responses valid-requests Repository           \
Directory Max-dotdot Static-directory Sticky Checkin-prog Update-prog   \
Entry Kopt Checkin-time Modified Is-modified UseUnchanged Unchanged     \
Notify Questionable Case Argument Argumentx Global_option Gzip-stream   \
wrapper-sendme-rcsOptions Set expand-modules ci co update diff log add  \
remove update-patches gzip-file-contents status rdiff tag rtag import   \
admin export history release watch-on watch-off watch-add watch-remove  \
watchers editors init annotate noop
ok
M ? clog.in
M ? clog.out
E cvs server: Updating .
E cvs server: Updating a-subdir
E cvs server: Updating a-subdir/subsubdir
E cvs server: Updating b-subdir
ok
@end example

El fichero clog.in es m@'as complicado, puesto que incluye n@'umeros de
versi@'on y otras informaciones por cada fichero.

No podemos dedicar espacio aqu@'{@dotless{i}} a documentar el protocolo, pero podemos
leer las p@'aginas Info de @code{cvsclient} que vienen con el paquete de
CVS para m@'as informaci@'on. Comprobaremos que aunque no siempre nos d@'e una
respuesta, mirar el hist@'orico del protocolo puede darnos una buena pista.

@c ---------------------------------------------------------------------
@node Mi problema no est@'a explicado en este cap@'{@dotless{i}}tulo
@subsection Mi problema no est@'a explicado en este cap@'{@dotless{i}}tulo

Lo mejor es enviar una descripci@'on del problema a la lista de discusi@'on
sobre CVS, @email{info-cvs@@gnu.org}. Los miembros est@'an dispersos por
todo el mundo, y por tanto a todas horas suele haber alguien que nos
ayudar@'a casi de inmediato. Para apuntarse a la lista hay que enviar un
mensaje a @email{info-cvs-request@@gnu.org}. Se agradecer@'a que nosotros
tambi@'en ayudemos a resolver problemas a los dem@'as.

@c ---------------------------------------------------------------------
@node Creo que he descubierto un bug en CVS; ¿qu@'e hago?
@subsection Creo que he descubierto un bug en CVS; ¿qu@'e hago?

CVS no es perfecto ... si hemos intentado consultar el manual o
preguntar por ah@'{@dotless{i}} y aun creemos que es un bug, podemos hacer lo siguiente:

Hay que enviar una descripci@'on lo m@'as completa posible del error a
@email{bug-cvs@@gnu.org}. A esta lista tambi@'en podemos suscribirnos
escribiendo a @email{bug-cvs-request@@gnu.org}. Hay que incluir en
nuestra consulta los n@'umeros de versi@'on (cliente y servidor) y el modo
de reproducir el error.

Si hubi@'eramos escrito un parche para corregir el error, incluy@'amoslo y
mencion@'emoslo en la l@'{@dotless{i}}nea del asunto del mensaje. Los desarrolladores lo
agradecer@'an infinitamente.

(En el manual de Cederqvist, en el nodo @cite{BUGS}, encontraremos m@'as
detalles sobre c@'omo seguir estos procedimientos. Tambi@'en hay informaci@'on
en el fichero HACKING de la distribuci@'on del c@'odigo fuente).


@c ---------------------------------------------------------------------
@node He a@~nadido una caracter@'{@dotless{i}}stica a CVS; ¿a qui@'en la env@'{@dotless{i}}o?
@subsection He a@~nadido una caracter@'{@dotless{i}}stica a CVS; ¿a qui@'en la env@'{@dotless{i}}o?

Al igual que con los errores, enviaremos el parche a
@email{bug-cvs@@gnu.org}. Antes tenemos que asegurarnos de que hemos
le@'{@dotless{i}}do el mencionado fichero HACKING.

@c ---------------------------------------------------------------------
@node ¿Como puedo mantenerme informado de las novedades en CVS?
@subsection ¿Como puedo mantenerme informado de las novedades en CVS?

Las t@'ecnicas de resoluci@'on de problemas y los errores conocidos
descritos en este cap@'{@dotless{i}}tulo son para la versi@'on de CVS 1.10.7
(aproximadamente). Pero el mundo CVS se mueve r@'apidamente. Mientras que
escrib@'{@dotless{i}}a los @'ultimos cap@'{@dotless{i}}tulos, el mantenimiento de CVS pas@'o de Cyclic
Software a SourceGear Inc (@uref{http://www.sourcegear.com}), quienes
hab@'{@dotless{i}}an comprado Cyclic. SourceGear ha anunciado p@'ublicamente su
intenci@'on de participar activamente en el equipo de desarrolladores de
CVS y ha recibido la aprobaci@'on de la gente de Cyclic, quienes eran m@'as
o menos los que lo lideraban hasta ahora (la direcci@'on
@uref{http://www.cyclic.com} seguir@'a funcionando, sin embargo, de manera
que todas las URL dadas aqu@'{@dotless{i}} a@'un valen).

SourceGear est@'a, en este preciso momento, ocupada organizando y puliendo
varios parches que estaban circulando por ah@'{@dotless{i}}, con la intenci@'on de
incorporar los que puedan a CVS. Algunos parches probablemente
corregir@'an errores vistos aqu@'{@dotless{i}}, y otros a@~nadir@'an nuevas opciones a los
usuarios.

La mejor forma de mantenerse informado de la evoluci@'on es leer el
fichero NEWS de la distribuci@'on de CVS, vigilando adem@'as las listas de
correo y buscando cambios en el manual de Cederqvist y en la versi@'on en
l@'{@dotless{i}}nea, en ingl@'es, de este libro (@uref{http://cvsbook.red-bean.com}).
