<!--
$Header: /home/cvs/lucas/doc-postgresql-es/v7/src/sgml/REF/create_table.sgml,v 1.2 2001/10/11 21:46:27 rssantos Exp $
Postgres documentation
-->

<refentry id="SQL-CREATETABLE">
 <refmeta>
  <refentrytitle id="sql-createtable-title">
   CREATE TABLE
  </refentrytitle>
  <refmiscinfo>SQL - Sentencias del lenguaje</refmiscinfo>
 </refmeta>
 <refnamediv>
  <refname>
   CREATE TABLE
  </refname>
  <refpurpose>
   Crea una nueva tabla
  </refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <refsynopsisdivinfo>
   <date>1999-07-20</date>
  </refsynopsisdivinfo>
  <synopsis>
CREATE [ TEMPORARY | TEMP ] TABLE <replaceable class="PARAMETER">table</replaceable> (
    <replaceable class="PARAMETER">column</replaceable> <replaceable class="PARAMETER">type</replaceable>
    [ NULL | NOT NULL ] [ UNIQUE ] [ DEFAULT <replaceable class="PARAMETER">value</replaceable> ]
    [<replaceable>column_constraint_clause</replaceable> | PRIMARY KEY } [ ... ] ]
    [, ... ]
    [, PRIMARY KEY ( <replaceable class="PARAMETER">column</replaceable> [, ...] ) ]
    [, CHECK ( <replaceable class="PARAMETER">condition</replaceable> ) ]
    [, <replaceable>table_constraint_clause</replaceable> ]
    ) [ INHERITS ( <replaceable>inherited_table</replaceable> [, ...] ) ]
  </synopsis>
  
  <refsect2 id="R2-SQL-CREATETABLE-1">
   <refsect2info>
    <date>1998-09-11</date>
   </refsect2info>
   <title>
    Entradas
   </title>

   <para>

    <variablelist>
     <varlistentry>
      <term>TEMPORARY</term>
      <listitem>
       <para>
	Se crea la tabla sólo para esta sesión, y es eliminada 
	automáticamente con el fin de la sesión.
	Las tablas permanentes existentes con el mismo nombre no
	son visibles mientras la table temporal existe.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">table</replaceable></term>
      <listitem>
       <para>
	El nombre de una nueva clase o tabla a crear.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">column</replaceable></term>
      <listitem>
       <para>
	El nombre de un campo.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">type</replaceable></term>
      <listitem>
       <para>
	El tipo del campo. Puede incluir especificadores de array.
	Consulte la <citetitle>PostgreSQL User's Guide</citetitle> para
	más información sobre tipos y arrays.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>DEFAULT <replaceable class="PARAMETER">value</replaceable></term>
      <listitem>
       <para>
	Un valor por defecto para el campo.
	Consulte la cláusula DEFAULT para más información.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable>column_constraint_clause</replaceable></term>
      <listitem>
       <para>
	La cláusula opcional de restricciones (constraint) especifica
	una lista de restricciones de integridad o comprueba que las nuevas
	inserciones o actualizaciones deben satisfacer para que la inserción
	o la actualización tenga éxito. Cada restricción debe evaluarse a una
	expresión booleana. Aunque <acronym>SQL92</acronym>
	requiere la <replaceable class="PARAMETER">column_constraint_clause</replaceable>
	para referirse a ese campo sólamente, <productname>Postgres</productname>
	permite que múltiples campos sean referenciados dentro de un único campo constraint.
	Consulte la cláusula constraint para más información.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable>table_constraint_clause</replaceable></term>
      <listitem>
       <para>
	La cláusula opcional CONSTRAINT especifica una lista de restricciones
	de integridad que las nuevas inserciones o las actualizaciones deberán
	satisfacer para que una sentencia insert o update tenga éxito. Cada 
	restricción debe ser evaluada a una expresión booleana. Se pueden referenciar
	múltiples campos con una única restricción.
	Sólo se puede definir una única cláusula PRIMARY KEY por tabla;
	PRIMARY KEY <replaceable>column</replaceable>
	(una restricción de tabla) and PRIMARY KEY (una restricción de campo) son
	mutuamente excluyentes.
	Consulte la cláusula de restricción de tabla para más información.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>INHERITS <replaceable class="PARAMETER">inherited_table</replaceable></term>
      <listitem>
       <para>
	La cláusula opcional INHERITS especifica una colección de nombres de tabla
	de las cuales esta tabla hereda todos los campos.
	Si algún campo heredado aparece más de una vez, 
	<productname>Postgres</productname>
	informa de un error.
	<productname>Postgres</productname> permite automáticamente a la tabla creada
	heredar funciones de las tablas superiores a ella en la jerarquía de herencia.
	<note>
	 <title>Aside</title>
	 <para>
	  La herencia de funciones se realiza siguiendo
	  las convenciones del Common Lisp Object System (CLOS).
	 </para>
	</note>
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>    
  </refsect2>

  <refsect2 id="R2-SQL-CREATETABLE-2">
   <refsect2info>
    <date>1998-09-11</date>
   </refsect2info>
   <title>
    Salidas
   </title>
   <para>

    <variablelist>
     <varlistentry>
      <term><computeroutput>
CREATE
       </computeroutput></term>
      <listitem>
       <para>
	Mensaje devuelto si la table se ha creado con éxito.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><computeroutput>
ERROR
       </computeroutput></term>
      <listitem>
       <para>
	Mensaje devuelto si la creación de la tabla falla.
	Este mensaje viene normalmente acompañado por algún texto explicativo, como:
	<computeroutput>
ERROR:  Relation '<replaceable class="parameter">table</replaceable>' already exists
	</computeroutput>
	que ocurre en tiempo de ejecución, si la tabla especificada ya existe
	en la base de datos.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><computeroutput>
ERROR:  DEFAULT: type mismatched
       </computeroutput></term>
      <listitem>
       <para>
	Si el tipo de datos o el valor por defecto no corresponde al
	tipo de datos de la definición del campo.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </refsect2>
 </refsynopsisdiv>

 <refsect1 id="R1-SQL-CREATETABLE-1">
  <refsect1info>
   <date>1998-09-11</date>
  </refsect1info>
  <title>
   Description
  </title>

  <para>
   <command>CREATE TABLE</command> introducirá una nueva clase o tabla
   en la base de datos actual. La tabla será poseída por el usuario que
   introduce la sentencia.
  </para>

  <para>
   Cada <replaceable class="PARAMETER">type</replaceable>
   puede ser un tipo simple, un tipo complejo (set) o un tipo array.
   Cada atributo puede ser especificado para ser no nulo, y 
   puede tener un valor por defecto, especificado por la
   <xref linkend="R1-SQL-DEFAULTCLAUSE-1-TITLE" endterm="R1-SQL-DEFAULTCLAUSE-1-TITLE">.
  </para>

  <para>
   <note>
    <para>
	Al igual que en la versión 6.0 de Postgres, consistant array dimensions within an
     attribute are not enforced. Esto cambiará probablemente en las versiones futuras.
    </para>
   </note>
  </para>

  <para>
   La cláusula opcional INHERITS
   especifica una colección de nombres de clases de los cuales esta clase
   hereda automáticamente todos los campos. Si cualquier nombre de campo heredado
   aparece más de una vez, Postgres informa de un error. Postgres permite automáticamente
   a la clase creada heredar funciones de clases superiores en la jerarquía de herencia.	
   La herencia de funciones se hace siguiendo las convenciones
   del Common Lisp Object System (CLOS).
  </para>

  <para>
   Cada nueva tabla o clase <replaceable class="PARAMETER">table</replaceable>
   es creada automáticamente como tipo.  Por tanto, una o más instancias
   de la clase son automáticamente un tipo y pueden ser usadas en otras 
   <xref linkend="sql-altertable-title" endterm="sql-altertable-title">
   sentencias <command>CREATE TABLE</command>.
  </para>

  <para>
   The new table is created as a heap with no initial data.
   Una tabla no puede tener más de 1600 campos (realmente,
   esto viene limitado por el hecho que el máximo tamaño de una
   tupla debe ser menor que 8192 bytes), pero este límite puede ser
   configurado a un tamaño menor en algunos sitios. Una tabla no puede
   tener el mismo nombre que una tabla de catálogo del sistema.
  </para>
 </refsect1>

 <refsect1 id="R1-SQL-DEFAULTCLAUSE-1">
  <refsect1info>
   <date>1998-09-11</date>
  </refsect1info>
  <title id="R1-SQL-DEFAULTCLAUSE-1-TITLE">
   Cláusula DEFAULT 
  </title>
  <para>
   <synopsis>
DEFAULT <replaceable class="PARAMETER">value</replaceable>
   </synopsis>
  </para>
  <refsect2 id="R2-SQL-DEFAULTCLAUSE-1">
   <refsect2info>
    <date>1998-09-11</date>
   </refsect2info>
   <title>
    Entradas
   </title>
   <para>

    <variablelist>
     <varlistentry>
      <term><replaceable class="parameter">value</replaceable></term>
      <listitem>
       <para>
	Los posibles valores para la expresión DEFAULT (valor por defecto) son:
	<itemizedlist>
	 <listitem>
	  <simpara>
	   un literal
	  </simpara>
	 </listitem>
	 <listitem>
	  <simpara>
	   una función de usuario
	  </simpara>
	 </listitem>
	 <listitem>
	  <simpara>
	   una función niladic
	  </simpara>
	 </listitem>
	</itemizedlist>
       </para>
      </listitem>
     </varlistentry>	
    </variablelist>
   </para>
  </refsect2>

  <refsect2 id="R2-SQL-DEFAULTCLAUSE-2">
   <refsect2info>
    <date>1998-09-11</date>
   </refsect2info>
   <title>
    Salidas
   </title>
   <para>
    Ninguna.
   </para>
  </refsect2>
  
  <refsect2 id="R2-SQL-DEFAULTCLAUSE-3">
   <refsect2info>
    <date>1998-09-11</date>
   </refsect2info>
   <title>
    Descripción
   </title>
   <para>
    La cláusula DEFAULT asigna una valor por defecto a un campo
    (a través de una definición de campo en la sentencia CREATE TABLE). 
    El tipo de dato de un valor por defecto debe corresponder al tipo 
    de dato de la definición del campo.
   </para>
   <para>
    Una operación de inserción (INSERT) que incluya un campo sin un valor
    especificado por defecto asignará el valor NULL al campo si no se le
    proporciona un valor explícito.
    Si el valor por defecto es un <replaceable class="parameter">literal</replaceable> significa que
    que es un valor constante.
    Si el valor por defecto es una <replaceable class="parameter">niladic-function</replaceable>
    o una <replaceable class="parameter">user-function</replaceable> significa
    que dicho valor es el de la función especificada en el momento de la inserción.
   </para>
   <para>
    Hay dos tipos de funciones niladic:
    <variablelist>
     <varlistentry>
      <term>niladic USER</term>
      <listitem>
       <variablelist>
	<varlistentry>
	 <term>CURRENT_USER / USER</term>
	 <listitem>
	  <simpara>Consulte las funciones CURRENT_USER</simpara>
	 </listitem>
	</varlistentry>
	<varlistentry>
	 <term>SESSION_USER</term>
	 <listitem>
	  <simpara>todavía no soportadas</simpara>
	 </listitem>
	</varlistentry>
	<varlistentry>
	 <term>SYSTEM_USER</term>
	 <listitem>
	  <simpara>todavía no soportadas</simpara>
	 </listitem>
	</varlistentry>
       </variablelist>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>niladic datetime</term>
      <listitem>
       <variablelist>
	<varlistentry>
	 <term>CURRENT_DATE</term>
	 <listitem>
	  <simpara>Consulte las funciones CURRENT_DATE </simpara>
	 </listitem>
	</varlistentry>
	<varlistentry>
	 <term>CURRENT_TIME</term>
	 <listitem>
	  <simpara>Consulte las funciones CURRENT_TIME</simpara>
	 </listitem>
	</varlistentry>
	<varlistentry>
	 <term>CURRENT_TIMESTAMP</term>
	 <listitem>
	  <simpara>Consulte la función CURRENT_TIMESTAMP</simpara>
	 </listitem>
	</varlistentry>
       </variablelist>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
    En la versión actual (v6.5), <productname>Postgres</productname>
    evalúa todas las expresiones por defecto en el momento en que la tabla
    es definida. Por tanto, las funciones que son "non-cacheable" como
    <function>CURRENT_TIMESTAMP</function> pueden no producir el efecto
    deseado. Para el caso particular de tipos date/time , se puede trabajar
    sobre este comportamiento usando
    <quote>DEFAULT TEXT 'now'</quote>
    en lugar de 
    <quote>DEFAULT 'now'</quote>
    o
    <quote>DEFAULT CURRENT_TIMESTAMP</quote>.
    Esto fuerza <productname>Postgres</productname> a considerar la constante como
    un tipo string y así convertirla al valor <type>timestamp</type> en tiempo de 
    ejecución.
   </para>
  </refsect2>
  <refsect2 id="R2-SQL-DEFAULTCLAUSE-4">
   <refsect2info>
    <date>1998-09-11</date>
   </refsect2info>
   <title>
    Uso
   </title>

   <para>
    Para asignar un valor constante como valor por defecto para
    los campos <literal>did</literal> and <literal>number</literal>,
    y una cadena al campo <literal>did</literal>:

    <programlisting>
CREATE TABLE video_sales (
    did      VARCHAR(40) DEFAULT 'luso films',
    number   INTEGER DEFAULT 0,
    total    CASH DEFAULT '$0.0'
);
    </programlisting>
   </para>
   <para>
    Para asignar una secuencia existente
    como valor por defecto para el campo <literal>did</literal>,
    y un literal para el campo <literal>name</literal>:

    <programlisting>
CREATE TABLE distributors (
    did      DECIMAL(3)  DEFAULT NEXTVAL('serial'),
    name     VARCHAR(40) DEFAULT 'luso films'
);
    </programlisting>
   </para>
  </refsect2>
 </refsect1>

 <refsect1 id="R1-SQL-COLUMNCONSTRAINT-1">
  <refsect1info>
   <date>1998-09-11</date>
  </refsect1info>
  <title id="R1-SQL-COLUMNCONSTRAINT-1-TITLE">
   Column CONSTRAINT Clause
  </title>
  <para>
   <synopsis>
[ CONSTRAINT <replaceable class="parameter">name</replaceable> ] { [
    NULL | NOT NULL ] | UNIQUE | PRIMARY KEY | CHECK <replaceable
     class="parameter">constraint</replaceable> } [, ...]
   </synopsis>
  </para>

  <refsect2 id="R2-SQL-COLUMNCONSTRAINT-1">
   <refsect2info>
    <date>1998-09-11</date>
   </refsect2info>
   <title>
    Entradas
   </title>
   <para>

    <variablelist>
     <varlistentry>
      <term><replaceable class="parameter">name</replaceable></term>
      <listitem>
       <para>
	Un nombre arbitrario dado a la restricción de integridad
	Si no se especifica <replaceable class="parameter">name</replaceable>,
	se genera de los nombres de l tabla y campos,
	lo que asegura unicidad para
	<replaceable class="parameter">name</replaceable>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>NULL</term>
      <listitem>
       <para>
	El campo puede contener valores NULL. Ésta es la opción por defecto.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>NOT NULL</term>
      <listitem>
       <para>
	El campo no puede contener valores NULL.
	Esto equivale a la restricción de campo
	CHECK (<replaceable class="PARAMETER">column</replaceable> NOT NULL).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>UNIQUE</term>
      <listitem>
       <para>
	El campo debe contener un valor único. En <productname>Postgres</productname>
	esto es forzado por medio de la creación implícita de un índice único sobre
	la tabla.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>PRIMARY KEY</term>
      <listitem>
       <para>
	Este campo es una clave primaria, lo que implica que la unicidad es forzada
	por el sistema y que otras tablas pueden confiar en este campo como identificador
	único para los registros.
	Consulte PRIMARY KEY para más información.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>
<replaceable class="parameter">constraint</replaceable>
      </term>
      <listitem>
       <para>
	La definición de la restricción.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </refsect2>

  <refsect2 id="R2-SQL-COLUMNCONSTRAINT-2">
   <refsect2info>
    <date>1998-09-11</date>
   </refsect2info>
   <title>
	Descripción
   </title>

   <para>
    La cláusula opcional de restricción (CONSTRAINT) especifica restricciones o
    verifica qué deben cumplir las nuevas inserciones o las actualizaciones para que una 
    operación de inserción o de actualización tenga éxito. Cada restricción
    debe evaluarse a una expresión booleana. Con una única restricción se pueden
    referenciar múltiples atributos.  El uso de PRIMARY KEY como restricción de tabla
    es mutuamente incompatible con el uso de PRIMARY KEY como restricción de campo.
   </para>

   <para>
    Una restricción es una regla con nombre: un objeto SQL que ayuda
    a definir conjuntos de valores válidos poniendo límites a los resultados 
    de las operaciones INSERT, UPDATE or DELETE sobre una tabla. 
   </para>

   <para>
    Existen dos maneras de definir restricciones de integridad:
    restricciones de tabla, que veremos más adelante, y restricciones de campo, 
    que pasamos a ver.
   </para>

   <para>
    Una restricción de campo es una restricción de integridad definida
    como parte de la definición de campo, y lógicamente se convierte
    en una restricción de tabla nada más ser creada. Las restricciones de
    campo disponibles son:

    <simplelist columns="1">
     <member>PRIMARY KEY</member>
     <member>REFERENCES</member>
     <member>UNIQUE</member>
     <member>CHECK</member>
     <member>NOT NULL</member>
    </simplelist></para>
   <note>
    <para>
     <productname>Postgres</productname> todavía no soporta
     (en su versión 6.5) restricciones de integridad especificadas
     por REFERENCES. Se acepta la sintaxis pero se ignora la cláusula (disponible,
     en cambio, a partir de la versión 7.0)
    </para>
   </note>
  </refsect2>
   
  <refsect2 id="R2-SQL-NOTNULL-1">
   <refsect2info>
    <date>1998-09-11</date>
   </refsect2info>
   <title>
    Restricción NOT NULL
   </title>
   <synopsis>
[ CONSTRAINT <replaceable class="parameter">name</replaceable> ] NOT NULL 
   </synopsis>
   <para>
    La restricción NOT NULL especifica una regla que obliga que un campo
    contenga únicamente valores no nulos.
    Ésta es únicamente una restricción de campo, y no se permite como 
    restricción de tabla..
   </para>

   <refsect3 id="R3-SQL-NOTNULL-1">
    <refsect3info>
     <date>1998-09-11</date>
    </refsect3info>
    <title>
     Salidas
    </title>
    <para>
     <variablelist>
      <varlistentry>
       <term><replaceable>status</replaceable></term>
       <listitem>
	<para>
	 <variablelist>
	  <varlistentry>
	   <term><computeroutput>
ERROR:  ExecAppend: Fail to add null value in not null attribute "<replaceable class="parameter">column</replaceable>".
	    </computeroutput></term>
	   <listitem>
	    <para>
	     Este error ocurre en tiempo de ejecución cuando se intenta insertar
	     un valor nulo en un campo que contiene la restricción NOT NULL.
	    </para>
	   </listitem>
	  </varlistentry>
	 </variablelist>
	</para>
       </listitem>
      </varlistentry>
     </variablelist> 
    </para>
   </refsect3>

   <refsect3 id="R3-SQL-NOTNULL-2">
    <refsect3info>
     <date>1998-09-11</date>
    </refsect3info>
    <title>
     Descripción
    </title>
    <para>
    </para>
   </refsect3>

   <refsect3 id="R3-SQL-NOTNULL-3">
    <refsect3info>
     <date>1998-09-11</date>
    </refsect3info>
    <title>
     Uso
    </title>

    <para>
     Definir dos restricciones de campo NOT NULL en la tabla
     <classname>distributors</classname>,
     una de las cuales se nombra:

     <programlisting>
CREATE TABLE distributors (
    did      DECIMAL(3) CONSTRAINT no_null NOT NULL,
    name     VARCHAR(40) NOT NULL
);
     </programlisting>
    </para>
   </refsect3>
  </refsect2>

  <refsect2 id="R2-SQL-UNIQUECLAUSE-1">
   <refsect2info>
    <date>1998-09-11</date>
   </refsect2info>
   <title>
    Restricción UNIQUE
   </title>
   <synopsis>
[ CONSTRAINT <replaceable class="parameter">name</replaceable> ] UNIQUE
   </synopsis>

   <refsect3>
    <title>Entradas</title>
    <para>

     <variablelist>
      <varlistentry>
       <term>CONSTRAINT <replaceable class="parameter">name</replaceable></term>
       <listitem>
	<para>
	Una etiqueta arbitraria dada a una restricción. 
	</para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsect3>
   
   <refsect3>
    <title>Salidas</title>
    <para>
     <variablelist>
      <varlistentry>
       <term><replaceable>status</replaceable></term>
       <listitem>
	<para>
	 <variablelist>
	  <varlistentry>
	   <term><computeroutput>
ERROR: Cannot insert a duplicate key into a unique index.
	    </computeroutput></term>
	   <listitem>
	    <para>
	     Este error ocurre en tiempo de ejecución si se intenta
	     insertar un valor duplicado en un campo.	
	    </para>
	   </listitem>
	  </varlistentry>
	 </variablelist>
	</para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsect3>

   <refsect3>
    <title>
     Descripción
    </title>

    <para>
     La restricción UNIQUE especifica una regla que obliga a un grupo
     de uno o más campos de una tabla a contener valores únicos.
    </para>
    <para>
     Las definiciones de campo de las columnas especificadas no tienen	
     porqué incluir una restricción NOT NULL constraint para ser incluídos
     en una restricción UNIQUE.  Tener más de un valor nulo en un campo sin
     la restricción NOT NULL, no viola la restricción UNIQUE.
     (This deviates from the <acronym>SQL92</acronym> definition, but
     is a more sensible convention. See the section on compatibility
     for more details.).
    </para>
    <para>
     Cada restricción de campo UNIQUE debe nombrar un campo que
     es distitno del conjunto de campos nombrados por cualquier otra
     restricción UNIQUE o PRIMARY KEY definifas por la tabla.
    </para>
    <note>
     <para>
      <productname>Postgres</productname> crea automáticamente un índice
      único por cada restricción UNIQUE, para asegurar la integridad
      de los datos. Vea CREATE INDEX para más información.
     </para>
    </note>
   </refsect3>

   <refsect3 id="R3-SQL-UNIQUECLAUSE-3">
    <title>
     Uso
    </title>

    <para>
     Define una restricción de campo UNIQUE para la tabla distributors.
     Las restricciones de campo UNIQUE solo son definidas sobre un campo
     de la tabla:
     <programlisting>
CREATE TABLE distributors (
    did      DECIMAL(3),
    name     VARCHAR(40) UNIQUE
);
  </programlisting>

     lo que equivale a la siguiente restricción de tabla:
     <programlisting>
CREATE TABLE distributors (
    did      DECIMAL(3),
    name     VARCHAR(40),
    UNIQUE(name)
);
     </programlisting>
    </para>
   </refsect3>
  </refsect2>

  <refsect2 id="R2-SQL-CHECK-1">
   <refsect2info>
    <date>1998-09-11</date>
   </refsect2info>
   <title>
    La restricción CHECK
   </title>
   <synopsis>
[ CONSTRAINT <replaceable class="parameter">name</replaceable> ] CHECK
    ( <replaceable>condition</replaceable> [, ...] ) 
   </synopsis>
   <refsect3 id="R3-SQL-CHECK-1">
    <title>Entradas</title>
    <para>

     <variablelist>
      <varlistentry>
       <term><replaceable class="parameter">name</replaceable></term>
       <listitem>
	<para>
	Un nombre arbitrario dado a la restricción. 
	</para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><replaceable>condition</replaceable></term>
       <listitem>
	<para>
	 Cualquier expresión condicional válida que se evalue a un resultado boolenano.
	</para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsect3>

   <refsect3 id="R3-SQL-CHECK-2">
    <refsect3info>
     <date>1998-09-11</date>
    </refsect3info>
    <title>
     Outputs
    </title>
    <para>

     <variablelist>
      <varlistentry>
       <term><replaceable>status</replaceable></term>
       <listitem>
	<para>

	 <variablelist>
	  <varlistentry>
	   <term><computeroutput>
ERROR:  ExecAppend: rejected due to CHECK constraint "<replaceable class="parameter">table_column</replaceable>".
	    </computeroutput></term>
	   <listitem>
	    <para>
		Este error ocurre en tiempo de ejecución si alguien intenta insertar un
		valor ilegal en un campo sujeto a una restricción CHECK.
	    </para>
	   </listitem>
	  </varlistentry>
	 </variablelist>
	</para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsect3>

   <refsect3>
    <title>Descripción</title>
    <para>
	La restricción CHECK especifica una restricción sobre los valores
	permitidos en un campo. La restricción CHECK también se permite como 
	restricción de tabla.
    </para>
    <para>
     Las resticciones de campo CHECK de SQL92 sólo pueden ser definidas sobre 
     un campo de la tabla, y solamente pueden referirse a un campo. <productname>Postgres</productname>
     no tiene esta restricción.
    </para>
   </refsect3>
  </refsect2>
  
  <refsect2 id="R2-SQL-PRIMARYKEY-1">
   <refsect2info>
    <date>1998-09-11</date>
   </refsect2info>
   <title>
    Restricción PRIMARY KEY
   </title>
   <synopsis>
[ CONSTRAINT <replaceable class="PARAMETER">name</replaceable> ] PRIMARY KEY 
   </synopsis>

   <refsect3>
    <title>Entradas</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>CONSTRAINT <replaceable class="PARAMETER">name</replaceable></term>
       <listitem>
	<para>
	Un nombre arbitrario para la restricción. 
	</para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsect3>

   <refsect3>
    <title>Salidas</title>
    <variablelist>
     <varlistentry>
      <term><computeroutput>
	ERROR: No se puede insertar un valor duplicado en un índice único.
       </computeroutput></term>
      <listitem>
       <para>
	Esto ocurre en tiempo de ejecución si alguien intenta insertar un valor duplicado
	en una columna sujeta a una restricción PRIMARY KEY.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect3>

   <refsect3>
    <title>Descripción</title>
    <para>
     La restricción de campo PRIMARY KEY especifica que un campo de una tabla
     solamente puede contener valores únicos (no duplicados) y no nulos . La
     definición de la columna especificada no tiene que incluir una restricción
     explícita NOT NULL para ser incluída en una restricción PRIMARY KEY.
    </para>
    <para>
     Sólo se puede especificar una única clave primaria (PRIMARY KEY) por tabla.
    </para>
   </refsect3>
   
   <refsect3 id="R3-SQL-PRIMARYKEY-3">
    <refsect3info>
     <date>1998-09-11</date>
    </refsect3info>
    <title>
     Notas
    </title>
    <para>
     <productname>Postgres</productname> crea automáticamente un índice
	único para asegurar la integridad de los datos. (Vea la sentencia CREATE INDEX)
    </para>
    <para>
     La restricción de clave primaria (PRIMARY KEY) debe nombrar un conjunto de
     campos que no sean contenidos por ninguna otra restricción UNIQUE
     definidos por la misma tabla, ya que produciría una duplicación
     de índices equivalentes y una sobrecarga adicional en tiempo de ejecución.
     Sin embargo, <productname>Postgres</productname> no lo deshabilita específicamente.
    </para>
   </refsect3>
  </refsect2>
 </refsect1>
 
 <refsect1 id="R1-SQL-TABLECONSTRAINT-1">
  <refsect1info>
   <date>1998-09-11</date>
  </refsect1info>
  <title>
   Cláusula CONSTRAINT para tablas
  </title>
  <para>
   <synopsis>
[ CONSTRAINT name ] { PRIMARY KEY |  UNIQUE } ( <replaceable class="parameter">column</replaceable> [, ...] )
[ CONSTRAINT name ] CHECK ( <replaceable>constraint</replaceable> )
   </synopsis>
  </para>
  <refsect2 id="R2-SQL-TABLECONSTRAINT-1">
   <refsect2info>
    <date>1998-09-11</date>
   </refsect2info>
   <title>
    Entradas
   </title>

   <para>

    <variablelist>
     <varlistentry>
      <term>CONSTRAINT <replaceable class="parameter">name</replaceable></term>
      <listitem>
       <para>
	Un nombre arbitrario dado a una restricción de integridad.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><replaceable class="parameter">column</replaceable> [, ...]</term>
      <listitem>
       <para>
	El nombre de los campos para los que definimos un índice único y, para la PRIMARY KEY, 
	una restricción NOT NULL. 
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>CHECK ( <replaceable class="parameter">constraint</replaceable> )</term>
      <listitem>
       <para>
	Una expresión booleana a ser evaluado como la restricción.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </refsect2>
    
  <refsect2 id="R2-SQL-TABLECONSTRAINT-2">
   <refsect2info>
    <date>1998-09-11</date>
   </refsect2info>
   <title>
    Salidas
   </title>
   
   <para>
    Las posibles salidas para la cláusula de restricción de tablas son las mismas
    que para las partes correspondientes de la cláusula restricción de campo.	
   </para>
  </refsect2>
  
  <refsect2 id="R2-SQL-TABLECONSTRAINT-3">
   <refsect2info>
    <date>1998-09-11</date>
   </refsect2info>
   <title>
    Descripción
   </title>
   
   <para>
    Una restricción de tabla es una restricción de integridad definidad
    sobre uno o más campos de una tabla base. Las cuatro variaciones de  
    restricciones de tabla son:
    <simplelist columns="1">
     <member>UNIQUE</member>
     <member>CHECK</member>
     <member>PRIMARY KEY</member>
     <member>FOREIGN KEY</member>
    </simplelist>
   </para>
   <note>
    <para>
     <productname>Postgres</productname> todavía no soporta (en su versión 6.5)
	las restricciones de integridad FOREIGN KEY. El compilador entiende la sintaxis
	de FOREIGN KEY, pero solo imprime un aviso e ignora la cláusula. Las claves ajenas
	pueden ser parcialmente emuladas por medio de triggers (Consulte la sentencia CREATE TRIGGER).
    </para>
   </note>
  </refsect2>
 
  <refsect2 id="R2-SQL-UNIQUECLAUSE-4">
   <refsect2info>
    <date>1998-09-11</date>
   </refsect2info>
   <title>
    Restricción UNIQUE
   </title>
   <para>
    <synopsis>
[ CONSTRAINT <replaceable class="parameter">name</replaceable> ] UNIQUE ( <replaceable class="parameter">column</replaceable> [, ...] )
    </synopsis>
   </para>
   <refsect3>
    <title>Entradas</title>
    <variablelist>
     <varlistentry>
      <term>CONSTRAINT <replaceable class="parameter">name</replaceable></term>
      <listitem>
       <para>
	Un nombre arbitrario dado a una restricción.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><replaceable class="parameter">column</replaceable></term>
      <listitem>
       <para>
	Un nombre de un campo en una tabla.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect3>

   <refsect3>
    <title>Salidas</title>
    <para>
     <variablelist>
      <varlistentry>
       <term><replaceable>status</replaceable></term>
       <listitem>
	<para>
	 <variablelist>
	  <varlistentry>
	   <term>ERROR: Cannot insert a duplicate key into a unique index.</term>
	   <listitem>
	    <para>
	     Este error ocurre en tiempo de ejecución si se intenta insertar
	     un valor duplicado en un campo.	
	    </para>
	   </listitem>
	  </varlistentry>
	 </variablelist>
	</para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsect3>
   
   <refsect3>
    <title>
     Descripción
    </title>
    
    <para>
     La restricción UNIQUE especifica una regla en la que un grupo de uno	
     The UNIQUE constraint specifies a rule that a group of one or
     o más campos diversos de una tabla puede contener solo valores únicos.
     El comportamiento de la restricción de tabla UNIQUE es el mismo que para
     la restricción de campo, con la posibilidad adicional de aplicarlo a más de un
     campo.
    </para>
    <para>
     Consulte la sección sobre la restricción de campo UNIQUE para más detalles.
    </para>
   </refsect3>

   <refsect3 id="R3-SQL-UNIQUECLAUSE-4">
    <title>
     Uso
    </title>
    
    <para>
     Define una restricción de tabla UNIQUE en la tabla distributors:
     <programlisting>
CREATE TABLE distributors (
    did      DECIMAL(03),
    name     VARCHAR(40),
    UNIQUE(name)
);
     </programlisting>
    </para>
   </refsect3>
  </refsect2>

  <refsect2 id="R2-SQL-PRIMARYKEY-4">
   <refsect2info>
    <date>1998-09-11</date>
   </refsect2info>
   <title>
    Restricción PRIMARY KEY
   </title>
   <para>
    <synopsis>
[ CONSTRAINT <replaceable class="PARAMETER">name</replaceable> ] PRIMARY KEY ( <replaceable class="PARAMETER">column</replaceable> [, ...] ) 
    </synopsis>
   </para>
   <refsect3>
    <title>Entradas</title>
    <para>

     <variablelist>
      <varlistentry>
       <term>CONSTRAINT <replaceable class="PARAMETER">name</replaceable></term>
       <listitem>
	<para>
	 Un nombre arbitrario para la restricción.
	</para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><replaceable class="PARAMETER">column</replaceable> [, ...]</term>
       <listitem>
	<para>
	Los nombres de uno o más campos en la tabla. 
	</para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsect3>
   
   <refsect3>
    <title>Salidas</title>
    <variablelist>
     <varlistentry>
      <term><replaceable>status</replaceable></term>
      <listitem>
       <para>
	<variablelist>
	 <varlistentry>
	  <term>ERROR: Cannot insert a duplicate key into a unique index.</term>
	  <listitem>
	   <para>
	    Esto ocurre en tiempo de ejecución si alguien intenta insertar un valor duplicado
	    en un campo sujeto a una restricción de clave primaria (PRIMARY KEY).
	   </para>
	  </listitem>
	 </varlistentry>
	</variablelist>
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect3>
   
   <refsect3>
    <title>Descripción</title>
    <para>
     La restricción PRIMARY KEY especifica una regla en la que un grupo
     de uno o más campos de una tabla puede contener sólo valores únicos
     (no duplicados) y no nulos. Las definiciones de campo de los campos
     especificados no necesita incluir una restricción NOT NULL para ser incluída
     en una restricción PRIMARY KEY.
    </para>

    <para>
     La restricción de tabla PRIMARY KEY es similar a la respectiva restricción
     de campo, con la posibilidad de extenderla
     with the additional capability of encompassing multiple columns.
    </para>
    <para>
     Consulte la sección sobre la restricción de campo PRIMARY KEY para más
     infomación.	
    </para>
   </refsect3>

  </refsect2>

 </refsect1>
 
 <refsect1 id="R1-SQL-CREATETABLE-2">
  <title>
   Uso
  </title>
  <para>
   Crea las tablas films y distributors:

   <programlisting>
CREATE TABLE films (
     code      CHARACTER(5) CONSTRAINT firstkey PRIMARY KEY,
     title     CHARACTER VARYING(40) NOT NULL,
     did       DECIMAL(3) NOT NULL,
     date_prod DATE,
     kind      CHAR(10),
     len       INTERVAL HOUR TO MINUTE
);
   </programlisting>

   <programlisting>
CREATE TABLE distributors (
     did      DECIMAL(03) PRIMARY KEY DEFAULT NEXTVAL('serial'),
     name     VARCHAR(40) NOT NULL CHECK (name &lt;&gt; '')
);
   </programlisting>
  </para>

  <para>
   Crea una tabla con un array de 2 dimensiones:

   <programlisting>
   CREATE TABLE array (
          vector INT[][]
          );
   </programlisting>
  </para>
  <para>
   Define una restricción de tabla UNIQUE para la tabla films.
   Las restricciones de tabla UNIQUE pueden ser definidas sobre uno
   o más campos de la tabla:
   <programlisting>
	CREATE TABLE films (
    code      CHAR(5),
    title     VARCHAR(40),
    did       DECIMAL(03),
    date_prod DATE,
    kind      CHAR(10),
    len       INTERVAL HOUR TO MINUTE,
    CONSTRAINT production UNIQUE(date_prod)
);
   </programlisting>
  </para>
  
  <para>
   Define una restricción de campo CHECK:

   <programlisting>
CREATE TABLE distributors (
    did      DECIMAL(3) CHECK (did > 100),
    name     VARCHAR(40)
);
   </programlisting>
  </para>

  <para>
   Define una restricción de tabla CHECK:

   <programlisting>
CREATE TABLE distributors (
    did      DECIMAL(3),
    name     VARCHAR(40)
    CONSTRAINT con1 CHECK (did > 100 AND name > '')
);
   </programlisting>
  </para>
 
  <para>
   Define una restricción de tabla PRIMARY KEY para la tabla  films.
   Las restricciones de tabla PRIMARY KEY pueden ser definidas sobre
   uno o más campos de la tabla:   
   <programlisting>
CREATE TABLE films (
    code      CHAR(05),
    title     VARCHAR(40),
    did       DECIMAL(03),
    date_prod DATE,
    kind      CHAR(10),
    len       INTERVAL HOUR TO MINUTE,
    CONSTRAINT code_title PRIMARY KEY(code,title)
);
   </programlisting>
  </para>

  <para>
   Define una restricción de campo PRIMARY KEY para la tabla distributors.
   Las restricciones de campo PRIMARY KEY solamente se pueden definir para
   un campo de la tabla (los siguientes dos ejemplos serían equivalentes) :
   <programlisting>
	CREATE TABLE distributors (
    did      DECIMAL(03),
    name     CHAR VARYING(40),
    PRIMARY KEY(did)
); 
   </programlisting>

   <programlisting>
CREATE TABLE distributors (
    did      DECIMAL(03) PRIMARY KEY,
    name     VARCHAR(40)
);
   </programlisting>
  </para>
  
  <refsect2 id="R2-SQL-CREATETABLE-3">
   <refsect2info>
    <date>1998-09-11</date>
   </refsect2info>
   <title>
    Notas
   </title>
   <para>
    CREATE TABLE/INHERITS es una extensión al lenguaje
    de <productname>Postgres</productname>.
   </para>
  </refsect2>
  
 </refsect1>
 
 <refsect1 id="R1-SQL-CREATETABLE-3">
  <title>
   Compatibilidad
  </title>
  
  <refsect2 id="R2-SQL-CREATETABLE-4">
   <refsect2info>
    <date>1998-09-11</date>
   </refsect2info>
   <title>
    SQL92
   </title>
   <para>
    Además de la tabla temporal visible localmente, SQL92 define una sentencia
    CREATE GLOBAL TEMPORARY TABLE , y opcionalmente una cláusula ON COMMIT:
   <synopsis>
CREATE GLOBAL TEMPORARY TABLE <replaceable class="parameter">table</replaceable> ( <replaceable class="parameter">column</replaceable> <replaceable class="parameter">type</replaceable> [
    DEFAULT <replaceable class="parameter">value</replaceable> ] [ CONSTRAINT <replaceable class="parameter">column_constraint</replaceable> ] [, ...] )
    [ CONSTRAINT <replaceable class="parameter">table_constraint</replaceable> ] [ ON COMMIT { DELETE | PRESERVE } ROWS ] 
   </synopsis>
   </para>

   <para>
    Para tablas temporales, la sentencia CREATE GLOBAL TEMPORARY TABLE nombra una
    nueva tabla visible a otros clientes y define los campos de la tabla y las restricciones.
   </para>
   <para>
    La cláusula opcional ON COMMIT de CREATE TEMPORARY TABLE especifica
    si la tabla temporal debe vaciarse de registros cada vez que se ejecuta
    un COMMIT o no. Si se omite la cláusula ON COMMIT, se asume la opción por 
    defecto, ON COMMIT DELETE ROWS.
   </para>
   <para>
    Para crear una tabla temporal:

    <programlisting>
CREATE TEMPORARY TABLE actors (
    id         DECIMAL(03),
    name       VARCHAR(40),
    CONSTRAINT actor_id CHECK (id &lt; 150)
) ON COMMIT DELETE ROWS;
    </programlisting>
   </para>

   <refsect3 id="R3-SQL-UNIQUECLAUSE-1">
    <refsect3info>
     <date>1998-09-11</date>
    </refsect3info>
    <title>
     Cláusula UNIQUE
    </title>
    <para>
     SQL92 especifica algunas posibilidades adicionales para UNIQUE:
    </para>
    <para>
     Definición de restricción de tabla:

     <synopsis>
[ CONSTRAINT name ] UNIQUE ( column [, ...] )
    [ { INITIALLY DEFERRED | INITIALLY IMMEDIATE } ]
    [ [ NOT ] DEFERRABLE ]
     </synopsis>
    </para>

    <para>
     Definición de restricción de campo:

     <synopsis>
[ CONSTRAINT name ] UNIQUE
      [ {INITIALLY DEFERRED | INITIALLY IMMEDIATE} ]
      [ [ NOT ] DEFERRABLE ]
     </synopsis>
    </para>
   </refsect3>
   
   <refsect3 id="R3-SQL-NULL-1">
    <refsect3info>
     <date>1998-12-24</date>
    </refsect3info>
    <title>
     cláusula NULL
    </title>
    <para>
	La restricción  NULL (realmente no es una restricción)
	es una extensión <productname>Postgres</productname> a SQL92
	incluída por simetría con la cláusula NOT NULL. Como es el valor por
	defecto para cualquier campo, su presencia es redundante.
     <synopsis>
[ CONSTRAINT name ] NULL 
     </synopsis>
    </para>
   </refsect3>
   
   <refsect3 id="R3-SQL-NOTNULL-4">
    <refsect3info>
     <date>1998-09-11</date>
    </refsect3info>
    <title>
     cláusula NOT NULL
    </title>
    <para>
     
     SQL92 especifica alguna posibildad adicional para NOT NULL:
     <synopsis>
[ CONSTRAINT name ] NOT NULL 
    [ {INITIALLY DEFERRED | INITIALLY IMMEDIATE} ]
    [ [ NOT ] DEFERRABLE ]
     </synopsis>
    </para>
   </refsect3>
   
<!--
I can't figure out why DEFAULT clause is different from what we already have.
Perhaps because CURRENT_USER and CURRENT_DATE have specific types (currently
the "name" type), if you aren't careful then the types won't match up with
the column. Not our problem...
- Thomas 1998-08-16

   <REFSECT3 ID="R3-SQL-DEFAULTCLAUSE-1">
    <REFSECT3INFO>
     <DATE>1998-09-11</DATE>
    </REFSECT3INFO>
    <TITLE>
     cláusula DEFAULT
    </TITLE>
    <PARA>
     SQL92 especifica alguna posibilidad adicional para la cláusula DEFAULT.
     Una cláusula DEFAULT se usa para establecer el valor por defecto de un
     campo o dominio
    </para>
    <synopsis>
     DEFAULT niladic USER function |
             niladic datetime function |
             NULL
    </synopsis>
   </refsect3>
-->

   <refsect3 id="R3-SQL-CONSTRAINT-3">
    <refsect3info>
     <date>1998-09-11</date>
    </refsect3info>
    <title>
     cláusula CONSTRAINT
    </title>
    <para>
     SQL92 especifica alguna posibilidad adicional para restricciones,
     y también define restricciones de assertions y de dominio.
     <note>
      <para>
       <productname>Postgres</productname> todavía no soporta ni 
       dominios ni assertions.
      </para>
     </note>
    </para>
    <para>
     Una assertion es un tipo especial de restricción de integridad y comparte
     el mismo espacio de nombres con otras restricciones.
     Sin embargo, una assertion no es necesariamente dependiente de una particular
     tabla base como son las restricciones, así que SQL-92 proporciona la sentencia
     CREATE ASSERTION como un método alternativo para definir una restricción:
    </para>
    <synopsis>
CREATE ASSERTION name CHECK ( condition )
    </synopsis>
    
    <para>
     Las restricciones de dominio se definen con las sentencias CREATE DOMAIN o ALTER DOMAIN:
    </para>
    <para>
     Restricción de dominio:

     <synopsis>
[ CONSTRAINT name ] CHECK constraint 
    [ {INITIALLY DEFERRED | INITIALLY IMMEDIATE} ]
    [ [ NOT ] DEFERRABLE ]
     </synopsis>
    </para>

    <para>
     Definición de restricciones de tabla:

     <synopsis>
[ CONSTRAINT name ] { PRIMARY KEY ( <replaceable class="parameter">column</replaceable>, ... ) | FOREIGN KEY constraint | UNIQUE constraint | CHECK constraint }
    [ {INITIALLY DEFERRED | INITIALLY IMMEDIATE} ]
    [ [ NOT ] DEFERRABLE ]
     </synopsis>
    </para>

    <para>
     Definición de restricciones de campo:

     <synopsis>
[ CONSTRAINT name ] { NOT NULL | PRIMARY KEY | FOREIGN KEY constraint | UNIQUE | CHECK constraint }  
    [ {INITIALLY DEFERRED | INITIALLY IMMEDIATE} ]
    [ [ NOT ] DEFERRABLE ]
     </synopsis>
    </para>

    <para>
     Una definición de restricción de integridad (CONSTRAINT) puede contener un atributo
     o cláusula DEFERRABLE y /o una cláusula del modo inicial de restricción, en cualquier orden.
     <variablelist>
      <varlistentry>
       <term>NOT DEFERRABLE</term>
       <listitem>
	<para>
	 significa que la restricción debe ser comprobada después
	 de la ejecución de cada sentencia SQL.
	</para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>DEFERRABLE</term>
       <listitem>
	<para>
	 significa que la verificación del cumplimiento de la restricción puede
	 ser aplazado hasta más tarde, pero no más tarde que el final de la actual
	 transacción.
	</para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
    <para>
     El modo de restricción para cada restricción tiene siempre un
     valor incial por defecto que se establece para la restricción
     al principio de la transacción.
     <variablelist>
      <varlistentry>
       <term>INITIALLY IMMEDIATE</term>
       <listitem>
	<para>
	 significa que, desde el principio de la transacción,
	 la restricción debe ser comprobada después de la ejecución
	 de cada sentencia SQL.
	</para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>INITIALLY DEFERRED</term>
       <listitem>
	<para>
	 significa que, como se está al principio de la transacción,
	 la comprobación de la restricción puede ser aplazada hasta más tarde,
	 pero no más tarde que en el final de la actual transacción. O sea, que la
	 restricción puede ser incumplida por alguna sentencia SQL en un punto 
	 intermedio de la transacción, pero no al final de la misma.</para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsect3>
   
   
   <refsect3 id="R3-SQL-CHECK-4">
    <refsect3info>
     <date>1998-09-11</date>
    </refsect3info>
    <title>
     Cláusula CHECK 
    </title>
    <para>
     SQL92 especifica alguna capacidad adicional para CHECK tanto en la restricciones de tabla
	como en la de campo.
    </para>
<!--
No es necesario mencionar las restricciones de dominio aquí,
aunque una restricción de dominio pueda posiblemente 
afectar a un campo o a una tabla.
- Thomas 1998-08-16
    <para>
     	Una restricción CHECK es bien una restricción de tabla, una
	restricción de campo o una de dominio.
    </para> 
-->
    <para>
     definición de restricción de tabla:
     <synopsis>
[ CONSTRAINT name ] CHECK ( VALUE condition ) 
      [ {INITIALLY DEFERRED | INITIALLY IMMEDIATE} ]
      [ [ NOT ] DEFERRABLE ]
     </synopsis>
    </para>

    <para>
     definición de restricción de campo:
    <synopsis>
[ CONSTRAINT name ] CHECK ( VALUE condition ) 
      [ {INITIALLY DEFERRED | INITIALLY IMMEDIATE} ]
      [ [ NOT ] DEFERRABLE ]
    </synopsis>
    </para>
<!--
   <para>
     definición de restricción de dominio: 
    </para>
    <synopsis>
     [ CONSTRAINT name ] 
      CHECK ( VALUE condition ) 
      [ {INITIALLY DEFERRED | INITIALLY IMMEDIATE} ]
      [ [ NOT ] DEFERRABLE ]
    </synopsis>
    <para>
     CHECK domain constraints puede ser definida bien
     sea en una sentencia CREATE DOMAIN o en una ALTER DOMAIN:
    </para>
    <programlisting>
CREATE DOMAIN duration AS SMALLINT 
    CONSTRAINT minutes CHECK (VALUE IN (90,120,180,240)); 

ALTER DOMAIN cities 
    ADD CONSTRAINT new_city CHECK (VALUE LIKE 'L%');
   </programlisting>
-->
   </refsect3>

   <refsect3 id="R3-SQL-PRIMARYKEY-1">
    <refsect3info>
     <date>1998-09-11</date>
    </refsect3info>
    <title>
     cláusula PRIMARY KEY 
    </title>
    <para>
     SQL92 especifica algunas posibilidades adicionales para la PRIMARY KEY:
    </para>
    <para>
     Definición de restricciones de tabla:
     <synopsis>
[ CONSTRAINT name ] PRIMARY KEY ( column [, ...] ) 
    [ {INITIALLY DEFERRED | INITIALLY IMMEDIATE} ]
    [ [ NOT ] DEFERRABLE ]
     </synopsis>
    </para>
    <para>
     Definición de restricciones de campo: 
     <synopsis>
[ CONSTRAINT name ] PRIMARY KEY 
    [ {INITIALLY DEFERRED | INITIALLY IMMEDIATE} ]
    [ [ NOT ] DEFERRABLE ]
     </synopsis>
    </para>
   </refsect3>
  </refsect2>
 </refsect1>
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->
