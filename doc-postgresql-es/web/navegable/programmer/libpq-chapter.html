<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<HTML
><HEAD
><TITLE
>libpq</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.59"><LINK
REL="HOME"
TITLE="Guia del Programador de PostgreSQL"
HREF="programmer.html"><LINK
REL="PREVIOUS"
TITLE="Programa de Ejemplo"
HREF="x3445.html"><LINK
REL="NEXT"
TITLE="Funciones de Ejecución de Consultas"
HREF="x3690.html"></HEAD
><BODY
CLASS="CHAPTER"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Guia del Programador de PostgreSQL</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x3445.html"
>Anterior</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x3690.html"
>Siguiente</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="CHAPTER"
><H1
><A
NAME="LIBPQ-CHAPTER"
>libpq</A
></H1
><P
>   <TT
CLASS="FILENAME"
>libpq</TT
> es la interfaz para los programadores de aplicaciones
   en <SPAN
CLASS="ACRONYM"
>C</SPAN
> para <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>.  
   <TT
CLASS="FILENAME"
>libpq</TT
> es un conjunto de rutinas de biblioteca que 
   permiten a los programas cliente trasladar consultas al servidor de
   <SPAN
CLASS="PRODUCTNAME"
>Postgres</SPAN
> y recibir el resultado de esas consultas.
   <TT
CLASS="FILENAME"
>libpq</TT
> es también el mecanismo subyacente para muchas otras
   interfaces de aplicaciones de <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>,
   incluyendo <TT
CLASS="FILENAME"
>libpq++</TT
> (C++),
   <TT
CLASS="FILENAME"
>libpgtcl</TT
> (Tcl), <SPAN
CLASS="PRODUCTNAME"
>Perl</SPAN
>, y
   <TT
CLASS="FILENAME"
>ecpg</TT
>.  Algunos aspectos del comportamiento de libpq le 
   resultarán
de importancia si quiere utilizar uno de estos paquetes.
  </P
><P
>   Se incluyen tres programas cortos al final de esta sección para mostrarle como 
   escribir programas que utilicen <TT
CLASS="FILENAME"
>libpq</TT
>.  Hay varios ejemplos
   completos de aplicaciones con <TT
CLASS="FILENAME"
>libpq</TT
> en los siguientes 
   directorios:

   <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>../src/test/regress
../src/test/examples
../src/bin/psql
   </PRE
></TD
></TR
></TABLE
>
  </P
><P
>   Los programas cliente que utilicen <TT
CLASS="FILENAME"
>libpq</TT
> deberán incluir el 
   fichero de cabeceras <TT
CLASS="FILENAME"
>libpq-fe.h</TT
>, y deberán enlazarse 
   con la biblioteca <TT
CLASS="FILENAME"
>libpq</TT
>.
  </P
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="AEN3471"
>Funciones de Conexión a la Base de Datos</A
></H1
><P
>    Las siguientes rutinas le permitirán realzar una conexión al servidor de
    <SPAN
CLASS="PRODUCTNAME"
>Postgres</SPAN
>.  El programa de aplicación puede tener 
    abiertas
varias conexiones a servidores al mismo tiempo. (Una razón para hacer 
    esto es acceder a más de una base de datos). Cada conexión se representa por 
    un objeto PGconn
que se obtiene de PQconnectdb () o PQsetdbLogin (). 
    Nótese que estas funciones
siempre devolverán un puntero a un objeto no nulo, 
    a menos que se tenga demasiada
poca memoria incluso para crear el objeto 
    PGconn. Se debería llamar a la función
PQstatus para comprobar si la conexión 
    se ha realizado con éxito antes
de enviar consultas a traves del objeto de 
    conexión.

    <P
></P
><UL
><LI
><P
>       <TT
CLASS="FUNCTION"
>PQconnectdb</TT
> 
       Realiza una nueva conexión al servidor de base de datos.
       <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>PGconn *PQconnectdb(const char *conninfo)
       </PRE
></TD
></TR
></TABLE
>

   Esta rutina abre una conexión a una base de datos utilizando los parámetros que 
   se
dan en la cadena <TT
CLASS="LITERAL"
>conninfo</TT
>.  Contra lo que ocurre más abajo 
   con PQsetdbLogin(), los parámetros fijados se pueden extender sin cambiar la 
   firma de la
función, de modo que el uso de bien esta rutina o bien las análogas 
   sin bloqueo PQconnetStart / PQconnectPoll resulta preferible para la programación
   de las aplicaciones.
La cadena pasada puede estar varía para utilizar así los
   parámetros de defecto, o puede contener uno o más parámetros separados por
   espacios.
   </P
><P
>   Cada fijación de un parámetro tiene la forma <TT
CLASS="LITERAL"
>keyword = value</TT
>.
   (Para escribir un valor nulo o un valor que contiene espación, se emplearán 
   comillas
simples, por ejemplo <TT
CLASS="LITERAL"
>keyword = 'a value'</TT
>.
   Las comillas simples dentro de un valor se escribirán como <TT
CLASS="LITERAL"
>\'</TT
>.
   Los espacios alrededor del signo igual son opcionales). Los parámetros
   reconocidos actualmente son:

   <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>host</TT
></DT
><DD
><P
>      Nombre del ordenador al que conectarse. Si se da una cadena de longitud 
      distinta de cero, se utiliza comunicación TCP/IP. El uso de este parámetro 
      supone una búsqueda del nombre del ordenador. Ver hostaddr.
     </P
></DD
><DT
><TT
CLASS="LITERAL"
>hostaddr</TT
></DT
><DD
><P
>      Dirección IP del ordenador al que se debe conectar. Debería estar en el 
      formato estandar de números y puntos, como se usan en las funciones de BSD
      inet_aton y otras. Si se especifica una cadena de longitud distinta de cero, 
      se emplea una comunicación TCP/IP.
     </P
><P
>      El uso de <TT
CLASS="LITERAL"
>hostaddr</TT
> en lugar de <TT
CLASS="LITERAL"
>host</TT
> 
      permite a la aplicación evitar la búsqueda del nombre de ordenador, lo que 
      puede ser importante en aplicaciones que tienen una limitación de tiempo.
      Sin embargo la autenticación Kerberos necesita el nombre del ordenador. En 
      este caso de aplica la siguiente secuencia. Si se especifica 
      <TT
CLASS="LITERAL"
>host</TT
> sin <TT
CLASS="LITERAL"
>hostaddr</TT
>, se fuerza la búsqueda
      del nombre del ordenador. Si se especifica <TT
CLASS="LITERAL"
>hostaddr</TT
> sin
      <TT
CLASS="LITERAL"
>host</TT
>, el valor de <TT
CLASS="LITERAL"
>hostaddr</TT
> dará la
      dirección remota; si se emplea Kerberos, se buscará de modo inverso el nombre
      del ordenador. Si se dan tanto <TT
CLASS="LITERAL"
>host</TT
> como 
      <TT
CLASS="LITERAL"
>hostaddr</TT
>, el valor de <TT
CLASS="LITERAL"
>hostaddr</TT
> dará
      la dirección remota; el valor de <TT
CLASS="LITERAL"
>host</TT
> se ignorará, 
      a menos que se emplee Kerberos, en cuyo caso ese valor se utilizará
      para la autenticación Kerberos. Nótese que libpq fallará si se pasa un 
      nombre de ordenador que no sea el nombre de la máquina en
      <TT
CLASS="LITERAL"
>hostaddr</TT
>.
     </P
><P
>      Cuando no se empleen ni uno ni otro, libpq conectará utilizando un socket de
      dominio local.
     </P
></DD
><DT
><TT
CLASS="LITERAL"
>port</TT
></DT
><DD
><P
>      Número del puerto para la conexión en el ordenador servidor, o extensión
      del nombre de fichero del socket para conexión de dominio Unix.
     </P
></DD
><DT
><TT
CLASS="LITERAL"
>dbname</TT
></DT
><DD
><P
>      Nombre de la base de datos.
     </P
></DD
><DT
><TT
CLASS="LITERAL"
>user</TT
></DT
><DD
><P
>      Nombre del usuario que se debe conectar.
     </P
></DD
><DT
><TT
CLASS="LITERAL"
>password</TT
></DT
><DD
><P
>      Password que se deberá utilizar si el servidor solicita una autenticación
      con password.
     </P
></DD
><DT
><TT
CLASS="LITERAL"
>options</TT
></DT
><DD
><P
>       Se pueden enviar las opciones Trace/debug al servidor.
      </P
></DD
><DT
><TT
CLASS="LITERAL"
>tty</TT
></DT
><DD
><P
>      Un fichero o tty para la salida de la depuración opcional desde el servidor.
     </P
></DD
></DL
></DIV
>

   Si no se especifica ningún parámetro, se comprobarán las correspondiente
   variables de entorno. Si no se encuentran fijadas, se emplean los
   valores de defecto codificadas en el programa. El valor devuelto es 
   un puntero a una estructura abstracta que representa la conexión al
   servidor.
   </P
><P
>    Esta función no salva hebra.
   </P
></LI
><LI
><P
>   <TT
CLASS="FUNCTION"
>PQsetdbLogin</TT
>
       Realiza una nueva conexión al servidor de base de datos.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>PGconn *PQsetdbLogin(const char *pghost,
                     const char *pgport,
                     const char *pgoptions,
                     const char *pgtty,
                     const char *dbName,
                     const char *login,
                     const char *pwd)</PRE
></TD
></TR
></TABLE
>

   Esta función es la predecesora de <TT
CLASS="FUNCTION"
>PQconnectdb</TT
>, con un número
   fijado de parámetros, pero con la misma funcionalidad.
   </P
><P
>    Esta función no salva hebra.
   </P
></LI
><LI
><P
>   <TT
CLASS="FUNCTION"
>PQsetdb</TT
> 
       Realiza una nueva conexión al servidor de base de datos.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>PGconn *PQsetdb(char *pghost,
                char *pgport,
                char *pgoptions,
                char *pgtty,
                char *dbName)</PRE
></TD
></TR
></TABLE
>
   Esta es una función que llama a <TT
CLASS="FUNCTION"
>PQsetdbLogin()</TT
> con 
   punteros nulos para los parámetros login y pwd. Se proporciona inicialmente
   para mantener compatibilidad con programas antigüos.
   </P
></LI
><LI
><P
>   <TT
CLASS="FUNCTION"
>PQconnectStart</TT
>
   <TT
CLASS="FUNCTION"
>PQconnectPoll</TT
>
   Realizan una conexión al servidor de base de datos de forma no bloqueante.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>PGconn *PQconnectStart(const char *conninfo)</PRE
></TD
></TR
></TABLE
>
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>PostgresPollingStatusType *PQconnectPoll(PQconn *conn)</PRE
></TD
></TR
></TABLE
>
   Estas dos rutinas se utilizan para abrir una conexión al servidor de base de 
   datos tal que la hebra de ejecución de la aplicación no queda bloqueada en
   el I/O remoto mientras lo hace.
  </P
><P
>   La conexión a la base de datos se realiza utilizando lo parámetros dados en la
   cadena <TT
CLASS="LITERAL"
>conninfo</TT
>, que se pasa a PQconnectStart. Esta cadena
   está en el mismo formato que se describió antes para PQconnectdb.
  </P
><P
>   Ni PQconnectStart ni PQconnectPoll bloquearán, aunque se exigen un cierto número
   de restricciónes:
   <P
></P
><UL
><LI
><P
>      Los parámetros <TT
CLASS="LITERAL"
>hostaddr</TT
> y <TT
CLASS="LITERAL"
>host</TT
> se
      utilizan apropiadamente para asegurar que no se realizan consultas de nombre
      ni
de nombre inverso. Vea la documentación de estos parámetros bajo 
      PQconnectdb antes
para obtener más detalles.
     </P
></LI
><LI
><P
>      Si llama a PQtrace, asegurese de que el objeto de la secuencia en la cual
      realiza usted un rastreo no bloquea.
     </P
></LI
><LI
><P
>      Asegurese usted mismo de que el socket se encuentra en el estado apropiado
      antes de llamar a PQconnetPoll, como se describe más abajo.
     </P
></LI
></UL
>
  </P
><P
>   Para empezar, llame <TT
CLASS="LITERAL"
>conn=PQconnectStart("&#60;connection_info_string&#62;")</TT
>.
   Si conn es NULL, libpq habrá sido incapaz de crear una nueva estructura PGconn.
   De otro modo, se devolverá un puntero PGconn valido (aunque todavía no represente
   una conexión válida a la base de datos). Al regreso de PQconnectStart, llame a
   status=PQstatus(conn). Si status es igual a CONNECTION_BAD, PQconnectStart habrá
   fallado.
  </P
><P
>   Si PQconnectStart funciona con éxito, el siguiente paso es comprobar libpq de 
   forma
que pueda proceder con la secuencia de conexión. Realice un bucle como 
   sigue:
Considere que por defecto una conexión se encuentra 'inactiva'. Si el
   último PQconnectPoll devolvió PGRES_POLLING_ACTIVE, considere ahora que la
   conexión está 'activa'. Si el último PQconnectPoll(conn) devolvió 
   PGRES_POLLING_READING, realice una select para leer en PQsocket(conn). Si 
   devolvió PGRES_POLLING_WRITING,
realice una select para escribir en 
   PQsocket(conn). Si todavía tiene que llamar a
PQconnectPoll, es decir, tras 
   llamar a PQconnectStart, comportese como si hubiera
devuelto 
   PGRES_POLLING_WRITING. Si la select muestra que el socket está preparado
   (ready), considerelo 'activo'. Si ya ha decido que el esta conexión está
   'activa', llame de nuevo a PQconnectPoll(conn).  Si esta llamada devuelve
   PGRES_POLLING_OK, la conexión se habrá establecido con éxito.
  </P
><P
>    Nótese que el uso de select() para asegurar que el socket se encuentra listo
    es realmente un ejemplo; aquellos que dispongan de otras facilidades 
    disponibles,
como una llamada poll(), por supuesto pueden utilizarla en su
    lugar.
  </P
><P
>    En cualquier momento durante la conexión, se puede comprobar la situación de
    esta conexión, llamando a PQstatus. Si el resultado es CONNECTION_BAD, el
    procedimiento de conexión habrá fallado; si es CONNECTION_OK, la conexión está
    funcionando correctamente. Cualquiera de estas situaciones se puede detectar
    del mismo modo a partir del valor de retorno de PQconnectPoll, como ántes. Otras
    situaciones se pueden mostrar durante (y sólo durante) un procedimiento de 
    conexión asíncrona. Estos indican la situación actual del procedimiento de 
    conexión, y se pueden utilizar para proporcionar información de retorno al 
    usuario, por ejemplo. Estas situaciones pueden incluir:
    <P
></P
><UL
><LI
><P
>      CONNECTION_STARTED: Esperando que se realice una conexión.
      </P
></LI
><LI
><P
>      CONNECTION_MADE: Conexión OK; esperando para enviar.
      </P
></LI
><LI
><P
>      CONNECTION_AWAITING_RESPONSE: Esperando una respuesta del postmaster.
      </P
></LI
><LI
><P
>      CONNECTION_AUTH_OK: Recibida autenticación, espera que arranque del servidor.
      </P
></LI
><LI
><P
>      CONNECTION_SETENV: Negociando el entorno.
      </P
></LI
></UL
>

    Téngase en cuenta que, aunque estas constantes se conservarán (para
    mantener la compatibilidad), una aplicación nunca debería basarse en la
    aparición de las mismas en un orden particual, o en todos, o en que las 
    situaciones siempre tengan un valor de estos documentados. Una aplicación
    podría hacer algo así:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>    switch(PQstatus(conn))
    {
        case CONNECTION_STARTED:
            feedback = "Connecting...";
	    break;

        case CONNECTION_MADE:
            feedback = "Connected to server...";
            break;
.
.
.
        default:
	    feedback = "Connecting...";
    }</PRE
></TD
></TR
></TABLE
>
  </P
><P
>   Nótese que si PQconnectStart devuelve un puntero no nulo, deberá usted 
   llamar a PQfinish cuando haya terminado con él, para disponer de la estructura
   y de cualquier bloque de memoria asociado. Se debe hacer esto incluso si ha 
   fallado una llamada a PQconnectStart o a PQconnectPoll.
  </P
><P
>   PQconnectPoll actualmente bloqueará si libpq se compila con USE_SSL definido.
   Esta restricción se eliminará en el futuro.
  </P
><P
>   PQconnectPoll actualmente bloqueará bajo Windows, a menos que libpq se compile
   con WIN32_NON_BLOCKING_CONNECTIONS definida. Este código no se ha probado aún
   bajo Windows, de forma que actualmente se encuentra desactivado por defecto.
   Esto podría cambiar en el futuro.
  </P
><P
>   Estas funciones dejarán el socket en un estado de no-bloqueo como si se hubiese
   llamado a <TT
CLASS="FUNCTION"
>PQsetnonblocking</TT
>.
  </P
><P
>   Estas funciones no aseguran la hebra.
  </P
></LI
><LI
><P
>   <TT
CLASS="FUNCTION"
>PQconndefaults</TT
> Devuelve la opciones de conexión de defecto.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>PQconninfoOption *PQconndefaults(void)

struct PQconninfoOption
{
    char   *keyword;   /* Palabra clave de la opción */
    char   *envvar;    /* Nombre de la variable de entorno que recoge su valor
                          si no se da expresamente */
    char   *compiled;  /* Valor de defecto en el código fuente si tampoco se asigna
                          variable de entorno */
    char   *val;       /* Valor de la opción */
    char   *label;     /* Etiqueta para el campo en el diálogo de conexión */
    char   *dispchar;  /* Carácter a mostrar para este campo en un diálogo de conexión.
                          Los valores son:
                          ""        Muestra el valor entrado tal cual es
                          "*"       Campo de Password - ocultar el valor
                          "D"       Opciones de depuración - No crea un campo por defecto */
    int     dispsize;  /* Tamaño del campo en carácteres para dialogo */
}</PRE
></TD
></TR
></TABLE
>
   Devuelve la dirección de la estructura de opciones de conexión. Esta se
   puede utilizar para determinar todas las opciones posibles de PQconnectdb
   y sus valores de defecto actuales. El valor de retorno apunta a una matriz
   de estructuras PQconninfoOption, que termina con una entrada que tiene un
   puntero a NULL. Note que los valores de defecto (los campos "val") dependerán
   de las variables de entorno y del resto del contexto. Cuando se le llame, se
   deben tratar los datos de las opciones de conexión como de sólo lectura.
   </P
><P
>    Esta función no salva hebra.
   </P
></LI
><LI
><P
>   <TT
CLASS="FUNCTION"
>PQfinish</TT
>
   Cierra la conexión con el servidor. También libera la memoria utilizada por 
   el objeto PGconn.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>void PQfinish(PGconn *conn)</PRE
></TD
></TR
></TABLE
>
   Téngase en cuenta que incluso si falló el intento de conexión con el servidor
   (como se indicaba en PQstatus), la aplicación deberá llamar a PQfinish para
   liberar la memoria utilizada por el objeto PGconn.
   No se debería utilizar el puntero PGconn una vez que se ha llamado a PQfinish.
   </P
></LI
><LI
><P
>   <TT
CLASS="FUNCTION"
>PQreset</TT
>
   Inicializa el puerto de comunicación con el servidor.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>void PQreset(PGconn *conn)</PRE
></TD
></TR
></TABLE
>
   Esta función cerrará la conexión con el servidor e intentará
   establecer una nueva conexión al mismo postmaster, utilizando todos los mismos
   parámetros anteriores. Se puede utilizar para recuperar un error si una 
   conexión que estaba trabajando se pierde.
   </P
></LI
><LI
><P
>   <TT
CLASS="FUNCTION"
>PQresetStart</TT
>
   <TT
CLASS="FUNCTION"
>PQresetPoll</TT
>
   Limpian el puerto de comunicación con el servidor de forma no bloqueante.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>int PQresetStart(PGconn *conn);</PRE
></TD
></TR
></TABLE
>
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>PostgresPollingStatusType PQresetPoll(PGconn *conn);</PRE
></TD
></TR
></TABLE
>
    Estas funciones cerrarán la conexión al servidor e intentarán reestablecer
    una nueva conexión con el mismo postmaster, utilizando los mismos parámetros
    previamente utilizados. Esto puede ser utilizable para recuperaciones de 
    errores si se pierde una conexión que estaba trabajando. Difieren de 
    del anterior PQreset en que lo hacen de una forma no bloqueante. Estas
    funciones sufren las mismas restricciones que PQconnectStart y PQconnectPoll.
   </P
><P
>    Ejecute PQresetStart. Si devuelve 0, la limpieza ha fallado. Si devuelve 1, 
    pruebe la limpieza utilizando PQresetPoll exactamente en la misma forma 
    en que habría creado la conexión utilizando PQconnectPoll.
   </P
></LI
></UL
></P
><P
>Los programadores de aplicaciones con libpq deberían ser cuidadosos de mantener
la abstracción de PGconn. Utilice las funciones siguientes para tomar el contenido
de PGconn. Prohiba las referencias directas a los campos de la estructura PGconn,
ya que están sujetas a cambios en el futuro. (A partir de 
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 6.4, la definición de la estructura 
PGconn incluso ya no se proporciona en <TT
CLASS="FILENAME"
>libpq-fe.h</TT
>. Si 
tiene usted viejas aplicaciones que acceden a campos de PGconn directamente, 
puede usted conservarlas utilizando para incluirla <TT
CLASS="FILENAME"
>libpq-int.h</TT
>
también, pero le recomendamos encarecidamente que fije pronto el código).
<P
></P
><UL
><LI
><P
><TT
CLASS="FUNCTION"
>PQdb</TT
>  
         Devuelve el nombre de la base de datos de la conexión.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>char *PQdb(const PGconn *conn)</PRE
></TD
></TR
></TABLE
>
PQdb y las siguientes funciones devuelven los valores establecidos en la conexión.
Estos valores se fijan para toda la vida de PGconn.
object.</P
></LI
><LI
><P
><TT
CLASS="FUNCTION"
>PQuser</TT
>
         Devuelve el nombre de usuario de la conexión.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>char *PQuser(const PGconn *conn)</PRE
></TD
></TR
></TABLE
></P
></LI
><LI
><P
><TT
CLASS="FUNCTION"
>PQpass</TT
>
         Devuelve la palabra de paso de la conexión.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>char *PQpass(const PGconn *conn)</PRE
></TD
></TR
></TABLE
></P
></LI
><LI
><P
><TT
CLASS="FUNCTION"
>PQhost</TT
>
         Devuelve el nombre del ordenador de servidor de la conexión.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>char *PQhost(const PGconn *conn)</PRE
></TD
></TR
></TABLE
></P
></LI
><LI
><P
><TT
CLASS="FUNCTION"
>PQport</TT
>
         Devuelve el puerto de la conexión.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>char *PQport(const PGconn *conn)</PRE
></TD
></TR
></TABLE
></P
></LI
><LI
><P
><TT
CLASS="FUNCTION"
>PQtty</TT
>
         Devuelve el terminal tty de depuración de la conexión.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>char *PQtty(const PGconn *conn)</PRE
></TD
></TR
></TABLE
></P
></LI
><LI
><P
><TT
CLASS="FUNCTION"
>PQoptions</TT
>
       Devuelve las opciones de servidor utilizadas en la conexión.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>char *PQoptions(const PGconn *conn)</PRE
></TD
></TR
></TABLE
></P
></LI
><LI
><P
><TT
CLASS="FUNCTION"
>PQstatus</TT
>
         Devuelve la situación (status) de la conexión.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>ConnStatusType PQstatus(const PGconn *conn)</PRE
></TD
></TR
></TABLE
></P
><P
>       La situación puede tomar varios valores diferentes.
       Sin embargo, sólo dos de ellos tienen significado fuera
       de un procedimiento de conexión asíncrona:
       <TT
CLASS="LITERAL"
>CONNECTION_OK</TT
> o
       <TT
CLASS="LITERAL"
>CONNECTION_BAD</TT
>. Una buena conexión a la
       base de datos tiene es status CONNECTION_OK. Una conexión
       fallida se señala con la situación
       <TT
CLASS="LITERAL"
>CONNECTION_BAD</TT
>.
       Normalmente, una situación de OK se mantendrá hasta
       <TT
CLASS="FUNCTION"
>PQfinish</TT
>, pero un fallo de las comunicaciones
       puede probocar un cambio prematuro de la situación a 
       <TT
CLASS="LITERAL"
>CONNECTION_BAD</TT
>.
En ese caso, la aplicación 
       podría intentar recuperar la comunicación llamando a 
       <TT
CLASS="FUNCTION"
>PQreset</TT
>.
      </P
><P
>       Para averiguar otras posibles situaciónes que podrían comprobarse,
       revise las entradas de PQconnectStart y PQconnectPoll.
      </P
></LI
><LI
><P
>       <TT
CLASS="FUNCTION"
>PQerrorMessage</TT
>
       Devuelve el mensaje de error más reciente que haya generado alguna
       operación en la conexión.
       <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>char *PQerrorMessage(const PGconn* conn);
       </PRE
></TD
></TR
></TABLE
>
      </P
><P
>       Casi todas las funciones de libpq fijarán el valor de 
       <TT
CLASS="FUNCTION"
>PQerrorMessage</TT
> si fallan.
       Tenga en cuenta que por convención de libpq, un
       <TT
CLASS="FUNCTION"
>PQerrorMessage</TT
> no vacío incluirá un carácter
       "nueva línea" final.
      </P
></LI
><LI
><P
>       <TT
CLASS="FUNCTION"
>PQbackendPID</TT
>
       Devuelve el identificador (<SPAN
CLASS="ACRONYM"
>ID</SPAN
>) del proceso
       del servidor que está controland esta conexión.
       <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>int PQbackendPID(const PGconn *conn);
       </PRE
></TD
></TR
></TABLE
>
       El <SPAN
CLASS="ACRONYM"
>PID</SPAN
> del servidor es utilizable si se quiere
       hacer depuración de errores y para comparar los mensajes de NOTIFY
       (que incluyen el <SPAN
CLASS="ACRONYM"
>PID</SPAN
> del servidor que está realizando
       la notificación). Tenga en cuenta que el <SPAN
CLASS="ACRONYM"
>PID</SPAN
> corresponde
       a un proceso que se está ejecutando en el ordenador servidor de la
       base de datos, ¡no en el ordenador local!
      </P
></LI
><LI
><P
>       <TT
CLASS="FUNCTION"
>PQsetenvStart</TT
>
       <TT
CLASS="FUNCTION"
>PQsetenvPoll</TT
>
       <TT
CLASS="FUNCTION"
>PQsetenvAbort</TT
>
       Realizan una negocación del ambiente.
       <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>PGsetenvHandle *PQsetenvStart(PGconn *conn)
       </PRE
></TD
></TR
></TABLE
>

       <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>PostgresPollingStatusType *PQsetenvPoll(PGsetenvHandle handle)
       </PRE
></TD
></TR
></TABLE
>
       <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>void PQsetenvAbort(PGsetenvHandle handle)
       </PRE
></TD
></TR
></TABLE
>
       Estas dos rutinas se pueden utilizar para re-ejecutar la negociación del 
       entorno que ocurre durante la apertura de una conexión al servidor de la 
       base de datos. No tengo idea de para qué se puede aprovechar esto (¿la 
       tiene alguien?), pero quizá resulte interesante para los usuarios poder
       reconfigurar su codificación de carácteres en caliente, por ejemplo.
      </P
><P
>       Estas funciones no bloquean, sujeto a las restricciones aplicadas a
       PQconnectStart y PQconnectPoll.
      </P
><P
>       Para empezar, llame a handle=PQsetenvStart(conn), donde conn es una 
       conexión abierta con el servidor de la base de datos. Si handle es NULL,
       libpq habrá sido incapaz de situar una nueva estructura PGsetenvHandle.
       En otro vaso, se devuelve una estructura handle valida. (N. del T: Dejo la
       palabra handle como identificador de una estructura de datos la aplicación,
       aunque evidentemente el usuario podrá utilizar el nombre que desee.
       Conociendo los programas que yo programo, normalmente usaría un nombre
       como con_servidor, por ejemplo). Este handle se piensa que sea opaco: sólo
       debe utilizarlo para llamar a otras funciones de libpq (PQsetenvPoll, por
       ejemplo).
      </P
><P
>       Elija el procecimiento utilizando PQsetenvPoll, exactamente del mismo modo 
       en que hubiese creado la conexión utilizando PQconnectPoll.
      </P
><P
>       El procedimiento se puede abortar en cualquier momento llamando a 
       PQsetevnAbort (handle).
      </P
><P
>       Estas funciones no aseguran la hebra.
      </P
></LI
><LI
><P
>       <TT
CLASS="FUNCTION"
>PQsetenv</TT
>
       Realiza una negociación del entorno.
       <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>int PQsetenv(PGconn *conn)
       </PRE
></TD
></TR
></TABLE
>
       Esta función realiza las mismas tareas que PQsetenvStart y PQsetenvPoll, 
       pero bloquea para hacerlo. Devuelve 1 en caso de éxito, y 0 en caso de 
       fracaso.
      </P
></LI
></UL
>
   </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x3445.html"
>Anterior</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="programmer.html"
>Inicio</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x3690.html"
>Siguiente</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Programa de Ejemplo</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Funciones de Ejecución de Consultas</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>