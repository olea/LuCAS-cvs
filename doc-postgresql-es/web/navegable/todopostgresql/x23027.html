<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<HTML
><HEAD
><TITLE
>Planificador/optimizador</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.59"><LINK
REL="HOME"
TITLE="PostgreSQL"
HREF="postgres.html"><LINK
REL="UP"
TITLE="Revisión de las características internas de PostgreSQL"
HREF="overview.html"><LINK
REL="PREVIOUS"
TITLE="El sistema de reglas de
   Postgres"
HREF="x22971.html"><LINK
REL="NEXT"
TITLE="Ejecutor"
HREF="x23081.html"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PostgreSQL</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x22971.html"
>Anterior</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Revisión de las características internas de PostgreSQL</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x23081.html"
>Siguiente</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="AEN23027"
>Planificador/optimizador</A
></H1
><P
>    La tarea del <I
CLASS="FIRSTTERM"
>planificador/optimizador</I
>
    es crear un plan de ejecución óptimo. Primero combina todas
    las posibles vías de <I
CLASS="FIRSTTERM"
>barrer</I
> (scannear) y
    <I
CLASS="FIRSTTERM"
>cruzar</I
> (join) las relaciones que aparecen en
    una consulta. Todas las rutas creadas conducen al mismo resultado y es
    el trabajo del optimizador estimar el coste de ejecutar cada una de
    ellas para encontrar cual es la más económica.
   </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN23033"
>Generando planes posibles</A
></H2
><P
>     El planificador/optimizador decide qué planes deberían generarse
     basándose en los tipos de índices definidos sobre las relaciones
     que aparecen en una consulta. Siempre existe la posibilidad de realizar
     un barrido secuencial de una relación, de modo que siempre se crea
     un plan que sólo utiliza barridos secuenciales. Se asume que hay
     definido un índice en una relación (por ejemplo un índice B-tree)
     y una consulta contiene la restricción <TT
CLASS="LITERAL"
>relation.attribute OPR
     constant</TT
>. Si <TT
CLASS="LITERAL"
>relation.attribute</TT
> acierta
     a coincidir con la clave del índice B-tree y <TT
CLASS="LITERAL"
>OPR</TT
>
     es distinto de '&#60;&#62;' se crea un plan utilizando el índice
     B-tree para barrer la relación. Si hay otros índices presentes y
     las restricciones de la consulta aciertan con una clave de un índice,
     se considerarán otros planes.
    </P
><P
>     Tras encontrar todos los planes utilizables para revisar
     relaciones únicas, se crean los planes para cruzar (join)
     relaciones. El planificador/optimizador considera sólo cruces
     entre cada dos relaciones para los cuales existe una cláusula
     de cruce correspondiente (es decir, para las cuales existe una
     restricción como <TT
CLASS="LITERAL"
>WHERE rel1.attr1=rel2.attr2</TT
>) en
     la cualificación de la WHERE. Se generan todos los posibles planes
     para cada cruce considerado por el planificador/optimizador. Las
     tes posibles estrategias son:

     <P
></P
><UL
><LI
><P
>        <I
CLASS="FIRSTTERM"
>Cruce de iteración anidada</I
> (nested
        iteration join): La relación derecha se recorre para cada tupla
        encontrada en la relación izquierda. Esta estrategia es fácil
        de implementar pero puede consumir mucho tiempo.
       </P
></LI
><LI
><P
>	<I
CLASS="FIRSTTERM"
>Cruce de ordenación mezclada </I
> (merge
	sort join): Cada relación es ordenada por los atributos del
	cruce antes de iniciar el cruce mismo. Después se mezclan las
	dos relaciones teniendo en cuenta que ambas relaciones están
	ordenadas pro los atributos del cruce. Este modelo de cruce es
	más atractivo porque cada relación debe ser barrida sólo una vez.
       </P
></LI
><LI
><P
>	<I
CLASS="FIRSTTERM"
>Cruce indexado</I
> (hash join): La relación
	de la derecha se indexa primero sobre sus atributos para el
	cruce. A continuación, se barre la relación izquierda, y los
	valores apropiados de cada tupla encontrada se utilizan como
	clave indexada para localizar las tuplas de la relación derecha.
       </P
></LI
></UL
>
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN23051"
>Estructura de datos del plan</A
></H2
><P
>     Daremos ahora una pequeña descripción de los nodos que aparecen
     en el plan. La figura \ref{plan} muestra el plan producido para la
     consulta del ejemplo \ref{simple_select}.
    </P
><P
>     El nodo superior del plan es un nodo <TT
CLASS="LITERAL"
>Cruce Mezclado
     (MergeJoin)</TT
> que tiene dos sucesores, uno unido al campo
     <TT
CLASS="LITERAL"
>árbol izquierdo</TT
> (lefttree) y el segundo unido
     al campo <TT
CLASS="LITERAL"
>árbol derecho</TT
> (righttree). Cada uno de
     los subnodos representa una relación del cruce. Como se mencionó
     antes, un cruce de mezcla ordenada requiere que cada relación sea
     ordenada. Por ello encontramos un nodo <TT
CLASS="LITERAL"
>Sort</TT
>
     en cada subplan. La cualificación adicional dada en la consulta
     (<TT
CLASS="LITERAL"
>s.sno &#62; 2</TT
>) se envía tan lejos como es
     posible y se une al campo <TT
CLASS="LITERAL"
>qpqual</TT
> de la rama
     <TT
CLASS="LITERAL"
>SeqScan</TT
> del nodo del correspondiente subplan.
    </P
><P
>     La lista unida al campo <TT
CLASS="LITERAL"
>mergeclauses</TT
> del nodo
     <TT
CLASS="LITERAL"
>Cruce Mezclado (MergeJoin)</TT
> contiene información
     sobre los atributos de cruce. Los valores <TT
CLASS="LITERAL"
>65000</TT
>
     y <TT
CLASS="LITERAL"
>65001</TT
> de los campos <TT
CLASS="LITERAL"
>varno</TT
>
     y los nodos <TT
CLASS="LITERAL"
>VAR</TT
> que aparecen en la lista
     <TT
CLASS="LITERAL"
>mergeclauses</TT
> (y también en la <TT
CLASS="LITERAL"
>lista
     objetivo</TT
>) muestran que las tuplas del nodo actual no
     deben ser consideradas, sino que se deben utilizar en su lugar las
     tuplas de los siguientes nodos "más profundos" (es decir, los nodos
     superiores de los subplanes).
    </P
><P
>     Nótese que todos los nodos <TT
CLASS="LITERAL"
>Sort</TT
> y
     <TT
CLASS="LITERAL"
>SeqScan</TT
> que aparecen en la figura \ref{plan}
     han tomado una <TT
CLASS="LITERAL"
>lista objetivo</TT
>, pero debido
     a la falta de espacio sólo se ha dibujado el correspondiente al
     <TT
CLASS="LITERAL"
>Cruce Mezclado</TT
>.
    </P
><P
>     Otra tarea realizada por el planificador/optimizador es fijar
     los <I
CLASS="FIRSTTERM"
>identificadores de operador</I
> en los
     nodos <TT
CLASS="LITERAL"
>Expr</TT
> y <TT
CLASS="LITERAL"
>Oper</TT
>. Como
     se mencionó anteriormente, <SPAN
CLASS="PRODUCTNAME"
>Postgres</SPAN
>
     soporta una variedad de tipos diferentes de datos, e incluso se
     pueden utilizar tipos definidos por el usuario. Para ser capaz de
     mantener la gran cantidad de funciones y operadores, es necesario
     almacenarlos en una tabla del sistema. Cada función y operador
     toma un identificador de operador único. De acuerdo con los tipos
     de los atributos usados en las cualificaciones, etc, se utilizan
     los identificadores de operador apropiados.
    </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x22971.html"
>Anterior</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="postgres.html"
>Inicio</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x23081.html"
>Siguiente</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>El sistema de reglas de
   <SPAN
CLASS="PRODUCTNAME"
>Postgres</SPAN
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="overview.html"
>Subir</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Ejecutor</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>