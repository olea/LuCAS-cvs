<HTML
><HEAD
><TITLE
>Extensiones de SQL: Agregados</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.54"><LINK
REL="HOME"
TITLE="PostgreSQL"
HREF="postgres.htm"><LINK
REL="UP"
TITLE="Guía del Programador"
HREF="part-programmer.htm"><LINK
REL="PREVIOUS"
TITLE="Extending SQL: Operators"
HREF="xoper.htm"><LINK
REL="NEXT"
TITLE="El Sistema de Reglas de Postgres"
HREF="rules.htm"></HEAD
><BODY
CLASS="CHAPTER"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PostgreSQL</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="xoper.htm"
>Anterior</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="rules.htm"
>Siguiente</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="CHAPTER"
><H1
><A
NAME="XAGGR"
>Capítulo 36. Extensiones de <SPAN
CLASS="ACRONYM"
>SQL</SPAN
>: Agregados</A
></H1
><P
>     Los agregados en 
     <SPAN
CLASS="PRODUCTNAME"
>Postgres</SPAN
> 
     están expresados en términos de funciones de transición de
     estado. Es decir, un agregado puede estar definido en
     términos de un estado que es modificado cuando una instancia
     es procesada. Algunas funciones de estado miran un valor
     particular en la instancia cuando calculan el nuevo estado
     (<SPAN
CLASS="ACRONYM"
>sfunc1</SPAN
> en la sintaxis de create aggregate
     ) mientras que otras sólo se preocupan de su estado interno
     (<SPAN
CLASS="ACRONYM"
>sfunc2</SPAN
>).
     Si definimos un agregado que utiliza solamente
     <SPAN
CLASS="ACRONYM"
>sfunc1</SPAN
>, definimos un agregado que computa
     una función de los atributos de cada instancia.
     "Sum" es un ejemplo de este tipo de agregado. "Sum" comienza
     en cero y siempre añade el valor de la instancia actual
     a su total. Utilizaremos 
<SPAN
CLASS="ACRONYM"
>int4pl</SPAN
> 
     que está integrado en 
     <SPAN
CLASS="PRODUCTNAME"
>Postgres</SPAN
> 
     para realizar esta adición.
     
<PRE
CLASS="PROGRAMLISTING"
>CREATE AGGREGATE complex_sum (
    sfunc1 = complex_add,
    basetype = complex,
    stype1 = complex,
    initcond1 = '(0,0)'
);

SELECT complex_sum(a) FROM test_complex;

         +------------+
         |complex_sum |
         +------------+
         |(34,53.9)   |
         +------------+</PRE
></P
><P
>     Si solamente definimos <SPAN
CLASS="ACRONYM"
>sfunc2</SPAN
>, estamos
     especificando un agregado que computa una funcion que es
     independiente de los atributos de cada instancia.
     "Count"  es el ejemplo más común de este tipo de agregado.
     .  "Count" comienza a cero y añade uno a su total para cada instancia,
     ignorando el valor de instancia. Aquí, utilizamos la rutina integrada
<SPAN
CLASS="ACRONYM"
>int4inc</SPAN
> para hacer el trabajo por nosotros.
     Esta rutina incrementa (añade uno) su argumento.
     
<PRE
CLASS="PROGRAMLISTING"
>CREATE AGGREGATE my_count (
    sfunc2 = int4inc, -- add one
    basetype = int4,
    stype2 = int4,
    initcond2 = '0'
);

SELECT my_count(*) as emp_count from EMP;

         +----------+
         |emp_count |
         +----------+
         |5         |
         +----------+</PRE
></P
><P
>     "Average" es un ejemplo de un agregado que requiere tanto una función
     para calcular la suma actual y una función para calcular el contador
     actual. Cuando todas las instancias han sido procesadas, la respuesta
     final para el agregado es la suma actual dividida por el contador
     actual. Utilizamos las rutinas
     <SPAN
CLASS="ACRONYM"
>int4pl</SPAN
> y <SPAN
CLASS="ACRONYM"
>int4inc</SPAN
> que utilizamos
     anteriormente así como también la rutina de división entera de
     <SPAN
CLASS="PRODUCTNAME"
>Postgres</SPAN
>  
     ,  <SPAN
CLASS="ACRONYM"
>int4div</SPAN
>,  para calcular la división de la suma
     por el contador.
     
<PRE
CLASS="PROGRAMLISTING"
>CREATE AGGREGATE my_average (
    sfunc1 = int4pl,     --  sum
    basetype = int4,
    stype1 = int4,
    sfunc2 = int4inc,    -- count
    stype2 = int4,
    finalfunc = int4div, -- division
    initcond1 = '0',
    initcond2 = '0'
);

SELECT my_average(salary) as emp_average FROM EMP;

         +------------+
         |emp_average |
         +------------+
         |1640        |
         +------------+</PRE
></P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="xoper.htm"
>Anterior</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="postgres.htm"
>Inicio</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="rules.htm"
>Siguiente</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Extending <SPAN
CLASS="ACRONYM"
>SQL</SPAN
>: Operators</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="part-programmer.htm"
>Subir</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>El Sistema de Reglas de <SPAN
CLASS="PRODUCTNAME"
>Postgres</SPAN
></TD
></TR
></TABLE
></DIV
></BODY
></HTML
>