<HTML
><HEAD
><TITLE
>   CREATE OPERATOR
  </TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.54"><LINK
REL="HOME"
TITLE="PostgreSQL"
HREF="postgres.htm"><LINK
REL="UP"
TITLE="Instrucciones SQL"
HREF="sql-commands.htm"><LINK
REL="PREVIOUS"
TITLE="   CREATE LANGUAGE
  "
HREF="sql-createlanguage.htm"><LINK
REL="NEXT"
TITLE="   CREATE RULE
  "
HREF="sql-createrule.htm"></HEAD
><BODY
CLASS="REFENTRY"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PostgreSQL</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="sql-createlanguage.htm"
>Anterior</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="sql-createrule.htm"
>Siguiente</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><H1
><A
NAME="SQL-CREATEOPERATOR"
>CREATE OPERATOR</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN5699"
></A
><H2
>Nombre</H2
>   CREATE OPERATOR
  &nbsp;--&nbsp;   Define un nuevo operador de usuario
  </DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN5702"
></A
><H2
>Synopsis</H2
><PRE
CLASS="SYNOPSIS"
>CREATE OPERATOR <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
> ( PROCEDURE = <TT
CLASS="REPLACEABLE"
><I
>func_name</I
></TT
>
     [, LEFTARG = <TT
CLASS="REPLACEABLE"
><I
>type1</I
></TT
> ] [, RIGHTARG = <TT
CLASS="REPLACEABLE"
><I
>type2</I
></TT
> ]
     [, COMMUTATOR = <TT
CLASS="REPLACEABLE"
><I
>com_op</I
></TT
> ] [, NEGATOR = <TT
CLASS="REPLACEABLE"
><I
>neg_op</I
></TT
> ]
     [, RESTRICT = <TT
CLASS="REPLACEABLE"
><I
>res_proc</I
></TT
> ] [, JOIN = <TT
CLASS="REPLACEABLE"
><I
>join_proc</I
></TT
> ]
     [, HASHES ] [, SORT1 = <TT
CLASS="REPLACEABLE"
><I
>left_sort_op</I
></TT
> ] [, SORT2 = <TT
CLASS="REPLACEABLE"
><I
>right_sort_op</I
></TT
> ] )
  </PRE
><DIV
CLASS="REFSECT2"
><A
NAME="R2-SQL-CREATEOPERATOR-1"
></A
><H3
>    Entradas
   </H3
><P
>&#13;    <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
></DT
><DD
><P
>        El operador a definir. Véanse más abajo los caracteres permitidos.
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>func_name</I
></TT
></DT
><DD
><P
>        La función utilizada para implementar este operador.
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>type1</I
></TT
></DT
><DD
><P
>	El tipo de la parte izquierda del operador, si procede. Esta opción
	debería ser omitida para un operador unario por la derecha.
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>type2</I
></TT
></DT
><DD
><P
> 	El tipo para la parte derecha del operador, si procede. Esta opción
	debería ser omitida para un operador unario por la izquierda.
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>com_op</I
></TT
></DT
><DD
><P
>	El commutador para este operador.
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>neg_op</I
></TT
></DT
><DD
><P
>	El negador para este operador.
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>res_proc</I
></TT
></DT
><DD
><P
>	La función estimadora de restricción selectiva para este operador.
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>join_proc</I
></TT
></DT
><DD
><P
>	***********The join selectivity estimator function for this operator.
	***********La función estimador de ?????
       </P
></DD
><DT
>HASHES</DT
><DD
><P
>Indica que este operador soporta un algoritmo "hash-join".
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>left_sort_op</I
></TT
></DT
><DD
><P
>	Operador que ordena el tipo de dato de la parte izquierda
	de este operador.
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>right_sort_op</I
></TT
></DT
><DD
><P
>	Operador que ordena el tipo de dato de la parte derecha
	de este operador.
       </P
></DD
></DL
></DIV
>
   </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="R2-SQL-CREATEOPERATOR-2"
></A
><H3
>    Salidas
   </H3
><P
>    <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="COMPUTEROUTPUT"
>CREATE
       </TT
></DT
><DD
><P
>	Mensaje devuelto si el operador es creado con éxito.
       </P
></DD
></DL
></DIV
>
   </P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="R1-SQL-CREATEOPERATOR-1"
></A
><H2
>   Description
  </H2
><P
>   <B
CLASS="COMMAND"
>CREATE OPERATOR</B
>  define un nuevo operador,
   <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
>.
   El usuario que define el operador se convierte en su propietario.
  </P
><P
>   El operador <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
>
   es una secuencia de hasta treinta y dos (32) caracteres con cualquiera
   combinación de lo siguiente:
   <P
CLASS="LITERALLAYOUT"
>+&nbsp;-&nbsp;*&nbsp;/&nbsp;&lt;&nbsp;&gt;&nbsp;=&nbsp;~&nbsp;!&nbsp;@&nbsp;#&nbsp;%&nbsp;^&nbsp;&#38;&nbsp;|&nbsp;`&nbsp;?&nbsp;$&nbsp;:&nbsp;<br>
&nbsp;&nbsp;&nbsp;</P
>
   <DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Nota: </B
>     No se permite ningún caracter alfabético en un nombre de operador.
     Esto permite a <SPAN
CLASS="PRODUCTNAME"
>Postgres</SPAN
> analizar la
     entrada SQL en elementos sin requerir espacion entre cada elemento.
     </P
></BLOCKQUOTE
></DIV
>   
  </P
><P
>   El operador "!=" es convertido a "&lt;&gt;" en la entrada, por lo
   que son en consecuencia equivalentes.
  </P
><P
>   Por lo menos uno de LEFTARG o RIGHTARG deben ser definidos. Para
   operadores binarios, ambos deberían ser definidos. Para operadores
   unarios por la derecha, solamente LEFTARG debería ser definido,
   mientras que en operadores unarios por la derecha solamente RIGHTARG
   debería ser definido.
  </P
><P
>   También, el procedimiento 
   <TT
CLASS="REPLACEABLE"
><I
>func_name</I
></TT
> debe
   haber sido previamente definido utilizando
   <B
CLASS="COMMAND"
>CREATE FUNCTION</B
> y debe se definido para aceptar el
   número correcto de argumentos (bien uno o dos).
  </P
><P
>   El operador commutador debería ser identificado si existe uno, para
   que <SPAN
CLASS="PRODUCTNAME"
>Postgres</SPAN
> pudiese invertir el orden de
   los operandos si lo desea.
   Por ejemplo, el operador area-menor-que,
    &lt;&lt;&lt;, debería probablemente tener un operador conmutador
   area-mayor-que&gt;&gt;&gt;.
   De esta forma, el optimizador de consultas podría convertir libremente:

   <PRE
CLASS="PROGRAMLISTING"
>"0,0,1,1"::box  &gt;&gt;&gt; MYBOXES.description
   </PRE
>

   a

   <PRE
CLASS="PROGRAMLISTING"
>MYBOXES.description &lt;&lt;&lt; "0,0,1,1"::box
   </PRE
>
  </P
><P
>   Esto permite la ejecución de código para utiliar siempre la última
   representación y simplifica algo el optimizador.
  </P
><P
>   De forma similar, si existe un operador negador entonces debería ser
   identificado.
   Supongamos que un operador, area-igual, ===, existe, y también un
   operador area-no-igual, !==.
   El negador permite al optimizador simpificar
   <PRE
CLASS="PROGRAMLISTING"
>NOT MYBOXES.description === "0,0,1,1"::box
   </PRE
>
   a 
   <PRE
CLASS="PROGRAMLISTING"
>MYBOXES.description !== "0,0,1,1"::box
   </PRE
>
  </P
><P
>   Si el nombre de un operador commutador es suministrado,
   <SPAN
CLASS="PRODUCTNAME"
>Postgres</SPAN
>
   lo busca en el catálogo. Si es encontrado e no tiene aún un
   commutador él mismo, entonces la entrada del commutador es
   actualizada para tener el recien creado operador como su
   commutador. Esto se aplica al negador, también. 
  </P
><P
>   Esto es para permitir la definición de dos operadores que
   son commutadores de los negadores de cada uno de los otros.
   El primer operador debería der definido sin un commutador
   o negador (como sea apropiado). Cuando el segundo operador
   es definido, se debe nombrar el primero como el commutador
   o negador. El primero será actualizado como un efecto lateral.
   (En Postgres 6.5, esto también funciona para simplemente que
   ambos operadores se refieran al otro).

  </P
><P
>   Los siguientes tres especificadores están presentes para auxiliar
   al optimizador de consultas al realizar uniones ("joins").
   <SPAN
CLASS="PRODUCTNAME"
>Postgres</SPAN
> siempre puede
   evaluar una unión (i.e., procesando una cláusula con dos variables
   de tuplas separadas por un operador que retorno un booleano)
   por substitución iterativa [WONG76].
   Además,<SPAN
CLASS="PRODUCTNAME"
>Postgres</SPAN
>
   es capaz de utilizar un algoritmo "hash-join" siguiendo las
   líneas de [SHAP86]; sin embargo, debe saber si esta estrategia
   es aplicable. Es algoritmo "hash-join" actual es solamente correcto
   para operadores que representan tests de igualdad; además la
   igualdad del tipo de dato debe significar igualdad a nivel de bits
   de la representación del tipo. (Por ejemplo, un tipo de dato que
   contiene bits no utilizados que no tienen repercusión para tests
   de igualdad podría no ser usado en el "hash-join").
   El indicador HASHES indica al optimizador de consultas que un
   hash join poude ser utilizado de forma segura por este operador.
   </P
><P
>   De forma parecida, los dos operadores de orden indican al optimizador
   de consultas si la estrategia mezclar-ordenar es utilizable y que
   operadores deberían ser utilizados para ordenar las clases de los
   dos operadores. Los operadores de orden deberían ser suministrados
   solamente para un operador de igualdad, y deberían referirse a
   operadores menor-que para los tipos de la parte izquierda y derecha
   respectivamente.
  </P
><P
>   Si otras estrategias de unión son consideradas prácticas,
   <SPAN
CLASS="PRODUCTNAME"
>Postgres</SPAN
>
   cambiará el optimizador en tiempo de ejecución para utilizarlas
   y requerirán especificación adicional cuando un operador sea
   definido. Afortunadamente, la comunidad investigadora inventa
   nuevas estrategias de unión infrecuentemente, y la generalidad
   añadida de estrategias definidas por el usuario no merece la
   complejidad resultante.
  </P
><P
>   Las dos últimas piezas de la especificación están presentes
   para que el optimizador pueda estimar los tamaños de los
   resultados. Si una cláusula de la forma:
   <PRE
CLASS="PROGRAMLISTING"
>MYBOXES.description &lt;&lt;&lt; "0,0,1,1"::box
   </PRE
>
   está presente in la cualificación,
   entonces<SPAN
CLASS="PRODUCTNAME"
>Postgres</SPAN
> puede tener que estimar
   la fracción de instancias en MYBOXES que satisfacen la cláusula. 
   La función
   <TT
CLASS="REPLACEABLE"
><I
>res_proc</I
></TT
>
   debe ser una función registrada (lo que significa que ya está definida
   utilizando
   <B
CLASS="COMMAND"
>CREATE FUNCTION</B
>), acepta argumentos del tipo
   correcto y devuelve un numero en punto flotante.
   El optimizador simplemente llama a esta función, pasandole el
   parámetro "0,0,1,1" y multiplica el resultado por el tamaño de
   la relación para obtener el deseado numero de instancias estimado.
  </P
><P
>   Cuando ambos operandos del operador contienen variables de instancia,
   el optimizador debe estimar el tamaño de la unión resultante. La
   función join_proc retornara otro numero decimal que será multiplicado
   por las cardinalidades de las dos clases envueltas en el cómputo
   del tamaño esperado.
  </P
><P
>   La diferencia entre la función
   <PRE
CLASS="PROGRAMLISTING"
>my_procedure_1 (MYBOXES.description, "0,0,1,1"::box)
   </PRE
>
   y el operador
   <PRE
CLASS="PROGRAMLISTING"
>MYBOXES.description === "0,0,1,1"::box
   </PRE
>
   es que<SPAN
CLASS="PRODUCTNAME"
>Postgres</SPAN
>
   intenta optimizar operadores y puede decidir utilizar un índice
   para restringir el espacio de búsqueda cuando aparecen operadores.
   Sin embargo, no se intenta optimizar funciones, y son ejecutadas
   mediante fuerza bruta. Además, las funciones pueden tener cualquier
   número de argumentos mientras que los operadores están restringidos
   a uno o dos.
  </P
><DIV
CLASS="REFSECT2"
><A
NAME="R2-SQL-CREATEOPERATOR-3"
></A
><H3
>    Notes
   </H3
><P
>    Refiérase al capítulo sobre operadores en ls
    <I
CLASS="CITETITLE"
>PostgreSQL User's Guide</I
>
    para más información.
    Refiérase a <B
CLASS="COMMAND"
>DROP OPERATOR</B
> para borrar
    operadores definidos por el usuario de una base de datos.
   </P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="R1-SQL-CREATEOPERATOR-2"
></A
><H2
>   Utilización
   Usage
  </H2
><P
>El siguiente comando define un nuevo operador, area-igualdad, para
   el tipo de dato BOX.
  </P
><PRE
CLASS="PROGRAMLISTING"
>CREATE OPERATOR === (
   LEFTARG = box,
   RIGHTARG = box,
   PROCEDURE = area_equal_procedure,
   COMMUTATOR = ===,
   NEGATOR = !==,
   RESTRICT = area_restriction_procedure,
   JOIN = area_join_procedure,
   HASHES,
   SORT1 = &#60;&#60;&#60;,
   SORT2 = &#60;&#60;&#60;
);
  </PRE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="R1-SQL-CREATEOPERATOR-3"
></A
><H2
>   Compatibility
  </H2
><DIV
CLASS="REFSECT2"
><A
NAME="R2-SQL-CREATEOPERATOR-4"
></A
><H3
>    SQL92
   </H3
><P
>    <B
CLASS="COMMAND"
>CREATE OPERATOR</B
>
    is a <SPAN
CLASS="PRODUCTNAME"
>Postgres</SPAN
> extension.
    There is no <B
CLASS="COMMAND"
>CREATE OPERATOR</B
>
    statement in <SPAN
CLASS="ACRONYM"
>SQL92</SPAN
>.
   </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="sql-createlanguage.htm"
>Anterior</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="postgres.htm"
>Inicio</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="sql-createrule.htm"
>Siguiente</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>CREATE LANGUAGE</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="sql-commands.htm"
>Subir</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>CREATE RULE</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>