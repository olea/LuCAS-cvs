<HTML
><HEAD
><TITLE
>Uso de funciones de conjunto</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.54"><LINK
REL="HOME"
TITLE="PostgreSQL"
HREF="postgres.htm"><LINK
REL="UP"
TITLE="El Lenguaje de consultas"
HREF="query.htm"><LINK
REL="PREVIOUS"
TITLE="Borrados"
HREF="x25427.htm"><LINK
REL="NEXT"
TITLE="Características Avanzadas de SQL en Postgres"
HREF="advanced.htm"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PostgreSQL</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x25427.htm"
>Anterior</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Capítulo 64. El Lenguaje de consultas</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="advanced.htm"
>Siguiente</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="AEN25434"
>Uso de funciones de conjunto</A
></H1
><P
>    Como otros lenguajes de consulta, 
    <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> soporta funciones de conjunto. Una 
	función de conjunto calcula un único resultado a partir de múltiples filas 
	de entrada. Por ejemplo, existen funciones globales para calcular 
    <TT
CLASS="FUNCTION"
>count</TT
>(contar) ,<TT
CLASS="FUNCTION"
>sum</TT
> (sumar),
    <TT
CLASS="FUNCTION"
>avg</TT
> (media), <TT
CLASS="FUNCTION"
>max</TT
> (máximo) and
    <TT
CLASS="FUNCTION"
>min</TT
> (mínimo) sobre un conjunto de instancias. 
   </P
><P
>    Es importante comprender la relación entre las funciones de conjunto y las cláusulas 
    SQL <B
CLASS="COMMAND"
>where</B
> y <B
CLASS="COMMAND"
>having</B
> .
    . La diferencia fundamental entre  <B
CLASS="COMMAND"
>where</B
> y
    <B
CLASS="COMMAND"
>having</B
> es que: <B
CLASS="COMMAND"
>where</B
> selecciona las columnas de
	 entrada antes de los grupos y entonces se computan las funciones de conjunto (de este 
	modo controla qué filas van a la función de conjunto), mientras que
    <B
CLASS="COMMAND"
>having</B
> selecciona grupos de filas después de los grupos y entonces 
	se computan las funciones de conjunto. De este modo la cláusula 
    <B
CLASS="COMMAND"
>where</B
> puede no contener funciones de conjunto puesto que no tiene 
	sentido intentar usar una función de conjunto para determinar qué fila será la entrada 
	de la función. Por otra parte, las cláusulas 
    <B
CLASS="COMMAND"
>having</B
> siempre contienen funciones de conjunto. (Estrictamente 
	hablando, usted puede escribir una cláusula <B
CLASS="COMMAND"
>having</B
>que no use 
	funciones de grupo, pero no merece la pena. La misma condición podría ser usada de un 
	modo más eficaz con<B
CLASS="COMMAND"
>where</B
> .)
   </P
><P
>    Como ejemplo podemos buscar la mínima temperatura en cualquier parte con 

    <PRE
CLASS="PROGRAMLISTING"
>SELECT max(temp_lo) FROM weather;
    </PRE
>

    Si queremos saber qué ciudad o ciudades donde se dieron estas temperaturas, podemos 
	probar 

    <PRE
CLASS="PROGRAMLISTING"
>SELECT city FROM weather WHERE temp_lo = max(temp_lo);
    </PRE
>

    pero esto no funcionará debido a que la función max() no puede ser usada en 
    <B
CLASS="COMMAND"
>where</B
>. Sin embargo y como es frecuente, la consulta 
	puede ser replanteada para llevar a cabo lo que se buscaba. En este caso 
	usando una 
    <I
CLASS="FIRSTTERM"
>subseleccion</I
>:
    <PRE
CLASS="PROGRAMLISTING"
>SELECT city FROM weather WHERE temp_lo = (SELECT max(temp_lo) FROM weather);
    </PRE
>
    Esto es correcto, ya que la subselección es una operación independiente 
	que calcula su propia función de grupo separadamente de lo que ocurre en 
	el select exterior. 
   </P
><P
>    Las funciones de grupo son también muy útiles combinándolas con cláusulas 
    <I
CLASS="FIRSTTERM"
>group by</I
> . Por ejemplo, podemos obtener la temperatura 
	mínima tomada en cada ciudad con :
    <PRE
CLASS="PROGRAMLISTING"
>SELECT city, max(temp_lo)
    FROM weather
    GROUP BY city;
    </PRE
>
    que nos devuelve una fila por ciudad. Podemos filtrar estas filas agrupadas 
	usando  <B
CLASS="COMMAND"
>having</B
>:
    <PRE
CLASS="PROGRAMLISTING"
>SELECT city, max(temp_lo)
    FROM weather
    GROUP BY city
    HAVING min(temp_lo) &#60; 0;
    </PRE
>
    que nos da los mismos resultados, pero de ciudades con temperaturas bajo cero. 
	Finalmente, si sólo nos interesan las ciudades cuyos nombres empiecen por 'P', 
	deberíamos hacer : 
    <PRE
CLASS="PROGRAMLISTING"
>SELECT city, max(temp_lo)
    FROM weather
    WHERE city like 'P%'
    GROUP BY city
    HAVING min(temp_lo) &#60; 0;
    </PRE
>
    Tenga en cuenta que podemos aplicar la restricción del nombre de ciudad en 
    <B
CLASS="COMMAND"
>where</B
>, ya que no necesita funciones de conjunto. Esto es 
	más eficaz que añadir la restricción a <B
CLASS="COMMAND"
>having</B
>,debido a que 
	evitamos hacer los cálculos de grupo para todas las filas que no pasan el 
	chequeo de <B
CLASS="COMMAND"
>where</B
> .
   </P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x25427.htm"
>Anterior</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="postgres.htm"
>Inicio</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="advanced.htm"
>Siguiente</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Borrados</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="query.htm"
>Subir</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Características Avanzadas de <SPAN
CLASS="ACRONYM"
>SQL</SPAN
> en <SPAN
CLASS="PRODUCTNAME"
>Postgres</SPAN
></TD
></TR
></TABLE
></DIV
></BODY
></HTML
>