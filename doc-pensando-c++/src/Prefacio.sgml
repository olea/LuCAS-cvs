<?xml  version="1.0" encoding="iso-8859-1"?>
<!-- -*- sgml -*- -->
<!--
  Editor:              Emacs 21/PSGML
  Traducción original: Miguel Ángel García
  Formateado DocBook:  Miguel Ángel García
  1ª Revisión:
  2ª Revisión
-->

<!DOCTYPE preface PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
                 "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">

<preface>



	 <title>Prefacio</title>

	 <!-- FIXME: aún por formatear, revisar, volver a leer, ... -->

	 <para>
		Como cualquier lenguaje humano, C++ ofrece maneras de expresar
		conceptos. Si se realiza de forma correcta, este medio de
		expresión será significativamente más sencillo y más flexible
		que otras alternativas cuando los problemas crecen en tamaño y
		complejidad.
	 </para>

	 <para>
		No se puede ver C++ sólo como una colección de características;
		algunas de estas características no tienen sentido
		aisladas. Sólo se puede utilizar la suma de las partes si se
		está pensando en el diseño, no sólo en el código. Y para
		entender C++ de esta forma, se deben comprender los problemas
		con C y con la programación en general. Este
		libro trata problemas de programación, porque son problemas, y
		la aproximación que C++ ha elegido para solucionar estos
		problemas. Además, el conjunto de características que explico en
		cada capítulo se basará en la forma en que yo veo un tipo de
		problema en particular, resolviéndose con el lenguaje. De esta
		forma espero llevarle, poco a poco, de entender
		C al punto donde la forma de pensar en C++ se
		convierta en su propia lengua.
	 </para>


	 <!-- en el párrafo siguiente me he tomado algunas licencias que
	 facilitan la comprensión del mismo. Miguel Ángel García -->

	 <para>
		Durante todo el libro, tomaré la actitud de que el lector desea
		construir en su cabeza un modelo que le permita comprender el
		lenguaje bajando hasta sus raices; si se tropieza con un
		rompecabezas, será capaz de compararlo con el modelo en su
		cabeza y deducir la respuesta. Trataré de comunicarle las
		precepciones que han reorientado mi cerebro para hacerme
		comenzar a "Pensar en C++".
	 </para>
	 
	 <sect1>
		<title>Qué es nuevo en la segunda edición.</title>

		<para>
		  Este libro es una minuciosa reescritura de la primera edición
		  para reflejar todos los cambios introducidos en C++ tras la
		  finalización del estándar de C++, y también para reflejar lo
		  que he aprendido desde la escritura de la primera edición. El
		  texto completo presente en la primera edición ha sido
		  examinado y reescrito, en ocasiones quitando viejos ejemplos,
		  a veces cambiando los existentes y añadiendo nuevos, y
		  añadiendo muchos ejercicios nuevos. La significativa
		  reorganización y reordenación del material tuvo lugar para
		  reflejar la disponibilidad de herramientas mejores y mi
		  mejorada comprensión de cómo la gente aprende C++. Se ha
		  añadido un nuevo capítulo que es una introducción rápida a los
		  conceptos de C y a las características básicas de C++ para
		  aquellos que no tienen experiencia en <acronym>C</acronym>,
		  introduciendo el resto del libro. El <acronym>CDROM</acronym>
		  incluido al final del libro contiene un seminario que es una
		  introducción aún más ligera a los conceptos de
		  <acronym>C</acronym> necesarios para comprender C++ (o
		  <acronym>Java</acronym>). Fue creado por Chuck Allison para mi
		  empresa (MindView, Inc.), y se denomina "Pensar en C: Bases de
		  Java y C++". Le presentará los aspectos de
		  <acronym>C</acronym> que son necesarios para que se cambie a
		  C++ o <acronym>Java</acronym>, abandonando los desagradables
		  bits con los que los programadores de <acronym>C</acronym>
		  deben tratar como base diaria pero de los que le alejan los
		  lenguajes C++ y <acronym>Java</acronym> (o incluso eliminan,
		  en el caso de <acronym>Java</acronym>).
		</para>

		<para>
		  Así que la respuesta corta a la preguna "¿Qué es diferente en
		  la segunda edición?" es: aquello que no es completamente nuevo
		  ha sido reescrito, a veces hasta el punto en el que no podrá
		  reconocer los ejemplos y el material originales.
		</para>

		<sect2>
		  <title>Qué contiene el Volumen 2 de este libro</title>

		  <para>
			 Con la finalización del estándar de C++ también se han
			 añadido algunas nuevas librerías importantes, como las
			 string y los contenedores, y algoritmos de la Librería C++
			 Estándar, así como nueva complejidad en las
			 plantillas. Estos y otros tópicos más avanzados se han
			 relegado al Volumen 2 de este libro, incluyendo temas tales
			 como la herencia múltiple, el manejo de excepciones,
			 patrones de diseño, y material sobre la creación y
			 depuración de sistemas estables.
		  </para>
		</sect2>

		<sect2>
		  <title>Cómo obtener el Volumen 2</title> 

		  <para>
			 De la misma manera que el libro que sostiene actualmente,
			 Pensar en C++, el Volumen 2 se puede descargar completo
			 desde mi sitio Web en <ulink
			 url="http://www.BruceEckel.com">www.BruceEckel.com</ulink>. Se
			 puede encontrar información en el sitio Web sobre la fecha
			 prevista para la impresión del Volumen 2.
		  </para>

		  <para>
			 El sitio Web también contiene el código fuente para ambos
			 libros, junto con actualizaciones e información sobre otros
			 <acronym>seminarios-en-CDROM</acronym> que ofrece MidView Inc.,
			 seminarios públicos y formación interna, consultas, soporte y
			 asistentes paso a paso.
		  </para>
		</sect2>
	 </sect1>

	 <sect1>
		<title>Requisitos</title>

		<para>
		  En la primera edición de este libro, decidí aceptar que otra
		  persona le haya enseñado <acronym>C</acronym> y que tiene, al
		  menos, un nivel de lectura aceptable. Mi primera intención fue
		  simplificar lo que encontré difícil: el lenguaje C++. En esta
		  edición he añadido un capítulo que es una introducción rápida
		  a <acronym>C</acronym>, acompañada de el "seminario en CD" de
		  Pensar en C, pero aún asumo que usted tiene algún tipo de
		  experiencia en programación. Además, de la misma manera que se
		  aprenden muchas palabras nuevas intuitivamente viéndolas en el
		  contexto de una novela, es posible aprender mucho sobre
		  <acronym>C</acronym> por el contexto en el que se utiliza en
		  el resto del libro.
		</para>
	 </sect1>

	 <sect1>
		<title>Aprender C++</title>

		<para>
		  Yo me adentré en C++ desde exactamente la misma posición en la
		  que espero que se encuentren muchos de los lectores de este
		  libro: como un programador con una actitud muy sensata y con
		  muchos vicios de programación. Peor aún, mis circunstancias y
		  mi experiencia pertenecían a la programación empotrada a nivel
		  hardware, en la que a veces se considera <acronym>C</acronym>
		  como un lenguaje de alto nivel y excesivamente ineficiente
		  para ahorrar bits. Descubrí más tarde que nunca había sido un
		  buen programador en <acronym>C</acronym>, camuflando mi
		  ignorancia sobre estructuras, malloc() y free(), setjmp() y
		  longimp(), y otros conceptos "sofisticados", muriéndome de
		  vergüenza cuando las materias entraban en la conversación en
		  lugar de investigar el nuevo conocimiento.
		</para>

		<para>
		  Cuando comencé mi lucha por aprender C++, elº único libro
		  decente era el del autodidacta Bjarne Stroustrup's "expert's
		  guide,[1]" por lo que me dejaron simplificar los conceptos
		  básicos por mí mismo. Esto resultó en mi primer libro de C++,
		  [2] que es esencialmente una plasmación de mi experiencia. Fue
		  denominado como una guía de lector para atraer a los
		  programadores a <acronym>C</acronym> y C++ al mismo
		  tiempo. Ambas ediciones [3] del libro acumularon una respuesta
		  entusiasta.
		</para>

		<para>
		  Más o menos al mismo tiempo que aparecía "Using C++", comencé
		  a enseñar el lenguaje en seminarios y presentaciones. Enseñar
		  C++ (y más tarde, <acronym>Java</acronym>) se convirtió en mi
		  profesión; he visto cabezas asintiendo, caras pálidas, y
		  expresiones de perplejidad en audiencias por todo el mundo
		  desde 1989. Cuando comencé a dar formación interna a grupos de
		  gente más pequeños, descubrí algo durante los
		  ejercicios. Incluso aquella gente que estaba sonriendo y
		  asintiendo se encontraba equivocada en muchos
		  aspectos. Descubrí, creando y dirigiendo las pruebas de C++ y
		  <acronym>Java</acronym> durante muchos años en el departamento
		  de Conferencias para el Desarrollo de Software, que otros
		  oradores y yo tendíamos a dar demasiados tópicos, demasiado
		  rápido. Así que, de vez en cuando, a pesar de la variedad del
		  nivel de la audiencia y de la forma en que presentara el
		  material, terminaría perdiendo alguna parte de la
		  audiencia. Quizá sea pedir demasiado, pero como soy una de
		  esas personas que se resisten a la lectura tradicional (y para
		  la mayoría de las personas, creo, esta resistencia resulta del
		  aburrimiento), quise intentar mantener a cada uno a su
		  velocidad.
		</para>

      <para>
		  Durante un tiempo, creé distintas presentaciones en un
		  ordenadas equitativamente. A pesar de esto, terminé por
		  aprender por la experiencia y la repetición (una téctnica que
		  también funciona bien en el diseño de programas C++). De vez
		  en cuando, desarrollaba un curso usando todo lo que había
		  aprendido de mi experiencia en la enseñanza. Esto me hizo
		  cambiar el problema de la enseñanza en pasos discretos,
		  fáciles de digerir, y para un seminario práctico (la situación
		  ideal para el aprendizaje) hay ejercicios al final de cada
		  presentación. Puede encontrar mis seminarios públicos en
		  <ulink url="www.BruceEckel.com">www.BruceEckel.com</ulink>, y
		  también puede aprender de los seminarios que he pasado a
		  <acronym>CDROM</acronym>.
		</para>

		<para>
		  La primera edición de este libro se desarrolló a lo largo de
		  dos años, y el material de este libro ha sido probado con su
		  uso de muchas formas y en muchos seminarios diferentes. La
		  reacción que he obtenido de cada seminario me ha ayudado a
		  cambiar y reorientar el material hasta que he sentido que
		  funciona bien como enseñanzas medias. Pero no es sólo una
		  receta para seminarios; he tratado de recopilar tanta
		  información como he podido en estas páginas, y estructurarlas
		  para atraerle hasta la siguiente materia. Más que nada, el
		  libro está diseñado para servir al lector solitario que lucha
		  con un lenguaje de programación nuevo.
		</para>
	 </sect1>


	 <sect1>
		<title>Metas</title>

		<para>
		  Mis metas en este libro son:</para>

		<orderedlist>
		  <listitem>
			 <para>
				Presentar el material paso a paso, de manera que el lector
				pueda digerir cada concepto fácilmente antes de continuar.
			 </para>
		  </listitem>
		  <listitem>
			 <para>
				Usar ejemplos tan simples y cortos como sea posible. Esto
				a veces me impide manejar problemas del "mundo real", pero
				he descubierto que los principiantes normalmente quedan
				más contentos cuando pueden comprender cada detalle de un
				ejemplo que siendo impresionados por el ámbito del
				problema que soluciona. Además, hay un severo límite en la
				cantidad de código que puede ser absorvido en una
				clase. Por ello a veces recibo críticas por usar "ejemplos
				de juguete", pero tengo la buena voluntad de aceptarlas a
				favor de producir algo pedagógicamente útil.
			 </para>
		  </listitem>

		  <listitem>
			 <para>
				La cuidadosa presentación secuencial de capacidades para
				que no se vea algo que no ha sido explicado. De acuerdo,
				esto no siempre es posible; en esos casos, se dará una
				descripción introductoria breve.
			 </para>
		  </listitem>

		  <listitem>
			 <para>
				Ofrecerle lo que pienso que es importante para que se
				comprenda el lenguaje, más que todo lo que sé. Creo que
				hay una "herencia de la importancia de la información", y
				hay algunos hechos que el 95 por ciento de los
				programadores nunca necesitará saber y que sólo podría
				confundirles y añadirse a su percepción de la complejidad
				del lenguaje. Tomando un ejemplo de <acronym>C</acronym>,
				si memoriza la tabla de precedencia de los operadores (yo
				nunca lo hice), puede escribir código más corto. Pero si
				lo piensa, esto confundirá al lector/actualizador de ese
				código. Así que olvide la precedencia, y utilice
				paréntesis cuando las cosas no estén claras. Esta misma
				actitud se tomará con alguna información del lenguaje C++,
				la cual creo que es más importante para escritores de
				compiladores que para programadores.
			 </para>
		  </listitem>

		  <listitem>
			 <para>
				Mantener cada sección suficientemente enfocada como para
				que el tiempo de lectura -y el tiempo entre los
				ejercicios- sea razonable. Esto no sólo mantiene las
				mentes de la audiencia más activas e involucradas durante
				un seminario práctico, sino que también ofrece al lector
				un mayor sentido de realización.
			 </para>
		  </listitem>
		  
		  <listitem>
			 <para>
				Dar a los lectores una base sólida de manera que puedan
				comprender las cuestiones lo suficientemente bien como
				para cambiar a otros cursos y libros más difíciles (en
				particular, el Volumen 2 de este libro).
			 </para>
		  </listitem>

		  <listitem>
			 <para>
				He tratado de no utilizar ninguna versión de C++ de
				ningúna compañía en particular porque, para aprender el
				lenguaje, no creo que los detalles de una implementación
				en particular sean tan importantes como el lenguaje
				mismo. La mayoría de la documentación de las compañías
				sobre su propia expecificación es adecuada.
			 </para>
		  </listitem>
		</orderedlist>
	 </sect1>

	 <sect1>
		<title>Capítulos</title>

		<para>
		  C++ es un lenguaje en el que se construyen características
		  nuevas y diferentes sobre una sintaxis existente (por esta
		  razón, nos referiremos a él como un lenguaje de programación
		  orientado a objetos híbrido). Como mucha gente sigue una curva
		  de aprendizaje, hemos comenzado a apegarnos por la forma en
		  que los programadores atraviesan las etapas de las
		  características del lenguaje C++. Como parece ser la
		  progresión natural de una mente entrenada modularmente, he
		  decidido comprender y seguir el mismo camino y acelerar el
		  proceso proponiendo y resolviendo las preguntas que se me
		  ocurrieron cuando yo aprendía el lenguaje y también las que se
		  me ocurrieron en las audiencias en las que yo enseñaba dicho
		  lenguaje.
		</para>

		<para>
		  El curso fue diseñado con algo en mente: racionalizar el
		  proceso de aprender C++. La reacción de la audiencia me ayudó
		  a comprender qué partes eran difíciles y necesitaban una
		  iluminación extra. En las áreas en las que me volvía ambicioso
		  e incluía demasiadas características de una vez, me di cuenta
		  -mediante el proceso de la entrega de material- de que si
		  incluyes demasiadas características, tendrás que explicarlas
		  todas, y la confusión de los estudiantes se verá fácilmente
		  agravada. Como resultado, he tenido muchos problemas para
		  introducir las características tan lentamente como ha sido
		  posible; sólo un concepto importante a la vez por capítulo.
		</para>

		<para>
		  La meta para cada capítulo es, entonces, enseñar un concepto
		  simple, o un pequeño grupo de conceptos asociados, en caso de
		  que no haya más conceptos adicionales. De esa forma puede
		  digerir cada parte en el contexto de su conocimiento actual
		  antes de continuar. Para llevar esto a cabo, dejé algunas
		  partes de <acronym>C</acronym> en algún lugar más adelante del
		  que preferiría. El beneficio es que no se confunda por ver
		  usadas todas las características de C++ antes de que éstas
		  sean explicadas, así su introducción al lenguaje será
		  tranquila y reflejará la forma en que asimile las
		  características que dejo en sus manos.
		</para>

		<para>
		  He aquí una breve descripción de los capítulos que contiene
		  este libro:
		</para>


      <para>
		Capítulo <ref id="C1" name=""/>: <!-- FIXME: título del capítulo
		  1 -->
		  Cuando los proyectos se vuelven demasiado grandes y difíciles
		  de mantener, nace la <quote>crisis de software</quote>, que es
		  cuando los programadores dicen: <quote>¡No podemos terminar
		  los proyectos, y cuando podemos, son demasiado
		  caros!</quote>. Esto provoca gran cantidad de respuestas, que
		  se discuten en este capítulo mediante las ideas de
		  programación orientada a objetos (<acronym>POO</acronym>) y
		  cómo afecta ésta a resolver la crisis de software. El capítulo
		  le hará pasar por las características y conceptos básicos de
		  la POO y también introduce el análisis y diseño de
		  procesos. Además, aprenderá los beneficios y problemas de
		  adaptar el lenguaje, y obtendrá sugerencias para adentrarse en
		  el mundo de C++.
      </para>

      <para>
		  Capítulo <ref id="C2" name="Construir y usar objetos"/>: 
		  Este capítulo explica el proceso
		  de construir programas usando compiladores y
		  librerías. Presenta el primer programa C++ del libro y muestra
		  cómo se construyen y compilan los programas. Después se
		  presentan algunas de las librerías de objetos básicas que están
		  disponibles en C++ estándar. Para cuando acabe el capítulo,
		  dominará lo que se refiere a escribir un programa C++
		  utilizando las librerías de objetos incluídas.<!--FIXME-->
		</para>

      <para>
		  Capítulo <ref id="C3"/>:
		  Este capítulo es una densa vista general de las
		  características de C que se utilizan en C++, así como gran
		  número de características básicas que sólo están disponibles
		  en C++. Además introduce la utilidad <quote>make</quote>, que
		  es común en el desarrollo software de todo el mundo y que se
		  utiliza para construir todos los ejemplos de este libro (el
		  código fuente de este libro, que está disponible en <ulink
		  url="http://www.BruceEckel.com">www.BruceEckel.com</ulink>,
		  contiene los makefiles correspondientes a cada capítulo). El
		  capítulo 3 supone que tiene unos conocimientos básicos sólidos
		  en algún lenguaje de programación procedural como Pascal, C, o
		  incluso algún tipo de Basic (basta con que haya escrito algo
		  de código en ese lenguaje, especialmente funciones). Si
		  encuentra este capítulo demasiado difícil, debería ir primero
		  por el seminario <quote>Pensar en C</quote> del CD que
		  acompaña este libro (y también disponible en <ulink
		  url="http://www.BruceEckel.com">www.BruceEckel.com</ulink>).
		</para>

      <para>
		  Capítulo <ref id="C4"/>:
		  La mayor parte de las características de C++ giran entorno a
		  la capacidad de crear nuevos tipos de datos. Esto no sólo
		  ofrece una mayor organización del código, sino que es el
		  trabajo preliminar para las capacidades de POO más poderosas. Verá
		  cómo esta idea se facilita con el simple hecho de poner
		  funciones dentro de las estructuras, los detalles de cómo
		  hacerlo, y qué tipo de código se escribe. También aprenderá la
		  mejor manera de organizar su código mediante archivos de cabecera y
		  archivos de implementación.
		</para>

      <para>
		  Capítulo <ref id="C5"/>:
		  Se puede decidir que algunos de los datos y funciones de su
		  estructura no estén disponibles para el usuario del tipo nuevo
		  haciéndolas privadas. Esto significa que se puede separar la
		  implementación principal de la interfaz que el programador
		  cliente ve, y de este modo permitir que la implementación se
		  cambie fácilmente sin afectar al código del cliente. La
		  palabra clave <literal role="keyword">class</literal> también
		  se introduce como una manera más imaginativa de describir un
		  tipo de datos nuevo, y el significado de la palabra
		  <quote>objeto</quote> se desmistifica (es una variable
		  divertida).
		</para>

       <para>
		  Capítulo <ref id="C6"/>:
		  Uno de los errores más comunes en C se debe a las variables no
		  inicializadas. El constructor de C++ permite garantizar que
		  las variables de su nuevo tipo de datos (<quote>objetos de su
		  clase</quote>) siempre serán inicializados correctamente. Si
		  sus objetos también requieren algún tipo de reciclado, usted
		  puede garantizar que este reciclado siempre se realizará
		  mediante el destructor C++.
		</para>
		
		<para>
		  Capítulo <ref id="C7"/>:
		  Se desea que C++ le ayude a construir proyectos grandes y
		  complejos. Mientras que lo consigue, puede obtener múltiples
		  bibliotecas que utilicen el mismo nombre de funciones, y
		  también puede decidir utilizar un mismo nombre con diferentes
		  significados en la misma biblioteca. C++ lo hace sencillo
		  mediante la sobrecarga de funciones, lo que le permite
		  reutilizar el mismo nombre de función siempre que la lista de
		  argumentos sea diferente. Los argumentos por defecto le
		  permiten llamar a la misma función de diferentes maneras
		  proporcionando, automáticamente, valores por defecto para
		  algunos de sus argumentos.
		</para>

		<para>
		  Capítulo <ref id="C8"/>:
		  Este capítulo cubre las palabras reservadas <literal
		  role="keyword">const</literal> y <literal
		  role="keyword">volatile</literal>, que en C++ tienen un
		  significado adicional, especialmente dentro de las
		  clases. Aprenderá lo que significa aplicar <literal
		  role="keyword">const</literal> a una definición de
		  punteros. El capítulo también muestra cómo varía el
		  significado de <literal role="keyword">const</literal> según
		  se utilice dentro o fuera de las clases y cómo crear
		  constantes inherentes a las clases en tiempo de compilación.
		</para>
		
		<para>
		  Capítulo <ref id="C9"/>:

		  Las macros del preprocesador eliminan la llamada a funciones
		  superiores, pero el preprocesador también elimina la valiosa
		  comprobación de tipos de C++. Las funciones en línea le
		  ofrecen todos los beneficios de una macro de preprocesador
		  además de los beneficios de una verdadera llamada a función. Este
		  capítulo explora minuciosamente la implementación y uso de las
		  funciones en línea.
		</para>
		
		<para>
		  Capítulo <ref id="C10"/>:

		  La elección de nombres es una actividad fundamental en la
		  programación y, cuando un proyecto se vuelve grande, el número
		  de nombres puede ser arrollador. C++ le permite un gran
		  control de los nombres en función de su creación, visibilidad,
		  lugar de almacenamiento y enlazado. Este capítulo muestra cómo
		  se controlan los nombres en C++ utilizando dos
		  técnicas. Primero, la palabra clave <literal
		  role="keyword">static</literal> se utiliza para controlar la
		  visibilidad y enlazado, y se explora su significado especial
		  para clases. Una técnica mucho más util para controlar los
		  nombres a nivel global es la capacidad del espacio de nombres
		  de C++, que le permite dividir el espacio de nombres global en
		  distintas regiones.
		</para>
		
		<para>
		  Capítulo <ref id="C11"/>:
		  Los punteros de C++ trabajan como los punteros de C con el
		  beneficio adicional de la comprobación de tipos más fuerte de
		  C++. C++ también proporciona un método adicional para manejar
		  direcciones: C++ copia la <emphasis>referencia</emphasis> de
		  Algol y Pascal, que permite al compilador manejar la
		  manipulación de direcciones mientras se utiliza la notación
		  ordinaria. También encontrará el Constructor de Copia, que
		  controla la manera en que los objetos se pasan por valor hacia
		  o desde las funciones. Finalmente, se ilumina el puntero a
		  miembros de C++.
		</para>
		
		<para>
		  Capítulo <ref id="C12"/>:

		  Esta característica se llama algunas veces <quote>azúcar
		  sintáctico</quote>; permite dulcificar la sintaxis de uso de
		  su tipo permitiendo operadores así como llamadas a
		  funciones. En este capítulo aprenderá que la sobrecarga de
		  operadores sólo es un tipo de llamada a función diferente y
		  aprenderá cómo escribir los suyos propios, manejando el -a
		  veces confuso- uso de los argumentos, devolviendo tipos, y la
		  decisión de si hacer un operador miembro o amigo.
		</para>
		
		<para>
		  Capítulo <ref id="C13"/>:

		  ¿Cuántos aviones necesitará manejar un sistema de tráfico
		  aéreo? ¿Cuántas formas requerirá un sistema CAD? En el
		  problema de la programación genérica, no se puede saber la
		  cantidad, tiempo de vida o el tipo de los objetos necesitará
		  el programa una vez lanzado. En este capítulo, aprenderá cómo
		  <literal role="keyword">new</literal> y <literal
		  role="keyword">delete</literal> solventan elegantemente este
		  problema en C++ creando objetos en el montón. También verá
		  cómo <literal role="keyword">new</literal> y <literal
		  role="keyword">delete</literal> pueden sobrecargarse de
		  variadas maneras de forma que puedan controlar cómo se asigna
		  y se recupera el almacenamiento.
		</para>

		<para>
		  Capítulo <ref id="C14"/>:

		  La abstracción de datos le permite crear tipos nuevos de la
		  nada, pero con composición y herencia, se puede crear tipos
		  nuevos de los ya existentes. Con la composición, se puede
		  ensamblar un tipo nuevo utilizando los otros tipos como
		  piezas y, con la herencia, puede crear una versión más
		  expecífica de un tipo existente. En este capítulo aprenderá la
		  sintaxis, cómo redefinir funciones y la importancia de la
		  construcción y destrucción para la herencia y la composición.
		</para>

		<para>
		  Capítulo <ref id="C15"/>:
		  Por su parte, debería tomarle nueve meses descubrir y
		  comprender esta piedra angular de la POO. A través de
		  ejercicios pequeños y simples, verá cómo crear una familia de
		  tipos con herencia y manipular objetos de esa familia mediante
		  su clase base común. La palabra reservada <literal
		  role="keyword">virtual</literal> le permite tratar todos los
		  objetos de su familia de forma genérica, lo que significa que
		  el grueso del código no depende de información de tipo
		  específica. Esto hace extensibles sus programas, de manera que
		  construir programas y mantener el código sea más sencillo y
		  más barato.
		</para>

		<para>
		  Capítulo <ref id="C16"/>:

		  La herencia y la composición permiten reutilizar el código
		  objeto, pero eso no resuelve todas las necesidades de
		  reutilización. Las plantillas permiten reutilizar el código
		  fuente proporcionando al compilador un medio para sustituir el
		  nombre de tipo en el cuerpo de una clase o función. Esto
		  sostiene el uso de bibliotecas de clase recipiente, lo que son
		  herramientas importantes para el desarrollo rápido y robusto
		  de programas orientados a objetos (la Biblioteca Estándar de
		  C++ incluye una biblioteca significativa de clases
		  recipiente). Este capítulo da una base minuciosa en esta
		  materia esencial.
		</para>

		<para>
		  Temas adicionales (y materias más avanzadas) están disponibles
		  en el Volumen 2 de este libro, que puede ser obtenido del
		  sitio web <ulink
		  url="http://www.BruceEckel.com">www.BruceEckel.com</ulink>.
		</para>
	 </sect1>

	 <sect1>
		<title>Ejercicios</title>

		<para>
		  He descubierto que los ejercicios son excepcionalmente útiles
		  durante un seminario para completar la comprensión de los
		  estudiantes, así que encontrará algunos al final de cada
		  capítulo. El número de ejercicios ha sido incrementado
		  enormemente respecto a la primera edición.
		</para>

		<para>
		  Muchos de los ejercicios son suficientemente sencillos como
		  para que puedan terminarse en una cantidad de tiempo razonable
		  en una clase o apartado de laboratorio mientras el instructor
		  observa, asegurándose de que todos los estudiantes absorven el
		  material. Algunos ejercicios son un poco más complejos para
		  mantener entretenidos a los estudiantes avanzados. El grueso
		  de los ejercicios se orienta a ser resueltos en poco tiempo y
		  se intenta sólo probar y educar su conocimiento más que
		  presentar retos importantes (seguramente los encontrará usted
		  mismo -o más probablemente, ellos le encontrarán a usted).
		</para>

		<sect2>
		  <title>Soluciones a los ejercicios</title>

		  <para>
			 Las soluciones a los ejercicios seleccionados pueden
			 encontrarse en el documento electrónico <emphasis>El
			 Solucionario de Pensar en C++</emphasis>, disponible por una
			 pequeña cantidad en <ulink
			 url="http://www.BruceEckel.com">www.BruceEckel.com</ulink>.
		  </para>
		</sect2>
	 </sect1>
	 
	 <sect1>
		<title>Código fuente</title>

		<para>
		  El código fuente de este libro está registrado como software
		  gratuíto, distribuido mediante el sitio Web <ulink
		  url="http://www.BruceEckel.com">www.BruceEckel.com</ulink>. El
		  registro le impide publicar el código en un medio impreso sin
		  permiso, pero se le asegura el derecho de usarlo de muchas
		  otras maneras (ver más abajo).
		</para>

		<para>
		  El código está disponible en un fichero comprimido, destinado
		  a extraerse desde cualquier plataforma que tenga una utilidad
		  <quote>zip</quote> (la mayoría lo tienen; puede buscar en
		  Internet para encontrar una versión para su platarforma si aún
		  no tiene una instalada). En el directorio inicial donde
		  desempaquete el código encontrará la siguiente nota de
		  registro:
		</para>


<!-- FIXME: no tengo ni idea de cómo poner lo siguiente: -->
<!--
		<para>
		  <citation>
//:! :Copyright.txt
Copyright (c) 2000, Bruce Eckel
Source code file from the book "Thinking in C++"
All rights reserved EXCEPT as allowed by the
following statements: You can freely use this file
for your own work (personal or commercial),
including modifications and distribution in
executable form only. Permission is granted to use
this file in classroom situations, including its
use in presentation materials, as long as the book
"Thinking in C++" is cited as the source. 
Except in classroom situations, you cannot copy
and distribute this code; instead, the sole
distribution point is http://www.BruceEckel.com 
(and official mirror sites) where it is
available for free. You cannot remove this
copyright and notice. You cannot distribute
modified versions of the source code in this
package. You cannot use this file in printed
media without the express permission of the
author. Bruce Eckel makes no representation about
the suitability of this software for any purpose.
It is provided "as is" without express or implied
warranty of any kind, including any implied
warranty of merchantability, fitness for a
particular purpose, or non-infringement. The entire
risk as to the quality and performance of the
software is with you. Bruce Eckel and the
publisher shall not be liable for any damages
suffered by you or any third party as a result of
using or distributing this software. In no event 
will Bruce Eckel or the publisher be liable for 
any lost revenue, profit, or data, or for direct,
indirect, special, consequential, incidental, or
punitive damages, however caused and regardless of
the theory of liability, arising out of the use of
or inability to use software, even if Bruce Eckel
and the publisher have been advised of the
possibility of such damages. Should the software
prove defective, you assume the cost of all
necessary servicing, repair, or correction. If you
think you've found an error, please submit the
correction using the form you will find at
www.BruceEckel.com. (Please use the same
form for non-code errors found in the book.)
///:~
		  </citation>
		</para>		  
-->
<!-- FIXME: bueno, admito ideas. Sigo con lo siguiente -->


		<para>
		  Se puede usar el código en proyectos y clases siempre y cuando
		  la nota de registro se mantenga.
		</para>
	 </sect1>


	 <sect1>
		<title>Estándares del lenguaje</title>

		<para>
		  Durante todo el libro, cuando se haga referencia al estándar
		  de C ISO, generalmente se dirá <quote>C</quote>. Sólo si se
		  necesita distinguir entre C Estándar y otros más viejos,
		  versiones previas al Estándar de C, se hará la distinción.
		</para>

		<para>
		  Cuando se escribió esto, el Comité de Estándares de C++ ya
		  había terminar de trabajar en el lenguaje. De este modo, se
		  usará el término C++ Estándar para referirse al lenguaje
		  estandarizado. Si se hace referencia simplemente a C++,
		  debería asumir que se quiere decir <quote>C++
		  Estándar</quote>.
		</para>

		<para>
		  Hay alguna confusión sobre el nombre real del Comité de
		  Estándares de C++ y el nombre del estándar mismo. Steve Clamage, el
		  presidente del comité, clarificó esto:
		</para>

		<!-- FIXME: no sé si es correcto formatearlo de la siguiente
		manera: -->

		<para>
		  <emphasis>Hay dos comités de estandarización de C++: El comité
		  NCITS (antiguamente X3) J16 y el comité ISO
		  JTC1/SC22/WG14. ANSI alquila NCITS para crear comités técnicos
		  para desarrollar estándares nacionales americanos.</emphasis>
		</para>

		<para>
		  <emphasis>J16 fue alquilado en 1989 para crear un estándar
		  americano para C++. Por el año 1991 se alquiló WG14 para crear
		  un estándar internacional. El proyecto J16 se convirtión en un
		  proyecto <quote>Tipo I</quote> (Internacional) y se subordinó
		  al esfuerzo de estandarización de ISO.</emphasis>
		</para>

		<para>
		  <emphasis>Los dos comités se encontraron al mismo tiempo en el
		  mismo sitio, y el voto de J16 constituye el voto americano con
		  WG14. WG14 delega el trabajo técnico a J16. WG14 vota por el
		  trabajo técnico de J16.</emphasis>
		</para>
		
		<para>
		  <emphasis>El estándar de C++ fue creado originariamente como
		  un estándar ISO. ANSI votó más tarde (como recomendaba J16)
		  para adoptar el estándar de C++ ISO como el estándar americano
		  para C++.</emphasis>
		</para>

		<para>
		  Así, <quote>ISO</quote> es la forma correcta de referirse al
		  estándar de C++.
		</para>

		
		<sect2>
		  <title>Soporte del lenguaje</title>

		  <para>
			 Puede que su compilador no disponga de todas las
			 características discutidas en este libro, especialmente si
			 no tiene la versión más actual del compilador. Implemtar un
			 lenguaje como C++ es una tarea hercúlea, y puede esperar que
			 las características aparecerán poco a poco en lugar de todas
			 a la vez. Pero si prueba uno de los ejemplos del libro y
			 obtiene un montón de errores del compilador, no es
			 necesariamente un error en el código o el compilador;
			 simplemente puede no estar implementado aún en su compilador
			 particular.
		  </para>
		</sect2>
	 </sect1>


	 <sect1>
		<title>El CD-ROM del libro.</title>

		<para>
		  El contenido principal del CDROM empaquetado al final de este
		  libro es un <quote>seminario en CDROM</quote> titulado
		  <emphasis>Pensar en C</emphasis>: Fundamentos para Java y C++
		  obra de Chuck Allison (publicado por MindView, Inc., y también
		  disponible en grandes cantidades en <ulink
		  url="http://www.BruceEckel.com">www.BruceEckel.com</ulink>). Esto
		  contiene muchas horas de grabaciones y transparencias, que pueden
		  mostrarse en la mayoría de las computadoras que disponen de
		  lector de CDROM y sistema de sonido.
		</para>

		<para>
		  El objetivo de <emphasis>Pensar en C</emphasis> es llevarle
		  cuidadosamente a través de los fundamentos del lenguaje C. Se
		  centra en el conocimiento que necesita para poder cambiar a
		  los lenguajes C++ o Java en lugar de intentar hacerle un
		  experto en todos los recovecos de C (una de las razones de
		  utilizar un lenguaje de alto nivel como C++ o Java es,
		  precisamente, que se pueden evitar muchos de esos
		  recovecos). También contiene ejercicios y soluciones
		  guiadas. Téngalo en cuenta porque el Capítulo <ref id="C3"/>
		  de este libro va más allá del CD de <emphasis>Pensar en
		  C</emphasis>, el CD no es una alternativa a este capítulo,
		  sino que debería utilizarse como preparación para este libro.
		</para>

       <para>
		  Por favor, advierta que el CDROM está basado en navegador, por
		  lo que debería tener un navegador Web instalado en su máquina
		  antes de utilizarlo.
		</para>

	 </sect1>

	 
	 <sect1>
		<title>CDROMs, seminarios, y consultas</title>

		<para>
		  Hay seminarios en CD-ROM planeados para cubrir el Volumen 1 y
		  el Volumen 2 de este libro.  Éstos comprenden muchas horas de
		  grabaciones mías que acompañan las transparencias que cubren
		  el material seleccionado de cada capítulo del libro. Pueden
		  verse en la mayoría de las computadoras que disponen de lector
		  de CDROM y sistema de sonido. Estos CDs pueden comprarse en
		  <ulink
		  url="http://www.BruceEckel.com">www.BruceEckel.com</ulink>,
		  donde encontrará más información y lecturas de ejemplo.
		</para>


		<!-- FIXME: en el siguiente párrafo aparece la expresión "code
		walkthrows" que no sé traducir. Se ha rodeado de 5 asteriscos -->
		<para>
		  Mi compañía, MindView, Inc., proporciona seminarios de
		  preparación práctica públicos basados en el material de este
		  libro y también en temas avanzados. El material seleccionado
		  de cada capítulo representa una lección, que se continúa con
		  un periodo de ejercicios monitorizados para que cada
		  estudiante reciba atención personal. También propocionamos
		  preparación <quote>in situ</quote>, consultoría, tutorización,
		  y diseño y ***** code walkthrows*****. Puede encontrar la información y los
		  formularios para los próximos seminarios, así como otra
		  información de contacto, en <ulink
		  url="http://www.BruceEckel.com">www.BruceEckel.com</ulink>.
		</para>

       <para>
		  A veces me encuentro disponible para consultas de diseño,
		  evaluación de procesos y ****code walkthrows*****. Cuando
		  comencé a escribir sobre computadoras, mi motivación principal
		  fue incrementar mis actividades de consultoría, porque
		  encontraba que la consultoría era competitiva, educacional, y
		  una de mis experiencias profesionales más valiosas. Así haré
		  todo loq ue pueda para incluirle a usted en mi agenda, o para
		  proporcionarle uno de mis socios (que son gente que conozco
		  bien y con la que he tratado, y a menudo gente que
		  co-desarrollan e imparten seminarios conmigo).
		</para>
	 </sect1>

	 
	 <sect1>
		<title>Errores</title>

		<para>
		  No importa cuántos trucos emplee un escritor para detectar los
		  errores, algunos siempre se escapan y saltan del papel al
		  lector atento. Si encuentra algo que crea que es un error, por
		  favor, utilice el formulario de correcciones que encontrará al
		  en <ulink
		  url="http://www.BruceEckel.com">www.BruceEckel.com</ulink>. Se
		  agradece su ayuda.
		</para>
	 </sect1>


	 <sect1>
		<title>Sobre la portada.</title>

		<para>
		  La primera edición de este libro tenía mi cara en la portada,
		  pero para la segunda edición yo quería desde el principio una
		  portada que se pareciera más una obra de arte, como la portada
		  de <emphasis>Pensar en Java</emphasis>. Por alguna razón, C++
		  parece sugerirme Art Decó con sus curvas simples y pinceladas
		  cromadas. Tengo en mente algo como esos carteles de barcos y
		  aviones con cuerpos dulcemente largos.
		</para>
		
		<para>
		  Mi amigo Daniel Will-Harris, (<ulink
		  url="http://www.Will-Harris.com">www.Will-Harris.com</ulink>)
		  a quien conocí en las clases del coro del instituto, iba a
		  llegar a ser un diseñador y escritor de talla mundial. Él ha
		  echo prácticamente todos mis diseños, incluída la portada para
		  la primera edición de este libro. Durante el proceso de diseño
		  de la portada, Daniel, insatisfecho con el progreso que
		  realizábamos, siempre preguntaba: <quote>¿Cómo hace esto para
		  relacionar a la gente con las
		  computadoras?</quote>". Estábamos atascados.
		</para>

		<para>
		  Como capricho, sin nada en mente, me pidió que pusiera mi cara
		  en el escáner. Daniel tenía uno de sus programas gráficos
		  (Corel Xara, su favorito) que <quote>autotrazaba</quote> mi
		  cara escaneada. Él lo describe de la siguente manera:
		  <quote>El autotrazado es la manera de la computadora para
		  transformar un dibujo en los tipos de líneas y curvas que
		  realmente le gustan</quote>. Entonces él jugó con ello hasta
		  que obtuvo algo que parecía como un mapa topográfico de mi
		  cara, una imagen que podría ser la manera en que una
		  computadora ve a la gente.
		</para>

		<para>
		  Tomé esta imagen y la fotocopié en papel de acuarela (algunas
		  copiadoras pueden manejar paquetes gruesos), y entonces
		  comenzó a realizar montones de experimentos añadiendo acuarela
		  a la imágen. Seleccionamos las que nos gustaban más, entonces
		  Daniel las volvió a escanear y las organizó en la portada,
		  añadiendo el texto y otros elementos de diseño. El proceso
		  total requirió varios meses, mayormente a causa del tiempo que
		  me tomó hacer las acuarelas. Pero me he divertido
		  especialmente con ello porque conseguí participar en el arte
		  de la portada, y porque me dio un incentivo para hacer más
		  acuarelas (lo que dicen sobre la práctica realmente es
		  cierto).
		</para>

	 </sect1>

	 <sect1>
		<title>Diseño del libro y producción</title>

		<para>
		  El diseño del interior del libro fue creado por Daniel
		  Will-Harris, que solía jugar con letras *****rub-on***** en el
		  instituto mientras esperaba la invención de las computadoras y
		  los entornos de publicación. De todos modos, yo mismo produje
		  las páginas de fotos *****camera-ready*****, por lo que los
		  errores tipográficos son míos. Se utilizó Microsoft
		  *****Simbolillo del copyright!!****** Word para Windows
		  Versiones 8 y 9 para escribir el libro y crear las páginas
		  *****camera-ready*****, incluyendo la generación de la tabla
		  de contenidos y el índice (creé un servidor automatizado COM
		  en Python, llamado desde las macros VBA de Word, para ayudarme
		  en el marcado de los índices). Python (ver <ulink
		  url="http://www.BruceEckel.com">www.python.com</ulink>) se
		  utilizó para crear algunas de las herramientas para comprobar
		  el código, y se habría utilizado como herramienta de
		  extracción de código si lo hubiera descubierto antes.
		</para>

		<para>
		  Creé los diagramas utilizando Visio*****simbolillo del
		  copyright!!***** - Gracias a Visio Corporation por crear una
		  herramienta tan útil.
		</para>

		<para>
		  El tipo de letra del cuerpo es Georgia y los títulos utilizan
		  Verdana. La versión *****camera-ready***** definitiva se creó
		  con Adobe*****simbolillo del copyright!!***** Acrobat 4 y el
		  fichero generado se llevó directamente a la imprenta - muchas
		  gracias a Adobe por crear una herramienta que permite enviar
		  documentos *****camera-ready***** por correo electrónico, así
		  como permitir que se realicen múltiples revisiones en un único
		  día en lugar de recaer sobre mi impresora láser y servicios
		  rápidos 24 horas (probamos el proceso Acrobat por primera vez
		  con <emphasis>Pensar en Java</emphasis>, y fui capaz de subir
		  la versión final de ese libro a la imprenta de U.S. desde Sur
		  África).
		</para>

		<para>
		  La versión HTML se creó exportando el documento Word a RTF, y
		  utilizando entonces RTF2HTML (ver <ulink
		  url="http://www.sunpack.com/RTF/">http://www.sunpack.com/RTF/</ulink>)
		  para hacer la mayor parte del trabajo de la conversión HTML
		  (gracias a Chris Hector por hacer una herramienta tan util y
		  especialmente fiable). Los ficheros resultantes se limpiaron
		  utilizando un programa Python que truqué, y los WMFs se
		  transformaron en GIFs utilizando el PaintShop Pro 6 de
		  JASC*****copyright***** y su herramienta de conversión por
		  lotes (gracias a JASC por resolver tantos de mis problemas con
		  su excelente producto). El realce del color de la sintaxis se
		  añadió con un script Perl amablemente cedido por Zafir Anjum.
		</para>
	 </sect1>


     <sect1>
		<title>Agradecimientos</title>

		<para>
		  Lo primero, agradecer a todo aquel que presentó correcciones y
		  sugerencias desde Internet; han sido de tremenda ayuda para
		  mejorar la calidad de este libro, y no podría haberlo hecho
		  sin ustedes. Gracias en especial a John Cook.
		</para>

		<para>
		  Las ideas y compensión de este libro han llegado de varias
		  fuentes: amigos como Chuck Allison, Andrea Provaglio, Dans
		  Sakx, Scott Meyers, Charles Petzold y Michael Wilk; pioneros
		  del lenguaje como Bjarne Stroustrup, Andrew Koenig y Rob
		  Murray; miembros del Comité de Estándares de C++ como Nathan
		  Myers (que fue de particular ayuda y generosidad con sus
		  percepciones), Bill Plauger, Reg Charney, Tom Penello, Tom
		  Plum, Sam Druker y Uwe Steinmueller; gente que ha hablado de
		  mi camino en C++ en la Conferencia de Desarrollo de Software;
		  y a menudo estudiantes de mis seminarios, que preguntan
		  aquello que necesito oír para aclarar el material.
		</para>

		<para>
		  Enormes agradecimientos para mi amigo Gen Kiyooka, cuya
		  compañía Digigami me proporcionó un servidor web.
		</para>

		<para>
		  Mi amigo Richard Hale Shaw y yo hemos enseñado C++ juntos; las
		  percepciones de Richard y su apoyo han sido muy útiles (y las
		  de Kim también). Gracias también a DoAnn Vikoren, Eric Faurot,
		  Jennifer Jessup, Tara Arrowood, Marco Pardi, Nicole Freeman,
		  Barbara Hanscome, Regina Ridley, Alex Dunne y el resto del
		  reparto y plantilla de MFI.
		</para>
		
		<para>
		  Unos agradecimientos especiales para todos mis profesores y
		  todos mis estudiantes (que son profesores míos también).
		</para>

		<para>
		  Y para mis escritores favoritos, mi profunda apreciación y
		  simpatía por vuestros esfuerzos: John Irving, Neal Stephenson,
		  Robertson Davies (te echaremos de menos), Tom Robbins, William
		  Gibson, Richard Bach, Carlos Castaneda y Gene Wolfe.
		</para>

		<para>
		  A Guido van Rossum, por inventar Python y donarlo desinteresadamente
		  al mundo. Has enriquecido mi vida con tu contribución.
		</para>

		<para>
		  Gracias a la gente de Prentice Hall: Alan Apt, Ana Terry,
		  Scott Disanno, Toni Holm y mi editora de copias electrónicas
		  Stephanie English. En márqueting, Bryan Gambrel y Jennie
		  Burger.
		</para>

		<para>
		  Sonda Donovan me ayudó con la producción del CD Rom. Daniel
		  Will-Harris (de acuerdo) creó el diseño de la portada
		  *****silkscreen***** que se encuentra en el propio CD.
		</para>

       <para>
		  Para todos los grandes amigos de Crested Butte, gracias por
		  hacer de él un lugar mágico, especialmente Al Smith (creador
		  del maravilloso Camp4 Coffee Garden), mis vecinos Dave &amp;
		  Erika, Marsha de la librería Heg's Place, Pat &amp; John de
		  Teocalli Temale, Sam de Barkery Café, y a Tiller por su ayuda
		  con la investigación en audio. Y a toda la gente terrorífica
		  que cuelga de Camp4 y hace interesantes mis mañanas.
		</para>


<!-- FIXME: "ALMQUISTS" --> "alquimistas" ?? -->
		<para>
		  La plantilla de apoyo de amigos incluye, pero no está limitada
		  a, Zack Urlocker, Andrew Binstock, Neil Rubenking, Kraig
		  Brocschmidt, Steve Sinofsky, JD Hildebrandt, Brian McElhinney,
		  Brinkey Barr, Larry O'Brien, Bill Gates en Midnight
		  Engineering Magazine, Larry Constantine, Lucy Lockwood, Tom
		  Keffer, Dan Putterman, Gene Wang, Dave Mayer, David
		  Intersimone, Claire Sawyers, los Italianos (Andrea Provaglio,
		  Rossella Gioia, Laura Fallai, Marco &amp; Lella Cantu, Corrado,
		  Ilsa y Christina Giustozzi), Chris y laura Strand (y Parker),
		  los Alquimistas*****almquists*****, Brad Jerbic, Marilyn Cvitanic, el
		  Mabrys, el Halflingers, los Pollocks, Peter Vinci, los
		  Robbins, los Moelters, Dave Stoner, Laurie Adams, los
		  Cranstons, Larry Fogg, Mike y karen Sequeira, Gary Entsminger
		  y Allison Brody, Kevin, Sonda &amp; Ella Donovan, Chester y
		  Shannon Andersen, Joe Lordi, Dave y Brenda Barlett, los
		  Rentschlers, Lynn y Todd y sus familias. Y por supuesto, a Mamá
		  y Papá.
		</para>

	 </sect1>
  </preface>


<!-- Local Variables: -->
<!-- sgml-parent-document:"PensarEnC++.sgml" -->
  <!-- End: -->