<?xml  version="1.0" encoding="iso-8859-1"?>
<!-- -*- sgml -*- -->
<!--
  Editor:              Emacs 21/PSGML
  Traducción original: jesus lopez mollo <i302154@correo.unnet.es>
                       (anterior a LuCaS)
  Formateado DocBook:  Miguel Ángel García Martínez
  1ª Revisión:
  2ª Revisión
-->

<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
                 "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">

<chapter 
  xmlns:xi="http://www.w3.org/2001/XInclude"
  id="C16">


  <title>Introducción a las Plantillas</title>


  <para>
    La herencia y la composición proporcionan una forma de reusar código
    objeto.  La característica de las plantillas de C++ proporcionan una
    manera de reusar el código <emphasis>fuente</emphasis>.
  </para>

<para>
Aunque las plantillas (o templates) son una herramienta de
programación de propósito general, cuando fueron introducidos en el
lenguaje, parecían oponerse al uso de las jerarquías de clases
contenedoras basadas en objetos (demostrado al final del Capítulo
15). Además, los contenedores y algoritmos del C++ Standard
(explicados en dos capítulos del Volumen 2 de este libro, que se puede
bajar de <ulink
url="http://www.bruceeckel.com">www.BruceEckel.com</ulink>) están
construidos exclusivamente con plantillas y son relativamente fáciles
de usar por el programador.
</para>

<para>
Este capítulo no sólo muestra los fundamentos de los templates,
también es una introducción a los contenedores, que son componentes
fundamentales de la programación orientada a objetos lo cual se
evidencia a través de los contenedores de la librería estándar de
C++. Se verá que este libro ha estado usando ejemplos contenedores -
<classname>Stash</classname> y <classname>Stack</classname>- para
hacer más sencillo el concepto de los contenedores; en este capítulo
se sumará el concepto del <classname>iterator</classname>. Aunque los
contenedores son el ejemplo ideal para usarlos con las plantillas, en
el Volumen 2 (que tiene un capítulo con plantillas avanzadas) se
aprenderá que también hay otros usos para los templates.
</para>


  <sect1>
	 <title>Contenedores</title>

	 
	 <para>
		Supóngase que se quiere crear una pila, como se ha estado
		haciendo a través de este libro. Para hacerlo sencillo, esta
		clase manejará enteros.
	 </para>

	 <para>
		<programlisting>
		  <xi:include parse="text" href="./code/C16/IntStack.cpp"/>
		</programlisting>
	 </para>

	 <para>
		La clase <classname>IntStack</classname> es un ejemplo trivial
		de una pila. Para mantener la simplicidad ha sido creada con un
		tamaño fijo, pero se podría modificar para que automáticamente
		se expanda usando la memoria del montón, como en la clase
		<classname>Stack</classname> que ha sido examinada a través del
		libro.
	 </para>

	 <para>
		<function>main()</function> añade algunos enteros a la pila, y
		posteriormente los extrae.  Para hacer el ejemplo más
		interesante, los enteros son creados con la función
		<function>fibonacci()</function>, que genera los tradicionales
		números de la reproducción del conejo. Aquí está el archivo de
		cabecera que declara la función:
	 </para>

	 <para>
		<programlisting>
		  <xi:include parse="text" href="./code/C16/fibonacci.h"/>
		</programlisting>
	 </para>

	 <para>
		Aquí está la implementación:
	 </para>

	 <para>
		<programlisting>
		  <xi:include parse="text" href="./code/C16/fibonacci.cpp"/>
		</programlisting>
	 </para>

	 <para>
		Esta es una implementación bastante eficiente, porque nunca se
		generan los números más de una vez. Se usa un array <literal
		role="keyword">static</literal> de <type>int</type>, y se basa
		en el hecho de que el compilador inicializará el array estático
		a cero.  El primer bucle <literal role="keyword">for</literal>
		mueve el índice <varname>i</varname> a la primera posición del
		array que sea cero, entonces un bucle <literal
		role="keyword">while</literal> añade números Fibonacci al array
		hasta que se alcance el elemento deseado. Hay que hacer notar
		que si los números Fibonacci hasta el elemento
		<varname>n</varname> ya están inicializados, entonces también se
		salta el bucle <literal role="keyword">while</literal>.
	 </para>


	 <sect2>
		<title>La necesidad de los contenedores</title>

		<para>
		  Obviamente, una pila de enteros no es una herramienta
		  crucial. La necesidad real de los contenedores viene cuando se
		  empizan a crear objetos en el montón (heap) usando <literal
		  role="keyword">new</literal> y se destruyen con <literal
		  role="keyword">delete</literal>. En un problema general de
		  programación no se saben cuantos objetos van a ser necesarios
		  cuando se está escribiendo el programa. Por ejemplo, en un
		  sistema de control de tráfico aéreo no se quiere limitar el
		  número de aviones que el sistema pueda gestionar. No puede ser
		  que el programa se aborte sólo porque se excede algún
		  número. En un sistema de diseño asistido por computadora, se
		  están manejando montones de formas, pero únicamente el usuario
		  determina (en tiempo de ejecución) cuantas formas serán
		  necesarias. Una vez apreciemos estas tendencias, se
		  descubrirán montones de ejemplos en otras situaciones de
		  programación.
		</para>

		<para>
		  Los programadores de C que dependen de la memoria virtual para
		  manejar su "gestión de memoria" encuentran a menudo como
		  perturbantentes las ideas del <literal
		  role="keyword">new</literal>, <literal
		  role="keyword">delete</literal> y de los contenedores de
		  clases. Aparentemente, una práctica en C es crear un enorme
		  array global, más grande que cualquier cosa que el programa
		  parezca necesitar. Para esto no es necesario pensar demasiado
		  (o hay que meterse en el uso de <function>malloc()</function>
		  y <function>free()</function>), pero se producen programas que
		  no se pueden portar bien y que esconden sutiles errores.
		</para>

		<para>
		  Además, si se crea un enorme array global de objetos en C++,
		  la sobrecarga de los constructores y de los destructores
		  pueden enlentecer las cosas de forma significativa. La
		  aproximación de C++ funciona mucho mejor: Cuando se necesite
		  un objeto, se crea con <literal role="keyword">new</literal>,
		  y se pone su puntero en un contenedor. Más tarde, se saca y se
		  hace algo con él. De esta forma, sólo se crean los objetos
		  cuando sea necesario. Y normalmente no se dan todas las
		  condiciones para la inicialización al principio del
		  programa. <literal role="keyword">new</literal> permite
		  esperar hasta que suceda algo en el entorno para poder crear
		  el objeto.
		</para>

		<para>
		  Así, en la situación más común, se creará un contenedor que
		  almacene los punteros de algunos objetos de interés. Se
		  crearán esos objetos usando <literal
		  role="keyword">new</literal> y se pondrá el puntero resultante
		  en el contenedor (potencialmete haciendo upcasting en el
		  proceso), más tarde el objeto se puede recuperar cuando sea
		  necesario.  Esta técnica produce el tipo de programas más
		  flexible y general.
		</para>
		
	 </sect2>
  </sect1>
  <sect1>
	 <title>Un vistazo a los templates</title>

	 <para>
		Ahora surge un nuevo problema. Tenemos un
		<classname>IntStack</classname>, que maneja enteros. Pero
		queremos una pila que maneje formas, o flotas de aviones, o
		plantas o cualquier otra cosa.  Reinventar el código fuente cada
		vez no parece una aproximación muy inteligente con un lenguaje
		que propugna la reusabilidad. Debe haber un camino mejor.
	 </para>

	 <para>
		Hay tres técnicas para reusar código en esta situación: el modo
		de C, presentado aquí como contraste; la aproximación de
		Smalltalk, que afectó de forma significativa a C++, y la
		aproximación de C++: los templates.
	 </para>

	 <!-- FIXME: Esto es una enumeración de las técnicas con una pequeña
	 explicación, pero no sé cómo ponerlo en  docbook -->
	 <para>
		<emphasis>La solución de C</emphasis>. Por supuesto hay que
		escapar de la aproximación de C porque es desordenada y provoca
		errores, al mismo tiempo que no es nada elegante. En esta
		aproximación, se copia el código de una <classname>Stack
		</classname> y se hacen modificaciones a mano, introduciendo
		nuevos errores en el proceso. Esta no es una técnica muy
		productiva.
	 </para>
	 

<!-- FIXME: referencia -->
	 <para>
		<emphasis>La solución de Smalltalk</emphasis>. Smalltalk (y Java
		siguiendo su ejemplo) optó por una solución simple y directa: Se
		quiere reusar código, pues utilicese la herencia. Para
		implementarlo, cada clase contenedora maneja elementos de una
		clase base genérica llamada <classname>Object </classname> (similar
		al ejemplo del final del capítulo 15). Pero debido a que la
		librería de Smalltalk es fundamental, no se puede crear una
		clase desde la nada. En su lugar, siempre hay que heredar de una
		clase existente. Se encuentra una clase lo más cercana posible a
		lo que se desea, se hereda de ella, y se hacen un par de
		cambios. Obviamente, esto es un beneficio porque minimiza el
		trabajo (y explica porque se pierde un montón de tiempo
		aprendiendo la librería antes de ser un programador efectivo en
		Smalltalk).
	 </para>
	 
	 <para>
		Pero también significa que todas las clases de Smalltalk acaban
		siendo parte de un único árbol de herencia. Hay que heredar de
		una rama de este árbol cuando se está creando una nueva
		clase. La mayoría del árbol ya esta allí (es la librería de
		clases de Smalltalk), y la raiz del árbol es una clase llamada
		<classname>Object</classname> - la misma clase que los contenedores
		de Smalltalk manejan.
	 </para>



	 <para>
		Es un truco ingenioso porque significa que cada clase en la
		jerarquía de herencia de Smalltalk (y Java<footnote> <para>Con
		la excepción, en Java, de los tipos de datos primitivos, que se
		hicieron no <classname>Object</classname>s por eficiencia. </para>
		</footnote>) se deriva de <classname>Object</classname>, por lo
		que cualquier clase puede ser almacenada en cualquier contenedor
		(incluyendo a los propios contenedores). Este tipo de jerarquía
		de árbol única basada en un tipo genérico fundamental (a menudo
		llamado <classname>Object</classname>, como también es el caso
		en Java) es conocido como "jerarquía basada en objectos". Se
		puede haber oido este témino y asumido que es un nuevo concepto
		fundamental de la POO, como el polimorfismo. Sin embargo,
		simplemente se refiere a la raíz de la jerarquía como
		<classname>Object </classname> (o algún témino similar) y a
		contenedores que almacenan <classname>Object</classname>s.
	 </para>

	 <para>
		Debido a que la librería de clases de Smalltalk tenía mucha más
		experiencia e historia detrás de la que tenía C++, y porque los
		compiladores de C++ originales no tenían librerías de clases
		contenedoras, parecía una buena idea duplicar la librería de
		Smalltalk en C++. Esto se hizo como experimento con una de las
		primeras implementaciónes de C++<footnote> <para>La librería
		OOPS, por Keith Gorlen, mientras estaba en el NIH.</para>
		</footnote>, y como representaba un significativo ahorro de
		código mucha gente empezo a usarlo. En el proceso de intentar
		usar las clases contenedoras, descubrieron un problema.
	 </para>

	 <para>
		El problema es que en Smalltalk (y en la mayoría de los
		lenguajes de POO que yo conozco), todas las clases derivan
		automáticamente de la jerarquía única, pero esto no es cierto en
		C++. Se puede tener una magnifica jerarquía basada en objetos
		con sus clases contenedoras, pero entonces se compra un conjunto
		de clases de figuras, o de aviones de otro vendedor que no usa
		esa jerarquía. (Esto se debe a que usar una jerarquía supone
		sobrecarga, rechazada por los programadores de C). ¿Cómo se
		inserta un árbol de clases independientes en nuestra jerarquía?
		El problema se parece a lo siguiente:
	 </para>
<!--
<imagen origen="imagenes\plantilla1.bmp" alineacion="center">
</imagen>
-->
	 <para>
		Debido a que C++ suporta múltiples jerarquías independientes, la
		jerarquía basada en objetos de Smalltalk no funciona tan bien.
	 </para>

	 <para>
		La solución parace obvia. Si se pueden tener múltiples
		jerarquías de herencia, entonces hay que ser capaces de heredar
		de más de una clase: La herencia múltiple resuelve el
		problema. Por lo que se puede hacer lo siguiente (un ejemplo
		similar se dió al final del Capítulo 15).
	 </para>

<!--
<imagen origen="imagenes\plantilla2.bmp" alineacion="center">
</imagen>
-->

	 <para>
		Ahora <classname>OShape</classname> tiene las características y
		el comportamiento de <classname>Shape</classname>, pero como
		también está derivado de <classname>Object</classname> puede ser
		insertado en el contenedor. La herencia extra dada a
		<classname>OCircle</classname>, <classname>OSquare</classname>,
		etc. es necesaria para que esas clases puedan hacer upcast hacia
		<classname>OShape </classname> y puedan mantener el
		comportamiento correcto. Se puede ver como las cosas se están
		volviendo confusas rápidamente.
	 </para>

	 <para>
		Los vendedores de compiladores inventaron e incluyeron sus
		propias jerarquías y clases contenedoras, muchas de las cuales
		han sido reemplazadas desde entonces por versiones de templates.
		Se puede argumentar que la herencia múltiple es necesaria para
		resolver problemas de programación general, pero como se verá en
		el Volumen 2 de este libro es mejor evitar esta complejidad
		excepto en casos especiales.
	 </para>

	 <sect2>
		<title>La solución de los Templates</title>

		<para>
		  Aunque una jerarquía basada en objetos con herencia múltiple
		  es conceptualmente correcta, se vuelve difícil de usar. En su
		  libro<footnote> <para><emphasis>The C++ Programming
		  Language</emphasis> by Bjarne Stroustrup (1ª edición,
		  Addison-Wesley, 1986)</para> </footnote>, Stroustrup demostró
		  lo que el consideraba una alternativa preferible a la
		  jerarquía basada en objetos.  Clases contenedoras que fueran
		  creadas como grandes macros del preprocesador con argumentos
		  que pudieran ser sustituidos con el tipo deseado. Cuando se
		  quiera crear un contenedor que maneje un tipo en concreto, se
		  hacen un par de llamadas a macros.
		</para>

		<para>
		  Desafortunadamente, esta aproximación era confusa para toda la
		  literatura existente de Smalltalk y para la experiencia de
		  programación, y era un poco inmanejable.  Básicamente, nadie
		  la entendía.
		</para>

		<para>
		  Mientras tanto, Stroustrup y el equipo de C++ de los
		  Laboratorios Bell habían modificado su aproximación de las
		  macros, simplificándola y moviéndola del dominio del
		  preprocesador al compilador. Este nuevo dispositivo de
		  sustitución de código se conoce como <literal
		  role="keyword">template</literal><footnote> <para>La
		  inspiración de los templates parece venir de los <literal
		  role="keyword">generics</literal> de ADA</para> </footnote>
		  (plantilla), y representa un modo completamente diferente de
		  reusar el código. En vez de reusar código objeto, como en la
		  herencia y en la composición, un template reusa
		  <emphasis>código fuente</emphasis>. El contenedor no maneja
		  una clase base genérica llamada <classname>Object</classname>,
		  si no que gestiona un parámetro no especificado. Cuando se usa
		  un template, el parámetro es sustituido <emphasis>por el
		  compilador</emphasis>, parecido a la antigua aproximación de
		  las macros, pero más claro y fácil de usar.
		</para>

		<para>
		  Ahora, en vez de preocuparse por la herencia o la composición
		  cuando se quiera usar una clase contenedora, se usa la versión
		  en plantilla del contenedor y se crea una versión específica
		  para el problema, como lo siguiente:
		</para>

<!-- FIXME: Imagen
<imagen origen="imagenes\plantilla3.bmp" alineacion="center">
</imagen>
-->

		<para>
		  El compilador hace el trabajo por nosotros, y se obtiene el
		  contenedor necesario para hacer el trabajo, en vez de una
		  jerarquía de herencia inmanejable. En C++, el template
		  implementa el concepto de <emphasis>tipo
		  parametrizado</emphasis>. Otro beneficio de la aproximación de
		  las plantillas es que el programador novato que no tenga
		  familiaridad o esté incómodo con la herencia puede usar las
		  clases contenedoras de manera adecuada (como se ha estado
		  haciendo a lo largo del libro con el
		  <classname>vector</classname>).

		</para>

	 </sect2>
  </sect1>


  <sect1>
	 <title>Sintaxis del Template</title>

	 <para>
		La palabra reservada <literal role="keyword">template</literal>
		le dice al compilador que la definición de clases que sigue
		manipulará uno o más tipos no especificados. En el momento en
		que el código de la clase actual es generado, los tipos deben
		ser especificados para que el compilador pueda sustituirlos.
	 </para>
	 
	 <para>
		Para demostrar la sintaxis, aquí está un pequeño ejemplo que
		produce un array con límites comprobados:
	 </para>

	 <para>
		<programlisting>
		  <xi:include parse="text" href="./code/C16/Array.cpp"/>
		</programlisting>
	 </para>

	 <para>
		Se puede ver que parece una clase normal excepto por la línea.
	 </para>

	 <programlisting><ret></ret>
<reserv>template</reserv>&lt;<reserv>class</reserv> T&gt;<ret></ret>
	 </programlisting>

	 <para>
		que indica que <parameter>T</parameter> es un parámetro de
		sustitución, y que representa un nombre de un tipo. Además, se
		puede ver que <parameter>T</parameter> es usado en todas las
		partes de la clase donde normalmente se vería al tipo específico
		que el contenedor gestiona.
	 </para>

	 <para>
		En <classname>Array</classname> los elementos son insertados y
		extraidos con la misma función: el operador sobrecargado
		<literal role="operator">operator[]</literal>. Devuelve una
		referencia, por lo que puede ser usado en ambos lados del signo
		igual (es decir, tanto como <literal>lvalue</literal> como
		<literal>rvalue</literal>). Hay que hacer notar que si el índice
		se sale de los límites se usa la función <function>require()
		</function> para mostrar un mensaje. Como <literal
		role="operator">operator[] </literal> es <literal
		role="keyword">inline</literal>, se puede usar esta aproximación
		para garantizar que no se producen violaciones del límite del
		array para entonces eliminar el <function>require()</function>.
	 </para>

	 <para>
		En el <function>main()</function>, se puede ver lo fácil que es
		crear <classname>Array</classname>s que manejen distintos tipos de
		objetos. Cuando se dice:
	 </para>

	 <programlisting><ret></ret>
Array&lt;<reserv>int</reserv>&gt; ia;<ret></ret>
Array&lt;<reserv>float</reserv>&gt; fa;<ret></ret>
	 </programlisting>

	 <para>
		el compilador expande dos veces la plantilla del
		<classname>Array </classname> (que se conoce como <literal
		role="keyword">instantiation </literal> o crear una instancia),
		para crear dos nuevas <emphasis>clases generadas</emphasis>, las
		cuales pueden ser interpretadas como <classname>Array_int
		</classname> y <classname>Array_float</classname>. Diferentes
		compiladores pueden crear los nombres de diferentes
		maneras. Estas clases son idénticas a las que hubieran producido
		de estar hechas a mano, excepto que el compilador las crea por
		nosotros cuando se definen los objetos <varname>ia </varname> y
		<varname>fa</varname>. También hay que notar que las
		definiciones de clases duplicadas son eludidas por el
		compilador.
	 </para>


	 <sect2>
		<title>Definiciones de función no inline</title>

		<para>
		  Por supuesto, hay veces en las que se querrá tener definición
		  de funciones no inline. En ese caso, el compilador necesita
		  ver la declaración del <literal role="keyword">template</literal> antes que
		  la definición de la función miembro.  Aquí está el ejemplo
		  anterior, modificado para mostrar la definición del miembro no
		  inline.
		</para>


		<para>
		  <programlisting>
			 <xi:include parse="text" href="./code/C16/Array2.cpp"/>
		  </programlisting>
		</para>
		
		<para>
		  Cualquier referencia al nombre de una plantilla de clase debe
		  estar acompañado por la lista de argumentos del template, como
		  en
		  <programlisting>Array&lt;T&gt;operator[]</programlisting>. Se
		  puede imaginar que internamente, el nombre de la clase se
		  rellena con los argumentos de la lista de argumentos de la
		  plantilla para producir un nombre identificador único de la
		  clase for cada instanciación de la plantilla.
		</para>

		<sect3>
		  <title>Archivos cabecera</title>

		  <para>
			 Incluso si se crean definiciones de funciones no inline,
			 normalmente se querrá poner todas las declaraciones y
			 definiciones de un template en un archivo cabecera. Esto
			 parece violar la regla usual de los archivos cabecera de
			 <quote>No poner nada que asigne almacenamiento</quote>, (lo
			 cual previene múltiples errores de definición en tiempo de
			 enlace), pero las definiciones de plantillas son
			 especial. Algo precedido por
			 <programlisting>template&lt;...&gt; </programlisting>
			 significa que el compilador no asignará almacenamiento en
			 ese momento, sino que se esperará hasta que se lo indiquen
			 (en la instanciación de una plantilla), y que en algún lugar
			 del compilador y del enlazador hay un mecanismo para
			 eliminar las múltiples definiciones de una plantilla
			 idéntica.  Por lo tanto casi siempre se pondrá toda la
			 declaración y definición de la plantilla en el archivo
			 cabecera por facilidad de uso.
		  </para>

		  <para>
			 Hay veces en las que puede ser necesario poner las
			 definiciones de la plantilla en un archivo <filename
			 role="extension">cpp </filename> separado para satisfacer
			 necesidades especiales (por ejemplo, forzar las
			 instanciaciones de las plantillas para que se encuentren en
			 un único archivo <filename role="extension">dll </filename>
			 de Windows). La mayoría de los compiladores tienen algún
			 mecanismo para permitir esto; hay que investigar la
			 documentación del compilador concreto para usarlo.
		  </para>

		  <para>
			 Algunas personas sienten que poner el código fuente de la
			 implementación en un archivo cabecera hace posible que se
			 pueda robar y modificar el código si se compra la
			 librería. Esto puede ser una característica, pero
			 probablemente dependa del modo de mirar el problema: ¿Se
			 está comprando un producto o un servicio? Si es un producto,
			 entonces hay que hacer todo lo posible por protegerlo, y
			 probablemente no se quiera dar el código fuente, sino sólo
			 el código compilado. Pero mucha gente ve el software como un
			 servicio, incluso más, como un servicio por suscripción. El
			 cliente quiere nuestra pericia, quieren que se mantenga ese
			 fragmento de código reusable para no tenerlo que hacer él -
			 para que se pueda enfocar en hacer su propio trabajo.
			 Personalmente creo que la mayoría de los clientes le
			 tratarán como una fuente de recursos a tener en cuenta y no
			 querrán poner en peligro su relación con usted.  Y para los
			 pocos que quieran robar en vez de comprar o hacer el trabajo
			 original, de todas formas probablemante tampoco se
			 mantendrían con usted.
		  </para>
		</sect3>
	 </sect2>

	 <sect2>
		<title>IntStack como plantilla</title>

		<para>
		  Aquí está el contenedor y el iterador de
		  <filename>IntStack.cpp</filename>, implementado como una clase
		  contenedora genérica usando plantillas:
		</para>

		<para>
		  <programlisting>
			 <xi:include parse="text" href="./code/C16/StackTemplate.h"/>
		  </programlisting>
		</para>

		<para>
		  Hay que darse cuenta que esta plantilla asume ciertas
		  características de los objetos que está manejando. Por
		  ejemplo, <classname>StackTemplate </classname> asume que hay
		  alguna clase de operación de asignación a <parameter>T
		  </parameter> dentro de la función
		  <function>push()</function>. Se puede decir que una plantilla
		  <quote>implica una interfaz</quote> para los tipos que es
		  capaz de manejar.
		</para>

		<para>
		  Otra forma de decir esto es que las plantillas proporcionan
		  una clase de mecanismo de <emphasis>tipado débil</emphasis> en
		  C++, lo cual es típico en un lenguaje fuertemente tipado. En
		  vez de insistir en que un objeto sea del mismo tipo para que
		  sea aceptable, el tipado débil requiere únicamente que la
		  función miembro a la que se quiere llamar esté
		  <emphasis>disponible</emphasis> para un objeto en
		  particular. Es decir, el código débilmente tipado puede ser
		  aplicado a cualquier objeto que acepte esas llamadas a
		  funciones miembro, lo que lo hace mucho más flexible<footnote>
		  <para>Todos los métodos en Smalltalk y Python están débilmente
		  tipados, y ese es el motivo por lo que estos lenguajes no
		  necesitan el mecanismo de los templates.  En efecto, se
		  consiguen plantillas sin templates.</para>
		  </footnote>.
		</para>

		<para>
		  Aquí tenemos el objeto revisado para comprobar la plantilla:
		</para>


		<para>
		  <programlisting>
			 <xi:include parse="text" href="./code/C16/StackTemplate.cpp"/>
		  </programlisting>
		</para>

		<para>
		  La única diferencia está en la creación de
		  <varname>is</varname>. Dentro de la lista de argumentos del
		  template hay que especificar el tipo de objeto que la pila y
		  el iterador deberán manejar. Para demostrar la genericidad de
		  la plantilla, se crea un <classname>StackTemplate </classname>
		  para manejar <type>string</type>. El ejemplo lee las líneas
		  del archivo con el código fuente.
		</para>

	 </sect2>

	 <sect2>
		<title>Constantes en los Templates</title>

		<para>
		  Los argumentos de los templates no restrigen su uso a tipos
		  class; se pueden también usar tipos empotrados. Los valores de
		  estos argumentos se convierten en constantes en tiempo de
		  compilación para una instanciación en particular de la
		  plantilla. Se pueden usar incluso valores por defecto para
		  esos argumentos. El siguiente ejemplo nos permite indicar el
		  tamaño de la clase <classname>Array </classname> durante la
		  instanciación, pero también proporciona un valor por defecto:
		</para>

		<para>
		  <programlisting>
			 <xi:include parse="text" href="./code/C16/Array3.cpp"/>
		  </programlisting>
		</para>

		<para>
		  Como antes, <classname>Array </classname> es un array de
		  objetos que previene de rebasar los límites.  La clase
		  <classname>Holder </classname> es muy parecida a
		  <classname>Array </classname> excepto que tiene un puntero a
		  <classname>Array </classname> en vez de un tener incrustrado
		  un objeto del tipo <classname>Array</classname>. Este puntero
		  no se inicializa en el constructor; la inicialización es
		  retrasada hasta el primer acceso. Esto se conoce como
		  <emphasis>inicialización perezosa</emphasis>; se puede usar
		  una técnica como esta si se están creando un montón de
		  objetos, pero no se está accediendo a todos ellos y se quiere
		  ahorrar almacenamiento.
		</para>

		<para>
		  Hay que resaltar que nunca se almacena internamente el valor
		  de <varname>size</varname> en la clase, pero se usa como si
		  fuera un dato interno dentro de las funciones miembro.
		</para>

	 </sect2>
  </sect1>
  <sect1>
	 <title>Stack y Stash como Plantillas</title>

	 <para>
		Los problemas recurrentes de <quote>propiedad</quote> con las
		clases contenedoras <classname>Stack</classname> y
		<classname>Stash </classname> (Pila y Cola respectivamente) que
		han sido usadas varias veces a través del libro, vienen del
		hecho de que estos contenedores no son capaces de saber
		exactamente que tipo manejan. Lo más cerca que han estado es en
		el <quote>contenedor</quote> de objectos <classname>Stack
		</classname> que se vio al final del capítulo 15 en
		<filename>OStackTest.cpp</filename>.
	 </para>

	 <para>
		Si el programador cliente no elimina explícitamente todos los
		punteros a objeto que están almacenados en el contenedor,
		entonces el contenedor debería ser capaz de eliminar esos
		punteros de manera adecuada. Es decir, el contenedor
		<quote>posee</quote> cualquiera de los objetos que no hayan sido
		eliminados, y es el responsable de limpiarlos. La dificultad
		radica en que el limpiado requiere conocer el tipo del objeto, y
		crear un contenedor genérico <emphasis>no </emphasis> requiere
		conocer el tipo de ese objeto. Con los templates, sin embargo,
		podemos escribir código que no conozcan el tipo de objeto, y
		fácilmente instanciar una nueva versión del contenedor por cada
		tipo que queramos que contenga. La instancia contenedora
		individual <emphasis>conoce </emphasis> el tipo de objetos que
		maneja y puede por tanto llamar al destructor correcto
		(asumiendo que se haya proporcionado un destructor virtual).
	 </para>

	 <para>
		Para la pila es bastante sencillo debido a todas las funciones
		miembro pueden ser introducidas en línea:
	 </para>

	 <para>
		<programlisting>
		  <xi:include parse="text" href="./code/C16/TStack.h"/>
		</programlisting>
	 </para>

	 <para>
		Si se compara esto al ejemplo de <filename>OStack.h </filename> al
		final del capítulo 15, se verá que <classname>Stack </classname> es
		virtualmente idéntica, excepto que <classname>Object </classname> ha
		sido reemplazado con <parameter>T</parameter>. El programa de prueba
		también es casi idéntico, excepto por la necesidad de múltiple
		herencia de <type>string </type> y <classname>Object
		</classname> (incluso por la necesidad de <classname>Object
		</classname> en sí mismo) que ha sido eliminada. Ahora no tenemos
		una clase <classname>MyString </classname> para anunciar su
		destrucción por lo que añadimos una pequeña clase nueva para
		mostrar como la clase contenedora <classname>Stack </classname>
		limpia sus objetos:
	 </para>

	 <para>
		<programlisting>
		  <xi:include parse="text" href="./code/C16/TStackTest.cpp"/>
		</programlisting>
	 </para>

	 <para>
		El destructor de <classname>X </classname> es virtual, no porque se
		sea necesario aquí, sino porque <varname>xx</varname> podría
		ser usado más tarde para manejar objetos derivados de
		<classname>X</classname>.
	 </para>

	 <para>
		Note lo fácil que es crear diferentes clases de
		<classname>Stack</classname>s para <type>string</type> y para
		<classname>X</classname>. Debido a la plantilla, se consigue lo
		mejor de los dos mundos: la facilidad de uso de la
		<classname>Stack </classname> junto con un limpiado correcto.
	 </para>

	 <sect2>
		<title>Cola de punteros mediante plantillas</title>

		<para>
		  Reorganizar el código de <classname>PStash </classname> en un
		  template no es tan simple porque hay un número de funciones
		  miembro que no deben estar en línea. Sin embargo, como buena
		  plantilla aquellas definiciones de función deben permanecer en
		  el archivo cabecera (el compilador y el enlazador se
		  preocuparán por los problemas de múltiples definiciones). El
		  código parece bastante similar al <classname>PStash
		  </classname> ordinario excepto que el tamaño del incremento
		  (usado por <function>inflate()</function>) ha sido puesto en
		  el template como un parámetro no de clase con un valor por
		  defecto, para que el tamaño de incremento pueda ser modificado
		  en el momento de la instanciación (esto significa que el
		  tamaño es fijo aunque se podría argumentar que el tamaño de
		  incremento debería ser cambiable a lo largo de la vida del
		  objeto):
		</para>

		<para>
		  <programlisting>
			 <xi:include parse="text" href="./code/C16/TPStash.h"/>
		  </programlisting>
		</para>

		<para>
		  El tamaño del incremento por defecto es muy pequeño para
		  garantizar que se produzca la llamada a
		  <function>inflate()</function>. Esto nos asegura que funcione
		  correctamente.
		</para>
		
		<para>
		  Para comprobar el control de propiedad de <classname>PStack
		  </classname> en template, la siguiente clase muestra informes
		  de creación y destrucción de elementos, y también garantiza
		  que todos los objetos que hayan sido creados sean destruidos.
		  <classname>AutoCounter </classname> permitirá crear objetos en
		  la pila sólo a los objetos de su tipo:
		</para>

		<para>
		  <programlisting>
			 <xi:include parse="text" href="./code/C16/AutoCounter.h"/>
		  </programlisting>
		</para>

		<para>
		  La clase <classname>AutoCounter </classname> hace dos
		  cosas. Primero, numera cada instancia de <classname>AutoCounter
		  </classname> de forma secuencial: el valor de este número se
		  guarda en <varname>id</varname>, y el número se genera usando
		  el dato miembro <varname>count </varname> que es
		  <literal role="keyword">static</literal>.
		</para>

		<para>
		  Segundo, y más complejo, una instancia estática (llamada
		  <varname>verifier</varname>) de la clase
		  <classname>CleanupCheck </classname> se mantiene al tanto de
		  todos los objetos <classname>AutoCounter </classname> que son
		  creados y destruidos, y nos informa si no se han limpiado
		  todos (por ejemplo si existe un agujero en memoria). Este
		  comportamiento se completa con el uso de la clase
		  <classname>set</classname> de la Librería Estándar de C++, lo
		  cual es un magnífico ejemplo de cómo las plantillas bien
		  diseñadas nos pueden hacer la vida más fácil (se podrá
		  aprender más de los contenedores en el Volumen 2 de este
		  libro).
		</para>

		<para>
		  La clase <classname>set </classname> está instanciada para el tipo
		  que maneja; aquí hay una instancia que maneja punteros a
		  <classname>AutoCounter</classname>. Un <classname>set </classname>
		  permite que se inserte sólo una instancia de cada objeto; en
		  <function>add() </function> se puede ver que esto sucede con la
		  función <function>set::insert()</function>.  <function>insert()
		  </function> nos informa con su valor de retorno si se está
		  intentando añadir algo que ya se había incluido; sin embargo,
		  desde el momento en que las direcciones a objetos se inserten
		  podemos confiar en C++ para que garantice que todos los
		  objetos tengan direcciones únicas.
		</para>

		<para>
		  En <function>remove()</function>, se usa <function>set::erase()
		  </function> para eliminar un puntero a <classname>AutoCounter
		  </classname> del <classname>set</classname>. El valor de retorno
		  indica cuantas instancias del elemento se han eliminado; en
		  nuestro caso el valor puede ser únicamente uno o cero. Si el
		  valor es cero, sin embargo, significa que el objeto ya había
		  sido borrado del conjunto y que se está intentando borrar por
		  segunda vez, lo cual es un error de programación que debe ser
		  mostrado mediante <function>require()</function>.
		</para>

		<para>
		  El destructor de <classname>CleanupCheck </classname> hace una
		  comprobación final asegurándose de que el tamaño del
		  <classname>set </classname> es cero - Lo que significa que todos
		  los objetos han sido eliminados de manera adecuada. Si no es
		  cero, se tiene un agujero de memoria, lo cual se muestra
		  mediante el <function>require()</function>.
		</para>

		<para>
		  El constructor y el destructor de <classname>AutoCounter
		  </classname> se registra y desregistra con el objeto
		  <varname>verifier</varname>. Hay que resaltar que el
		  constructor, el constructor de copia, y el operador de
		  asignación son <literal role="keyword">private</literal>, por
		  lo que la única forma de crear un objeto es con la función
		  miembro <function>static create() </function> - esto es un
		  ejemplo sencillo de una <literal>factory</literal>, y
		  garantiza que todos los objetos sean creados en el montón
		  (heap), por lo que <varname>verifier</varname> no se verá
		  confundido con sobreasignaciones y construcciones de copia.
		</para>

		<para>
		  Como todas las funciones miembro han sido definidas inline, la
		  única razón para el archivo de implementación es que contenga
		  las definiciones de los datos miembro:
		</para>

		<para>
		  <programlisting>
			 <xi:include parse="text" href="./code/C16/AutoCounter.cpp"/>
		  </programlisting>
		</para>

		<para>
		  Con el <classname>AutoCounter </classname> en la mano, podemos
		  comprobar las facilidades que proporciona el
		  <classname>PStash</classname>. El siguiente ejemplo no sólo
		  muestra que el destructor de <classname>PStash </classname> limpia
		  todos los objetos que posee, sino que también muestra como la
		  clase <classname>AutoCounter </classname> detecta a los objetos
		  que no se han limpiado.
		</para>

		<para>
		  <programlisting>
			 <xi:include parse="text" href="./code/C16/TPStashTest.cpp"/>
		  </programlisting>
		</para>

		<para>
		  Cuando se eliminan los elementos <classname>AutoCounter
		  </classname> 5 y 6 de la <classname>PStash</classname>, se
		  vuelve responsabilidad del que los llama, pero como el cliente
		  nunca los borra se podrín producir agujeros de memoria, que
		  serín detectados por <classname>AutoCounter </classname> en
		  tiempo de ejecución.
		</para>

		<para>
		  Cuando se ejecuta el programa, se verá que el mensaje de error
		  no es tan específico como podría ser. Si se usa el esquema
		  presentado en <classname>AutoCounter </classname> para
		  descubrir agujeros de memoria en nuestro sistema,
		  probablemente se quiera imprimir información más detallada
		  sobre los objetos que no se hayan limpiado. El Volumen 2 de
		  este libro muestra algunas formas más sofisticadas de hacer
		  esto.
		</para>


	 </sect2>
  </sect1>


  <sect1>
	 <title>Activando y desactivando la propiedad</title>

	 <para>
		Volvamos al problema del propietario. Los contenedores que
		manejan objetos por valor normalmente no se preocupan por la
		propiedad porque claramente poseen los objetos que
		contienen. Pero si el contenedor gestiona punteros (lo cual es
		común en C++, especialmente con el polimorfismo), entonces es
		bastante probable que esos punteros sean usados en algún otro
		lado del programa, y no necesariamente se quiere borrar el
		objeto porque los otros punteros del programa estarán
		referenciando a un objeto destruido. Para prevenir que esto
		ocurra, hay que considerar al propietario cuando se está
		diseñando y usando un contenedor.
	 </para>

	 <para>
		Muchos programas son más simples que este, y no se encuentran
		con el problema de la propiedad: Un contenedor que maneja
		punteros a objetos y que son usados sólo por ese contenedor. En
		este caso el propietario es evidente: El contenedor posee sus
		objetos.
	 </para>

	 <para>
		La mejor aproximación para gestionar quién es el propietario es
		dar al programador cliente una elección. Esto se puede realizar
		con un argumento en el constructor que por defecto defina al
		propietario (el caso más sencillo). Además habrá que poner las
		funciones <quote>get</quote> y <quote>set</quote> para poder ver
		y modificar al propietario del contenedor. Si el contenedor
		tiene funciones para eliminar un objeto, el estado de propiedad
		normalmente afecta a la función de eliminación, por lo que se
		deberían encontrar opciones para controlar la destrucción en la
		función de eliminación. Es concebible que se añadan datos
		propietarios por cada elemento que contenga el contenedor, por
		lo que cada posición debería saber cuando es necesario ser
		destruido; esto es una variante del conteo de referencias,
		excepto en que es el contenedor y no el objeto el que conoce el
		número de referencias a un objeto.
	 </para>

	 <para>
		<programlisting>
		  <xi:include parse="text" href="./code/C16/OwnerStack.h"/>
		</programlisting>
	 </para>

	 <para>
		El comportamiento por defecto del contenedor consiste en
		destruir sus objetos pero se puede cambiar o modificando el
		argumento del constructor o usando las funciones miembro de
		<function>owns()</function>.
	 </para>

	 <para>
		Como con la mayoría de las plantillas que se verán, la
		implementación entera se encuentra en el archivo de
		cabecera. Aquí tenemos un pequeño test que muestra las
		capacidades de la propiedad:
	 </para>


	 <para>
		<programlisting>
		  <xi:include parse="text" href="./code/C16/OwnerStackTest.cpp"/>
		</programlisting>
	 </para>

	 <para>
		El objeto <varname>ac2 </varname> no posee los objetos que
		pusimos en él, sin embargo <varname>ac </varname> es un
		contenedor <quote>maestro</quote> que tiene la responsabilidad
		de ser el propietario de los objetos. Si en algún momento de la
		vida de un contenedor se quiere cambiar el que un contenedor
		posea a sus objetos, se puede hacer usando
		<function>owns()</function>.
	 </para>

	 <para>
		También sería posible cambiar la granularidad de la propiedad
		para que estuviera en la base, es decir, objeto por
		objeto. Esto, sin embargo, probablemente haría a la solución del
		problema del propietario más complejo que el propio problema.
	 </para>


  </sect1>
  <sect1>
	 <title>Manejando objetos por valor</title>

	 <para>
		Actualmente crear una copia de los objetos dentro de un
		contenedor genérico sería un problema complejo si no se tuvieran
		plantillas. Con los templates las cosas se vuelven relativamente
		sencillas - sólo hay que indicar que se están manejando objetos
		en vez de punteros:
	 </para>

	 <para>
		<programlisting>
		  <xi:include parse="text" href="./code/C16/ValueStack.h"/>
		</programlisting>
	 </para>

	 <para>
		El constructor de copia de los objetos contenidos hacen la
		mayoría del trabajo pasando y devolviendo objetos por
		valor. Dentro de <function>push()</function>, el almacenamiento
		del objeto en el array <classname>Stack </classname> viene
		acompañado con <function>T::operator=</function>.  Para
		garantizar que funciona, una clase llamada
		<classname>SelfCounter </classname> mantiene una lista de las
		creaciones y construcciones de copia de los objetos.
	 </para>

	 <para>
		<programlisting>
		  <xi:include parse="text" href="./code/C16/SelfCounter.h"/>
		</programlisting>
	 </para>

	 <para>
		<programlisting>
		  <xi:include parse="text" href="./code/C16/SelfCounter.cpp"/>
		</programlisting>
	 </para>

	 <para>
		<programlisting>
		  <xi:include parse="text" href="./code/C16/ValueStackTest.cpp"/>
		</programlisting>
	 </para>

	 <para>
		Cuando se crea un contenedor <classname>Stack</classname>, el
		constructor por defecto del objeto a contener es ejecutado por
		cada objeto en el array. Inicialmente se verán 100 objetos
		<classname>SelfCounter </classname> creados sin ningún motivo
		aparente, pero esto es justamente la inicialización del
		array. Esto puede resultar un poco caro, pero no existe ningún
		problema en un diseño simple como este. Incluso en situaciones
		más complejas si se hace a <classname>Stack </classname> más general
		permitiendo que crezca dinámicamente, porque en la
		implementación mostrada anteriormente esto implicaría crear un
		nuevo array más grande, copiando el anterior al nuevo y
		destruyendo el antiguo array (de hecho, así es como lo hace la
		clase <classname>vector </classname> de la Librería Estándar de
		C++).
	 </para>
  </sect1>


  <sect1>
	 <title>Introducción a los iteradores</title>

	 <para>
		Un <literal>iterator </literal> es un objeto que se mueve a
		través de un contenedor de otros objetos y selecciona a uno de
		ellos cada vez, sin porporcionar un acceso directo a la
		implementación del contenedor. Los iteradores proporcionan una
		forma estándar de acceder a los elementos, sin importar si un
		contenedor proporciona alguna marnera de acceder a los elementos
		directamente.  Se verán a los iteradores usados frecuentemente
		en asociación con clases contenedoras, y los iteradores son un
		concepto fundamental en el diseño y el uso de los contenedores
		del Standard C++, los cuales son descritos en el Volumen 2 de
		este libro (que se puede bajar de <ulink
		url="http://www.bruceeckel.com">www.BruceEckel.com</ulink>. Un
		iterador es también un tipo de <emphasis>patrón de
		diseño</emphasis>, lo cual es materia de un capítulo del Volumen
		2.
	 </para>

	 <para>
		En muchos sentidos, un iterador es un <quote>puntero
		elegante</quote>, y de hecho se verá que los iteradores
		normalmente ocultan la mayoría de las operaciones de los
		punteros. Sin embargo, al contrario que un puntero, el iterador
		es diseñado para ser seguro por lo que es mucho menos probable
		de hacer el equivalente de avanzar atravesando el final de un
		array (o si se hace, se encontrará más fácilmente).
	 </para>

	 <para>
		Considere el primer ejemplo de este capítulo. Aquí está pero
		añadiendo un iterador sencillo:
	 </para>

	 <para>
		<programlisting>
		  <xi:include parse="text" href="./code/C16/IterIntStack.cpp"/>
		</programlisting>
	 </para>

	 <para>
		El <classname>IntStackIter </classname> ha sido creado para
		trabajar solo con un <classname>IntStack</classname>.  Hay que
		resaltar que <classname>IntStackIter </classname> es un <literal
		role="keyword">friend </literal> de
		<classname>IntStack</classname>, lo que lo da un acceso a todos
		los elementos privados de <classname>IntStack</classname>.
	 </para>

	 <para>
		Como un puntero, el trabajo de <classname>IntStackIter
		</classname> consiste en moverse a través de un
		<classname>IntStack </classname> y devolver valores. En este
		sencillo ejemplo, el objeto <classname>IntStackIter </classname>
		se puede mover sólo hacia adelante (usando la forma prefija y
		sufija del <literal role="operator">operador++ </literal>). Sin
		embargo, no hay límites de la forma en que se puede definir un
		iterador a parte de las restricciones impuestas por el
		contenedor con el que trabaje. Esto es totalmente aceptable
		(incluido los límites del contenedor que se encuentre por
		debajo) para un iterador que se mueva de cualquier forma por su
		contenedor asociado y para que se puedan modificar los valores
		del contenedor.
	 </para>

	 <para>
		Es usual el que un iterador sea creado con un constructor que lo
		asocie a un único objeto contenedor, y que ese iterador no pueda
		ser asociado a otro contenedor diferente durante su ciclo de
		vida. (Los iteradores son normalemente pequeños y baratos, por
		lo que se puede crear otro fácilmente).
	 </para>
	 
	 <para>
		Con el iterador, se puede atravesar los elementos de la pila sin
		sacarlos de ella, como un puntero se mueve a través de los
		elementos del array. Sin embargo, el iterador conoce la
		estructura interna de la pila y como atravesar los elementos,
		dando la sensación de que se está moviendo a través de ellos
		como si fuera <quote>incrementar un puntero</quote>, aunque sea
		más complejo lo que pasa por debajo. Esta es la clave del
		iterador: Abstrae el proceso complicado de moverse de un
		elemento del contenedor al siguiente y lo convierte en algo
		parecido a un puntero.  La meta de cada iterador del programa es
		que tengan la misma interfaz para que cualquier código que use
		un iterador no se preocupe de a qué está apuntando - sólo se
		sabe que todos los iteradores se tratan de la misma manera, por
		lo que no es importante a lo que apunte el iterador.  De esta
		forma se puede escribir código más genérico. Todos los
		contenedores y algoritmos en la Librería Estándar de C++ se
		basan en este principio de los iteradores.
	 </para>
	 
	 <para>
		Para ayudar a hacer las cosas más genéricas, sería agradable
		decir <quote>todas las clases contenedoras tienen una clase
		asociada llamada <classname>iterator</classname></quote>, pero
		esto causará normalmente problemas de nombres. La solución
		consite en añadir una clase anidada para cada contenedor (en
		este caso, <quote><classname>iterator</classname></quote>
		comienza con una letra minúscula para que esté conforme al
		estilo del C++ estándar).  Aquí está el
		<filename>InterIntStack.cpp </filename> con un
		<classname>iterator </classname> anidado:
	 </para>

	 <para>
		<programlisting>
		  <xi:include parse="text" href="./code/C16/NestedIterator.cpp"/>
		</programlisting>
	 </para>

	 <para>
		Cuando se crea una clase <literal role="keyword">friend </literal> anidada, hay
		que seguir el proceso de primero declarar el nombre de la clase,
		después declararla como <literal role="keyword">friend</literal>, y después
		definir la clase. De otra forma, se confundirá el compilador.
	 </para>
	 
	 <para>
		Al iterador se le han dado algunas vueltas de tuerca más. La
		función miembro <function>current()</function> produce el
		elemento que el iterador está seleccionando actualmente en el
		contenedor. Se puede <quote>saltar</quote> hacia adelante un
		número arbitrario de elementos usando el <literal
		role="operator">operator+=</literal>. También, se pueden ver
		otros dos operadores sobrecargados: == y != que compararán un
		iterador con otro. Estos operadores pueden comparar dos
		<classname>IntStack::iterator</classname>, pero su intención
		primordial es comprobar si el iterador está al final de una
		secuencia de la misma manera que lo hacen los iteradores
		<quote>reales</quote> de la Librería Estándar de C++. La idea es
		que dos iteradores definan un rango, incluyendo el primer
		elemento apuntado por el primer iterador pero <emphasis>sin
		</emphasis> incluir el último elemento apuntado por el segundo
		iterador. Por esto, si se quiere mover a través del rango
		definido por los dos iteradores, se dirá algo como lo siguiente:
	 </para>


	 <programlisting><ret></ret>
<reserv>while</reserv> (star != end)<ret></ret>
<tab></tab>cout &lt;&lt; start++ &lt;&lt; endl;<ret></ret>
	 </programlisting>

	 <para>
		Donde <varname>start </varname> y <varname>end </varname> son
		los dos iteradores en el rango.  Note que el iterador
		<varname>end</varname>, al cual se le suele referir como el
		<literal>end sentinel</literal>, no es desreferenciado y nos
		avisa que estamos al final de la secuencia. Es decir, representa
		el que <quote>otro sobrepasa el final</quote>.
	 </para>

	 <para>
		La mayoría del tiempo se querrá mover a través de la secuencia
		entera de un contenedor, por lo que el contenedor necesitará
		alguna forma de producir los iteradores indicando el principio y
		el final de la secuencia. Aquí, como en la Standard C++ Library,
		estos iteradores se producen por las funciones miembro del
		contenedor <function>begin() </function> y
		<function>end()</function>. <function>begin() </function> usa el
		primer constructor de <classname>iterator </classname> que por
		defecto apunta al principio del contenedor (esto es el primer
		elemento que se introdujo en la pila). Sin embargo, un segundo
		constructor, usado por <function>end()</function>, es necesario
		para crear el iterador final. Estar <quote>al final</quote>
		significa apuntar a lo más alto de la pila, porque <varname>top
		</varname> siempre indica el siguiente espacio de la pila que
		esté disponible pero sin usar. Este constructor del
		<classname>iterator </classname> toma un segundo argumento del
		tipo <type>bool</type>, lo cual es útil para distinguir los dos
		constructores.
	 </para>

	 <para>
		De nuevo se usan los números Fibonacci para rellenar la
		<classname>IntStack </classname> en el
		<function>main()</function>, y se usan iteradores para moverse
		completamente a través de la <classname>IntStack </classname>
		así como para moverse en un reducido rango de la secuencia.
	 </para>

	 <para>
		El siguiente paso, por supuesto, es hacer el código general
		transformándolo en un template del tipo que maneje, para que en
		vez ser forzado a manejar enteros se pueda gestionar cualquier
		tipo:
	 </para>

	 <para>
		<programlisting>
		  <xi:include parse="text" href="./code/C16/IterStackTemplate.h"/>
		</programlisting>
	 </para>

	 <para>
		Se puede ver que la transformación de una clase regular en un
		<literal role="keyword">template </literal> es razonablemente
		transparente. Esta aproximación de primero crear y depurar una
		clase ordinaria, y después transformarla en plantilla, está
		generalmente considerada como más sencilla que crear el template
		desde la nada.
	 </para>

	 <para>
		Dese cuenta que en vez de sólo decir:
	 </para>

	 <programlisting><ret></ret>
<reserv>friend</reserv> iterator;  <coment>// Hacerlo amigo</coment><ret></ret>
	 </programlisting>

	 <para>
		Este código tiene:
	 </para>

	 <programlisting><ret></ret>
<reserv>friend</reserv> <reserv>class</reserv> iterator;  <coment>// Hacerlo amigo</coment><ret></ret>
	 </programlisting>
	 
	 <para>
		Esto es importante porque el nombre <quote><literal
		role="keyword">iterator</literal></quote> ya existe en el ámbito
		de resolución, por culpa de un archivo incluido.
	 </para>

	 <para>
		En vez de la función miembro <function>current()</function>, el
		<classname>iterator </classname> tiene un <literal
		role="operator">operator* </literal> para seleccionar el
		elemento actual, lo que hace que el <classname>iterator
		</classname> se parezca más a un puntero lo cual es una práctica
		común.
	 </para>

	 <para>
		Aquí está el ejemplo revisado para comprobar el template.
	 </para>


	 <para>
		<programlisting>
		  <xi:include parse="text" href="./code/C16/IterStackTemplateTest.cpp"/>
		</programlisting>
	 </para>

	 <para>
		El primer uso del iterador simplemente lo recorre de principio a
		fin (y muestra que el límite final funciona correctamente). En
		el segundo uso, se puede ver como los iteradores permite
		fácilmente especificar un rango de elementos (los contenedores y
		los iteradores del Standard C++ Library usan este concepto de
		rangos casi en cualquier parte). El sobrecargado <literal
		role="operator">operator+= </literal> mueve los iteradores
		<varname>start </varname> y <varname>end </varname> a posiciones
		que están en el medio del rango de elementos de
		<varname>is</varname>, y estos elementos son imprimidos. Hay que
		resaltar, como se ve en la salida, que el elemento final no está
		incluido en el rango, o sea que una vez llegado al elemento
		final (end sentinel) se sabe que se ha pasado el final del rango
		- pero no hay que desreferenciar el elemento final o si no se
		puede acabar desreferenciando un puntero nulo. (Yo he puesto un
		guardian en el <classname>StackTemplate::iterator</classname>,
		pero en la Librería Estándar de C++ los contenedores y los
		iteradores no tienen ese código - por motivos de eficiencia -
		por lo que hay que prestar atención).
	 </para>

	 <para>
		Por último para verificar que el <classname>StackTemplate
		</classname> funciona con objetos clase, se instancia uno para
		<type>string</type>s y se rellena con líneas del código fuente,
		las cuales son posteriormente imprimidas en pantalla.
	 </para>


	 <sect2>
		<title>Stack con iteradores</title>
		

		<para>
		  Podemos repetir el proceso con la clase de tamaño dinámico
		  <classname>Stack</classname> que ha sido usada como un ejemplo
		  a lo largo de todo el libro. Aquí está la clase
		  <classname>Stack </classname> con un iterador anidado en todo
		  el medio:
		</para>

		<para>
		  <programlisting>
			 <xi:include parse="text" href="./code/C16/TStack2.h"/>
		  </programlisting>
		</para>

		<para>
		  Hay que hacer notar que la clase ha sido cambiada para
		  soportar la posesión, que funciona ahora debido a que la clase
		  conoce ahora el tipo exacto (o al menos el tipo base, que
		  funciona asumiendo que son usados los destructores
		  virtuales). La opción por defecto es que el contenedor
		  destruya sus objetos pero nosotros somos responsables de los
		  objetos a los que se haga <function>pop()</function>.
		</para>

		<para>
		  El iterador es simple, y físicamente muy pequeño - el tamaño
		  de un único puntero. Cuando se crea un
		  <classname>iterator</classname>, se inicializa a la cabeza de
		  la lista enlazada, y sólo puede ser incrementado avanzando a
		  través de la lista. Si se quiere empezar desde el principio,
		  hay que crear un nuevo iterador, y si se quiere recordar un
		  punto de la lista, hay que crear un nuevo iterador a partir
		  del iterador existente que está apuntando a ese elemento
		  (usando el constructor de copia del iterador).
		</para>

		<para>
		  Para llamar a funciones del objeto referenciado por el
		  iterador, se puede usar la función
		  <function>current()</function>, el <literal
		  role="operator">operator*</literal>, o la desreferencia de
		  puntero <literal role="operator">operator-> </literal> (un
		  elemento común en los iteradores).  La última tiene una
		  implementación que <emphasis>parece</emphasis> idéntica a
		  <function>current() </function> debido a que devuelve un
		  puntero al objeto actual, pero es diferente porque el operador
		  desreferencia del puntero realiza niveles extra de
		  desreferenciación (ver Capítulo 12).
		</para>

		<para>
		  La clase <classname>iterator </classname> sigue el formato que
		  se vio en el ejemplo anterior.  <classname>class iterator
		  </classname> está anidada dentro de la clase contenedora,
		  contiene constructores para crear un iterador que apunta a un
		  elemento en el contenedor y un iterador <quote>marcador de
		  final</quote>, y la clase contenedora tiene los métodos
		  <function>begin() </function> y <function>end() </function>
		  para producir estos iteradores. (Cuando aprenda más de la
		  Librería Estándar de C++, verá que los nombres
		  <classname>iterator</classname>, <function>begin() </function>
		  y <function>end()</function> que se usan aquí tienen
		  correspondecia en las clases contenedoras. Al final de este
		  capítulo, se verá que esto permite manejar estas clases
		  contenedoras como si fueran clases de la STL).
		</para>
	 
		<para>
		  La implementación completa se encuentra en el archivo
		  cabecera, por lo que no existe un archivo <filename>cpp
		  </filename> separado. Aquí tenemos un pequeño test que usa el
		  iterador.
		</para>

		<para>
		  <programlisting>
			 <xi:include parse="text" href="./code/C16/TStack2Test.cpp"/>
		  </programlisting>
		</para>

		<para>
		  Una pila <classname>Stack </classname> es instanciada para
		  gestionar objetos <type>string </type> y se rellena con líneas
		  de un fichero. Entonces se crea un iterador y se usa para
		  moverse a través de la secuencia. La décima línea es recordada
		  mediante un segundo iterador creado con el constructor de
		  copia del primero; posteriormente esta línea es imprimida y el
		  iterador - crado dinámicamente - es destruido. Aquí la
		  creación dinámica de objetos es usada para controlar la vida
		  del objeto.
		</para>


	 </sect2>
	 <sect2>
		<title>PStash con iteradores</title>

		<para>
		  Para la mayoría de los contenedores tiene sentido tener un
		  iterador. Aquí tenemos un iterador añadido a la clase
		  <classname>PStash</classname>:
		</para>


		<para>
		  <programlisting>
			 <xi:include parse="text" href="./code/C16/TStash2.h"/>
		  </programlisting>
		</para>

		<para>
		  La mayoría de este archivo es un traducción prácticamente
		  directa del anterior <classname>PStash </classname> y el iterador
		  anidado dentro de un template. Esta vez, sin embargo, el
		  operador devuelve referencias al iterador actual, la cual es
		  una aproximación más típica y flexible.
		</para>

		<para>
		  El destructor llama a <function>delete </function> para todos
		  los punteros que contiene, y como el tipo es obtenido de la
		  plantilla, se ejecutará la destrucción adecuada.  Hay que
		  estar precavido que si el contenedor controla punteros al tipo
		  de la clase base, este tipo debe tener un destructor <literal
		  role="keyword">virtual </literal> para asegurar un limpiado
		  adecuado de los objetos derivados que hayan usado un upcast
		  cuando se los alojó en el contenedor.
		</para>

		<para>
		  El <varname>PStash::iterator</varname> mantiene el modelo de
		  engancharse a un único objeto contenedor durante su ciclo de
		  vida. Además, el constructor de copia permite crear un nuevo
		  iterador que apunte a la misma posición del iterador desde el
		  que se le creo, creando de esta manera un marcador dentro del
		  contenedor. Las funciones miembro <function>operator+=
		  </function> y el <function>operator-=</function> permiten
		  mover un iterador un número de posiciones, mientras se
		  respeten los límites del contenedor.  Los operadores
		  sobrecargados de incremento y decremento mueven el iterador
		  una posición.  El <function>operator+</function> produce un
		  nuevo iterador que se mueve adelante la cantidad añadida. Como
		  en el ejemplo anterior, los operadores de desreferencia de
		  punteros son usados para manejar el elemento al que el
		  iterador está referenciando, y <function>remove()</function>
		  destruye el objeto actual llamando al
		  <function>remove()</function> del contenedor.
		</para>

		<para>
		  Se usa la misma clase de código de antes para crear el
		  marcador final: un segundo constructor, la función miembro del
		  contenedor <function>end()</function>, y el
		  <function>operator== </function> y <function>operator!=
		  </function> para comparaciones.
		</para>

		<para>
		  El siguiente ejemplo crea y comprueba dos diferentes clases de
		  objetos <classname>Stash</classname>, uno para una nueva clase
		  llamada <classname>Int</classname> que anuncia su construcción y
		  destrucción y otra que gestiona objetos <type>string
		  </type> de la librería Estándar.
		</para>

		<para>
		  <programlisting>
			 <xi:include parse="text" href="./code/C16/TStash2Test.cpp"/>
		  </programlisting>
		</para>


		<para>
		  Por conveniencia <classname>Int </classname> tiene asociado un
		  <varname>ostream operator&lt;&lt;</varname> para
		  <classname>Int&amp;</classname> y <classname>Int*</classname>.
		</para>

		<para>
		  El primer bloque de código en <function>main()</function> está
		  rodeado de llaves para forzar la destrucción de
		  <varname>PStash&lt;Int&gt;</varname> que produce un limpiado
		  automático por este destructor. Unos cuantos elementos son
		  sacados y borrados a mano para mostrar que <classname>PStash
		  </classname> limpia el resto.
		</para>

		<para>
		  Para ambas instancias de <classname>PStash</classname>, se
		  crea un iterador y se usa para moverse a través del
		  contenedor. Note la elegancia generada por el uso de estos
		  constructores; no hay que preocuparse por los detalles de
		  implementación de usar un array. Se le dice al contenedor y al
		  iterador <emphasis>qué</emphasis> hacer y no
		  <emphasis>cómo</emphasis> hacerlo. Esto produce una solución
		  más sencilla de conceptualizar, construir y modificar.
		</para>

	 </sect2>
  </sect1>

  <sect1>
	 <title>Por qué usar iteradores</title>

	 <para>
		Hasta ahora se han visto los mecanismos de los iteradores, pero
		entender el por qué son tan importantes necesita un ejemplo más
		complejo.
	 </para>

	 <para>
		Es normal ver el polimorfismo, la creación dinámica de objetos,
		y los contenedores en un programa orientado a objetos real. Los
		contendores y la creación dinámica de objetos resuelven el
		problema de no saber cuantos o que tipo de objetos se
		necesitarán. Y si el contenedor está configurado para manejar
		punteros a la clase base, cada vez que se ponga un puntero a una
		clase derivada hay un upcast (con los beneficios que conlleva de
		claridad de código y extensibilidad). Como código del final del
		Volumen 1, este ejemplo reune varios aspectos de todo lo que se
		ha aprendido - si es capaz de seguir este ejemplo, entonces está
		preparado para el Volumen 2.
	 </para>

	 <para>
		Suponga que esta creando un programa que permite al usuario
		editar y producir diferentes clases de dibujos. Cada dibujo es
		un objeto que contiene una colección de objetos
		<classname>Shape</classname>:
	 </para>
	 
	 <para>
		<programlisting>
		  <xi:include parse="text" href="./code/C16/Shape.h"/>
		</programlisting>
	 </para>


	 <para>
		Se usa la estructura clásica de las funciones virtuales en la
		clase base que son sobreescritas en la clase derivada. Hay que
		resaltar que la clase <classname>Shape </classname> incluye un
		destructor virtual, algo que se debería añadir automáticamente a
		cualquier clase con funciones <literal
		role="keyword">virtual</literal>es. Si un contenedor maneja
		punteros o referencias a objetos <classname>Shape</classname>,
		entonces cuando los destructores virtuales sean llamados para
		estos objetos todo será correctamente limpiado.
	 </para>

	 <para>
		Cada tipo diferente de dibujo en el siguiente ejemplo hace uso
		de una plantilla de clase contenedora diferente: el
		<classname>PStash </classname> y el <classname>Stack
		</classname> que han sido definido en este capítulo, y la clase
		<classname>vector </classname> de la Librería Estándar de
		C++. El <quote>uso</quote> de los contenedores es extremadamente
		simple, y en general la herencia no es la mejor aproximación
		(composición puede tener más sentido), pero en este caso la
		herencia es una aproximación más simple.
	 </para>

	 <para>
		<programlisting>
		  <xi:include parse="text" href="./code/C16/Drawing.cpp"/>
		</programlisting>
	 </para>

	 <para>
		Los distintos tipos de contenedores manejan punteros a
		<classname>Shape </classname> y punteros a objetos de clases
		derivadas de <classname>Shape</classname>. Sin embargo, debido
		al polimorfismo, cuando se llama a las funcione virtuales ocurre
		el comportamiento adecuado.
	 </para>

	 <para>
		Note que <varname>sarray</varname>, el array de
		<classname>Shape*</classname>, puede ser recorrido como un
		contenedor.
	 </para>


	 <sect2>
		<title>Plantillas Función</title>

		<para>
		  En <function>drawAll()</function> se ve algo nuevo. En este
		  capítulo, únicamente hemos estado usando <emphasis>plantillas
		  de clases</emphasis>, las cuales pueden instanciar nuevas
		  clases basadas en uno o más parámetros de tipo. Sin embargo,
		  se puede crear <emphasis>plantillas de función</emphasis>, las
		  cuales crean nuevas funciones basadas en parámetros de
		  tipo. La razón para crear una plantilla de función es la misma
		  por la cual se crea una plantilla de clase: intentar crear
		  código más genérico, y se hace retrasando la especificación de
		  uno o más tipos.  Se quiere decir que estos parámetros de
		  tipos soportan ciertas operaciones, no qué tipos exactos son.
		</para>

		<para>
		  Se puede pensar sobre la plantilla función <function>drawAll()
		  </function> como si fuera un <emphasis>algoritmo </emphasis>
		  (y así es como se llaman la mayoría de las plantillas de
		  función de la STL). Sólo dice como hacer algo dado unos
		  iteradores que describen un rango de elementos, mientras que
		  estos iteradores pueden ser desreferenciados, incrementados, y
		  comparados. Estos son exactamente la clase de iteradores que
		  hemos estado desarrollando en este capítulo, y también - y no
		  por casualidad - la clase de iteradores que son producidos por
		  los contenedores de la Librería Estándar de C++, evidenciado
		  por el uso de <classname>vector</classname> en este ejemplo.
		</para>

		<para>
		  Además nos gustaría que <function>drawAll() </function> fuera un
		  <emphasis>algoritmo genérico</emphasis>, para que los
		  contenedores pudieran ser de cualquier tipo y que no se
		  tuviera que escribir una nueva versión del algoritmo para cada
		  tipo diferente del contenedor. Aquí es donde las plantillas de
		  funciones son esenciales, porque automáticamente generan el
		  código específico para cada tipo de contenedor diferente. Pero
		  sin la indirección extra proporcionada por los iteradores,
		  estas generalizaciones no serían posibles. Este es el motivo
		  por el que los iteradores son importantes; nos permiten
		  escribir código de propósito general que involucra a
		  contenedores sin conocer la estructura subyacente del
		  contenedor. (Note que los iteradores de C++ y los algoritmos
		  genéricos requieren plantillas de funciones).
		</para>

		<para>
		  Se puede ver el alcance de esto en el
		  <function>main()</function>, ya que <function>drawAll()
		  </function> funciona sin cambiar cada uno de los diferentes
		  tipos de contenedores. E incluso más interesante,
		  <function>drawAll() </function> también funciona con punteros
		  al principio y al final del array
		  <varname>sarray</varname>. Esta habilidad para tratar arrays
		  como contenedores está integrada en el diseño de la Librería
		  Estándar de C++, cuyos algoritmos se parecen mucho a
		  <function>drawAll()</function>.
		</para>

		<para>
		  Debido a que las plantillas de clases contenedoras están
		  raramente sujetas a la herencia y al upcast se ven como clases
		  <quote>ordinarias</quote>, casi nunca se verán funciones virtuales en
		  clases contenedoras. El reuso de las clases contenedoras está
		  implementado mediante plantillas, no mediante herencia.
		</para>


	 </sect2>

  </sect1>



  <sect1>
	 <title>Resumen</title>

	 <para>
		Las clases contenedoras son una parte esencial de la
		programación orientada a objetos.  Son otro modo de simplificar
		y ocultar los detalles de un programa y de acelerar el proceso
		de desarrollo del programa. Además, proporcionan un gran nivel
		de seguridad y flexibilidad reemplazando los anticuados arrays y
		las relativamente toscas técnicas de estructuras que se pueden
		encontrar en C.
	 </para>

	 <para>
		Como el programador cliente necesita contenedores, es esencial
		que sean fáciles de usar.  Aquí es donde entran los <literal
		role="keyword">template</literal>s. Con las plantillas la
		sintaxis para el reciclaje del código fuente (al contrario del
		reciclaje del código objeto que proporciona la herencia y la
		composición) se vuelve lo suficientemente trivial para el
		usuario novel. De hecho, la reutilización de código con
		plantillas es notablemente más fácil que la herencia y el
		polimorfismo.
	 </para>

	 <para>
		Aunque se ha aprendido cómo crear contenedores y clases
		iteradoras en este libro, en la práctica es mucho más útil
		aprender los contenedores e iteradores que contiene la Librería
		Estándar de C++, ya que se puede esperar encontrarlas en
		cualquier compilador. Como se verá en el Volumen 2 de este libro
		(que se puede bajar de <ulink
		url="http://www.bruceeckel.com">www.BruceEckel.com</ulink>, los
		contenedores y algoritmos de la STL colmarán virtualmente sus
		necesidades por lo que no tendrá que crear otras nuevas.
	 </para>

	 <para>
		Las características que implica el diseño con clases
		contenedoras han sido introducidas a lo largo de todo el
		capítulo, pero hay que resaltar que van mucho más allá. Una
		librería de clases contenedoras más complicada debería cubrir
		todo tipo de características adicionales, como la multitarea, la
		persistencia y la recolección de basura.
	 </para>
  </sect1>

  <sect1>
	 <title>Ejercicios</title>

	 <para>
		La solución a los ejercicios seleccionados se pueden encontrar
		en el documento electrónico <quote>The thinking in C++ Annotated
		Solution Guide</quote>, disponible por una pequeña cantidad en
		<ulink
		  url="http://www.bruceeckel.com">www.BruceEckel.com</ulink>.
	 </para>


	 <orderedlist>
		<listitem>
		  <para>
			 Implemente la jerarquía de herencia del diagrama de
			 <classname>OShape </classname> de este capítulo.
		  </para>
		</listitem>

		<listitem>
		  <para>
			 Modifique el resultado del Ejercicio 1 del capítulo 15 para
			 usar la <classname>Stack </classname> y el
			 <classname>iterator </classname> en <filename>TStack2.h
			 </filename> en vez de un array de punteros a
			 <classname>Shape</classname>. Añada destructores a la
			 jerarquía de clases para que se pueda ver que los objetos
			 <classname>Shape </classname> han sido destruidos cuando la
			 <classname>Stack </classname> se sale del ámbito.
		  </para>
		</listitem>

		<listitem>
		  <para>
			 Modifique <filename>TPStash.h </filename> para que el valor
			 de incremento usado por <function>inflate() </function>
			 pueda ser cambiado durante la vida de un objeto contenedor
			 particular.
		  </para>
		</listitem>

		<listitem>
		  <para>
			 Modifique <filename>TPStash.h </filename> para que el valor de
			 incremento usado por <function>inflate() </function>
			 automáticamente cambie de tamaño para que reduzca el número
			 de veces que debe ser llamado. Por ejemplo, cada vez que se
			 llama podría doblar el valor de incremento para su uso en la
			 siguiente llamada. Demuestre la funcionalidad mostrando cada
			 vez que se llama a <function>inflate()</function>, y escriba
			 código de prueba en <function>main()</function>.
		  </para>
		</listitem>

		<listitem>
		  <para>
			 Convierta en plantilla la función de <function>fibonacci()
			 </function> con los tipos que puede producir (puede generar
			 <type>long</type>, <type>float</type>, etc.  en vez de sólo
			 <type>int</type>).
		  </para>
		</listitem>

		<listitem>
		  <para>
			 Usar el <classname>vector </classname> de la STL como
			 implementación subyacente, para crear una platilla
			 <classname>Set </classname> que acepte solo uno de cada tipo
			 de objeto que se aloje en él. Cree un iterador anidado que
			 soporte el concepto de "marcador final" de este
			 capítulo. Escriba código de prueba para el <classname>Set
			 </classname> en el <function>main()</function>, y entonces
			 sustituyalo por la plantilla <classname>set </classname> de
			 la STL para comprobar que el comportamiento es correcto.
		  </para>
		</listitem>
		
		<listitem>
		  <para>
			 Modifique <filename>AutoCounter.h </filename> para que pueda
			 ser usado como un objeto miembro dentro de cualquier clase
			 cuya creación y destrucción quiera comprobar. Añada un
			 miembro <type>string </type> para que contenga el
			 nombre de la clase. Compruebe esta herramienta dentro una
			 clase suya.
		  </para>
		</listitem>

		<listitem>
		  <para>
			 Cree una versión de <filename>OwnerStack.h </filename> que use
			 un <classname>vector </classname> de la Librería Estándar de C++
			 como su implementación subyacente.  Será necesario conocer
			 algunas de las funciones miembro de <classname>vector
			 </classname> para poder hacerlo (sólo hay que mirar en el
			 archivo cabecera &lt;vector&gt;).
		  </para>
		</listitem>

		<listitem>
		  <para>
			 Modifique <filename>ValueStack.h </filename> para que pueda
			 expandirse dinámicamente según se introduzcan más objetos y
			 se quede sin espacio. Cambie <filename>ValueStackTest.cpp
			 </filename> para comprobar su nueva funcionalidad.
		  </para>
		</listitem>

		<listitem>
		  <para>
			 Repita el ejercicio 9 pero use el <classname>vector
			 </classname> de la STL como la implementación interna de
			 <classname>ValueStack</classname>. Note lo sencillo que es.
		  </para>
		</listitem>

		<listitem>
		  <para>
			 Modifique <filename>ValueStackTest.cpp </filename> para que
			 use un <classname>vector </classname> de la STL en vez de un
			 <classname>Stack </classname> en el
			 <function>main()</function>. Dése cuenta del comportamiento
			 en tiempo de ejecución: ¿Se genera un grupo de objetos por
			 defecto cuando se crea el <classname>vector</classname>?
		  </para>
		</listitem>

		<listitem>
		  <para>
			 Modifique <filename>TStack2.h </filename> para que use un
			 <classname>vector </classname> de la STL.  Asegurese de que no
			 cambia la interfaz, para que <filename>TStack2Test.cpp
			 </filename> funcione sin cambiarse.
		  </para>
		</listitem>

		<listitem>
		  <para>
			 Repita el Ejercicio 12 usando una <classname>stack </classname>
			 de la Librería Estándar de C++ en vez de un
			 <classname>vector</classname>.
		  </para>
		</listitem>

		<listitem>
		  <para>
			 Modifique <filename>TPStash2.h </filename> para que use un
			 <classname>vector </classname> de la STL como su
			 implementación interna. Asegurese que no cambia la interfaz,
			 por lo que <filename>TPStash2Test.cpp </filename> funciona
			 sin modificarse.
		  </para>
		</listitem>

		<listitem>
		  <para>
			 En <filename>IterIntStack.cpp</filename>, modifique
			 <classname>IntStackIter </classname> para darle un
			 constructor de <quote>marcador final</quote>, y añada el
			 <literal role="operator">operator== </literal> y el <literal
			 role="operator">operator!=</literal>. En el
			 <function>main()</function>, use un iterador para moverse a
			 través de los elementos del contenedor hasta que se
			 encuentre el marcador.
		  </para>
		</listitem>

		<listitem>
		  <para>
			 Use <filename>TStack2.h</filename>,
			 <filename>TPSTash2.h</filename>, y
			 <filename>Shape.h</filename>, instancie los contenedores
			 <classname>PStash </classname> y <classname>Stack
			 </classname> para que contenga
			 <classname>Shape*</classname>, rellene cada uno con punteros
			 a <classname>Shape</classname>, entonces use iteradores para
			 moverse a través de cada contenedor y llame a
			 <function>draw() </function> para cada objeto.
		  </para>
		</listitem>

		<listitem>
		  <para>
			 Cree una plantilla en la clase <type>Int </type> para
			 que pueda alojar cualquier tipo de objetos (Siéntase libre
			 de cambiar el nombre de la clase a algo más apropiado).
		  </para>
		</listitem>

		<listitem>
		  <para>
			 Cree una plantilla de la clase <classname>IntArray
			 </classname> en <filename>IostreamOperatorOverloading.cpp
			 </filename> del capítulo 12, introduzca en plantilla ambos
			 tipos de objetos que están contenidos y el tamaño del array
			 interno
		  </para>
		</listitem>

		<listitem>
		  <para>
			 Convierta <classname>ObjContainer </classname> en
			 <filename>NestedSmartPointer.cpp </filename> del Capítulo 12
			 en una plantilla. Compruebelo con dos clases diferentes.
		  </para>
		</listitem>

		<listitem>
		  <para>
			 Modifique <filename>C15:OStack.h </filename> y
			 <filename>C15:OStackTest.cpp </filename> consiguiendo que
			 <classname>class Stack </classname> pueda tener múltiple
			 herencia automáticamente de la clase contenida y de
			 <classname>Object</classname>. La <classname>Stack
			 </classname> contenida debe aceptar y producir sólo punteros
			 del tipo contenido.
		  </para>
		</listitem>

		<listitem>
		  <para>
			 Repita el ejercicio 20 usando <classname>vector </classname>
			 en vez de <classname>Stack</classname>.
		  </para>
		</listitem>

		<listitem>
		  <para>
			 Herede una clase <classname>StringVector </classname> de
			 <classname>vector&lt;void&gt; </classname> y redefina las
			 funciones miembro <function>push_back() </function> y el
			 <literal role="operator">operator[] </literal> para que acepten y produzcan
			 únicamente <type>string* </type> (y realizen el
			 moldeado adecuado). Ahora creee una plantilla que haga
			 automáticamente lo mismo a una clase contenedora para
			 punteros de cualquier tipo. Esta técnica es a menudo usada
			 para reducir el código producido por muchas instanciaciones
			 de templates.
		  </para>
		</listitem>

		<listitem>
		  <para>
			 En <filename>TPStash2.h</filename>, añada y compruebe un
			 <literal role="operator">operator- </literal> para
			 <classname>PStash::iterator</classname>, siguiendo la lógica
			 de <literal role="operator">operator+</literal>.
		  </para>
		</listitem>

		<listitem>
		  <para>
			 En <filename>Drawing.cpp</filename>, añada y compruebe una
			 plantilla de función que llame a funciones miembro
			 <function>erase()</function>.
		  </para>
		</listitem>

		<listitem>
		  <para>
			 (Avanzado) Modifique la clase <classname>Stack </classname>
			 en <filename>TStack2.h </filename> para permitir una
			 granularidad de la propiedad: Añada una bandera para cada
			 enlace indicando si el enlace posee el objeto al que apunta,
			 y de soporte a esta información la función <function>push()
			 </function> y en el destructor. Añada funciones miembro para
			 leer y cambiar la propiedad de cada enlace.
		  </para>
		</listitem>

		<listitem>
		  <para>
			 (Avanzado) Modifique <filename>PointerToMemberOperator.cpp
			 </filename> del Capítulo 12 para que la
			 <classname>FunctionObject </classname> y el <literal
			 role="operator">operator->* </literal> sean convertidos en
			 plantillas para que funcionen con cualquier tipo de retorno
			 (para <literal role="operator">operator->*</literal>, tendrá
			 que usar <emphasis>plantillas miembro </emphasis> descritas
			 en el Volumen 2). Añada soporte y compruebe para cero, uno y
			 dos argumentos en las funciones miembro
			 <classname>Dog</classname>.
		  </para>
		</listitem>
	 </orderedlist>
  </sect1>
</chapter>