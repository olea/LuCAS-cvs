<?xml  version="1.0" encoding="iso-8859-1"?>
<!-- -*- sgml -*- -->
<!--
  Editor:              Emacs 21/PSGML
  Traducción original: José María Requena
                       (anterior a LuCaS)
  Formateado DocBook:  Miguel Ángel García Martínez
  1ª Revisión:
  2ª Revisión
-->

<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
                 "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">

<chapter 
  xmlns:xi="http://www.w3.org/2001/XInclude"
  id="AC">


  <title>Apéndice C</title>

	<para>Recursos para profundizar en el estudio</para>

	 <sect1>
		<title>Sobre C</title>
		<para>
		<quote><emphasis>Thinking in C: Foundations for Java &amp;
		  C++</emphasis></quote>, por Chuck Allison (un seminario en
		  CDRoM de MindView, Inc. , 2000, incluido al final de este
		  libro y disponible también en <ulink
		  url="http://www.bruceeckel.com">www.BruceEckel.com</ulink>). Se
		  trata de un curso que incluye lecciones y transparencias sobre
		  los conceptos básicos del lenguaje C para preparar al lector a
		  aprender Java o C++. No es un curso exhaustivo sobre C; sólo
		  contiene lo necesario para cambiarse a esos otros
		  lenguajes. Unas secciones adicionales sobre esos lenguajes
		  concretos introducen al aspirante a programador en C++ o en
		  Java, a sus características.  Requisitos previos: alguna
		  experiencia con un lenguaje de alto nivel, como Pascal, BASIC,
		  Fortran, o LISP (sería posible avanzar por el CD sin ese
		  bagaje, pero el curso no está pensado para servir de
		  introducción básica a la programación).
		</para>
	 </sect1>

	 <sect1>
		<title>Sobre C++ en general</title>
		<para>
		<quote><emphasis>The C++ Programming Language, 3ª
		  edición</emphasis></quote>, por Bjarne Stroustrup
		  (Addison-Wesley 1997).Hasta cierto punto, el objetivo de la
		  obra que tiene en sus manos es permitirle usarel libro de
		  Bjarne a modo de referencia. Dado que contiene la descripción
		  del lenguaje por su propio autor, es típicamente ahí donde se
		  mira para resolver dudas sobre qué se supone que C++ debe o no
		  debe hacer. Cuando empiece a dominar el lenguaje y esté
		  preparado para pasar a las cosas serias, lo necesitará.
		</para>
		<para>
		<quote><emphasis>C++ Primer, 3ª Edición</emphasis></quote>,por
		  Stanley Lippman y Josee Lajoie (Addison-Wesley 1998). Ha
		  dejado de ser una introducción; se ha convertido en un
		  voluminoso libro muy detallista, y es uno de los que consulto
		  junto con el de Stroustrup cuando intento resolver una
		  cuestión.<quote>Pensar En C++</quote> debe proporcionar una
		  base para entender <emphasis>C++ Primer</emphasis> así como el
		  libro de Stroustrup.
	 </para>
	 <para>
		<quote><emphasis>C &amp; C++ Code Capsules</emphasis></quote>,
		por Chuck Allison (Prentice-Hall, 1998).Ese libro presupone
		unconocimiento de C y C++, y trata cuestiones que ya hayan sido
		quebraderos decabeza, o que no logró zanjar adecuadamente a la
		primera. La obra soluciona lagunas tanto en C como en C++.
	 </para>
	 <para>
		<quote><emphasis>The C++ Standard</emphasis></quote>.Ese es el
		documento en el que el comité ha trabajado tanto durante
		años. No es gratis, desgraciadamente. Pero por lo menos se puede
		adquirir en formato PDF por sólo $18 en <ulink
		url="http://www.cssinfo.com">www.cssinfo.com</ulink>.
	 </para>


	 <sect2>
		<title>Mi propia lista de libros</title>

		<para> Aparecen a continuación ordenados por fecha de
publicación. No todos están a la venta actualmente.
		</para>
		<para>
		  <quote><emphasis>Computer Interfacing with Pascal &amp;
		  C</emphasis></quote>(publicado por mí, vía Eisys, en
		  1988. Disponible únicamente a través de <ulink
		  url="http://www.bruceeckel.com">www.BruceEckel.com</ulink>).
		  Es una introducción a la electrónica desde los días en los que
		  CP/M era aun el rey y MSDoS sólo un principiante. Utilicé
		  lenguajes de alto nivel y a menudo el puerto paralelo del
		  ordenador para pilotar varios proyectos electrónicos. Se trata
		  de una adaptación de mis columnas en la primera y mejor
		  revista para la que trabajé, <emphasis>Micro
		  Cornucopia</emphasis> (retomando las palabras de Larry
		  o_Brien, editor durante muchos años de <emphasis>Software
		  Development Magazine</emphasis>: la mejor revista de
		  electrónica jamás publicada -¡hasta daban los planos para
		  fabricar un robot a partir de una maceta!). Desgraciadamente,
		  <emphasis>MicroC</emphasis> dejó de existir mucho antes de que
		  apareciese el Internet. Crear ese libro fue una experiencia
		  editorial muy gratificante para mí.
		</para>
		<para>
		  <quote><emphasis>Using C++</emphasis></quote>
		  (osborne/McGraw-Hill 1989).  Fue uno de los primeros libros
		  publicados acerca de C++.  Está agotado y ha sido reemplazado
		  por su segunda edición, bajo el nuevo título <quote>C++ Inside
		  &amp; out.</quote>
		</para>
		<para>
		  <quote><emphasis>C++ Inside &amp; out</emphasis></quote>
		  (osborne/McGraw-Hill 1993).Como se indicó antes, es en
		  realidad la segunda edición de <quote>Using C++</quote>. El
		  lenguaje C++ que describe el libro es bastante correcto, pero
		  data de 1992 y <quote>Pensar En C++</quote> está llamado a
		  sustituirlo. Puede saber más acerca de ese libro y conseguir
		  el código fuente en <ulink
		  url="http://www.bruceeckel.com">www.BruceEckel.com</ulink>.
		</para>
		<para>
		  <quote><emphasis> Thinking in C++, 1ª edition</emphasis>
		  </quote>(Prentice-Hall 1995).
		</para>
		<para>
		  <quote> <emphasis>Black Belt C++, the Master's
		  Collection</emphasis></quote>, Bruce Eckel, editor (M&amp;T
		  Books 1994).Agotado. Está constituido por una serie de
		  capítulos escritos por personas de prestigio sobre la base de
		  sus presentaciones en el coloquio sobre C++ durante la
		  Conferencia sobre Desarrollo de Software que yo presidí. La
		  portada del libro me llevó a ejercer desde entonces más
		  control sobre el diseño de las portadas.
		</para>
		<para>
		  <quote><emphasis>Thinking in Java</emphasis></quote>, 2ª
		  edición (Prentice-Hall, 2000).  La primera edición de ese
		  libro ganó el Premio a la Productividad del <emphasis>Software
		  Development Magazine</emphasis> y también el <emphasis>Premio
		  del Editor 1999 </emphasis>del <emphasis>Java Developer_s
		  Journal</emphasis>. Se puede descargar desde <ulink
		  url="http://www.bruceeckel.com">www.BruceEckel.com</ulink>.
		</para>

	 </sect2>
  </sect1>

  <sect1>
	 <title>Los rincones oscuros</title>
	 <para>
		Estos libros profundizan en aspectos del lenguaje, y ayudan a
		evitar los típicos errores inherentes al desarrollo de programas
		en C++.
	 </para>
	 <para>
		<quote><emphasis>Effective C++</emphasis></quote>(2ª Edición,
		Addison-Wesley 1998) y <quote>More Effective C++</quote>
		(Addison-Wesley 1996), por Scott Meyers.  La obra clásica e
		indispensable para resolver los problemas serios y diseñar mejor
		código en C++. He intentado capturar y plasmar muchos de los
		conceptos de esos libros en <quote><emphasis>Pensar en
		C++</emphasis></quote>, pero no pretendo haberlo
		logrado. Cualquiera que dedica tiempo a C++ acaba teniendo esos
		libros.  También disponible en CDRoM.
	 </para>
	 <para>
		<quote><emphasis>Ruminations on C++</emphasis></quote> , por
		Andrew Koenig y Barbara Moo (Addison-Wesley, 1996).Andrew
		trabajó personalmente con Stroustrup en muchos aspectos del
		lenguaje C++ y es por tanto una voz muy autorizada. Me
		encantaron sus incisivos comentarios y he aprendido mucho con
		él, tanto por escrito como en persona, a lo largo de los años.
	 </para>
	 <para>
		<quote><emphasis>Large-Scale C++ Software
		Design</emphasis></quote> , por John Lakos(Addison-Wesley,
		1996).Trata temas y contesta a preguntas con las que uno se
		encuentra durante la creación de grandes proyectos, y a menudo
		de pequeños también.
	 </para>
	 <para>
		<quote> <emphasis>C++ Gems</emphasis></quote>
		editor (SIGS Publications, 1996).  Una selección de artículos
		extraídos de <emphasis>The C++ Report</emphasis>.
	 </para>
	 <para>
		<quote><emphasis> The Design &amp; Evolution of C++</emphasis>
		</quote> , por Bjarne Stroustrup (Addison-Wesley
		1994).Aclaraciones del inventor de C++ acerca de por qué tomó
		ciertas decisiones durante su diseño. No es esencial, pero
		resulta interesante.
	 </para>

  </sect1>
  <sect1>
	 <title>Sobre Análisis y Diseño</title>
	 <para>
		<quote><emphasis>Extreme Programming Explained
		</emphasis></quote>por Kent Beck (Addison-Wesley 2000).¡Adoro
		ese libro! Si,sé que tengo tendencia a tomar posturas radicales,
		pero siempre había intuido que podía haber un proceso de
		desarrollo de programas muy diferente, y mucho mejor, y pienso
		que <emphasis>XP</emphasis> se acerca bastante a ello. El único
		libro que me impactó de forma similar, fue
		<emphasis>PeopleWare</emphasis> (descrito a continuación), que
		trata de los entornos y la interacción con la cultura de las
		empresas. <emphasis>Extreme Programming Explained</emphasis>
		habla de programación, y echa abajo la mayoría de las cosas,
		incluso los recientes <quote>hallazgos</quote>. Llega al punto
		de decir que los dibujos están bien mientras que no se les
		dedique demasiado tiempo y se esté dispuesto a tirarlos a la
		basura. (observen que ese libro no lleva el <quote>sello de
		certificación UML</quote> en su portada). Comprendería que
		alguien decidiese si quiere trabajar o no para una compañía,
		basándose sólo en el hecho que usan XP. Es un libro pequeño, con
		capítulos cortos, fácil de leer, y que da mucho que pensar.  Uno
		empieza a imaginarse trabajando en esa atmósfera y vienen a la
		mente visiones de un mundo nuevo.
	 </para>
	 <para>
		<quote><emphasis>UML Distilled </emphasis></quote> por Martin
		Fowler (2ª edición, Addison-Wesley, 2000).Cuando se descubre UML
		por primera vez, resulta intimidante porque hay tantos diagramas
		y detalles. Según Fowler, la mayoría de esa parafernalia es
		innecesaria, así que se queda sólo con lo esencial. Para la
		mayoría de los proyectos, sólo se necesitan unos pocos
		instrumentos gráficos, y el objetivo de Fowler es llegar a un
		buen diseño en lugar de preocuparse por todos los artefactos que
		permiten alcanzarlo. Es un libro corto, muy legible; el primer
		libro que debería conseguir si necesita entender UML.
	 </para>
	 <para>
		<quote><emphasis> The Unified Software Development
		Process</emphasis></quote> por Ivar Jacobsen, Grady Booch, y
		James Rumbaugh (Addison-Wesley 1999).  Estaba mentalizado para
		que no me gustase ese libro. Parecía tener todos los
		ingredientes de un aburrido texto universitario. Me quedé
		gratamente sorprendido - solo unos islotes dentro del libro
		contienen explicaciones que dan la impresión que los conceptos
		no han quedado claros para los propios autores. La mayoría del
		libro es no solamente claro, sino agradable. Y lo mejor de todo,
		es que el proceso tiene realmente sentido. Esto no es
		<emphasis>Extreme Programming</emphasis> (y no tiene su claridad
		acerca de los tests) pero también forma parte del mastodonte UML
		- incluso si usted no consigue hacer adoptar
		<emphasis>XP</emphasis>, la mayoría de la gente se ha subido al
		carro de "UML es bueno" (independientemente de su nivel de
		experiencia real con él) así que podría conseguir que lo
		adopten. Pienso que ese libro debería ser el buque insignia del
		UML, y es el que se debe de leer después del <emphasis>UML
		Distilled</emphasis> de Fowler en cuanto se desee tener más
		nivel de detalle.
	 </para>
	 <para>
		Antes de elegir método alguno, es útil enriquecer su perspectiva
		través de los que no están intentando vender ninguno. Es fácil
		adoptar un método sin entender realmente lo que se desea
		conseguir con él o lo que puede hacer por uno. otras personas lo
		están usando, lo cual parece una buena razón. Sin embargo, los
		humanos tienen un extraño perfil psicológico: si quieren creer
		que algo va a solucionar sus problemas, lo van a probar. (Eso se
		llama experimentación, que es una cosa buena) Pero si eso no les
		resuelve nada, redoblarán sus esfuerzos y empezarán a anunciar
		por todo lo alto su fabuloso descubrimiento. (Eso es negación de
		la realidad, que no es bueno) La idea parece consistir en que si
		usted consigue meter a más gente en el mismo barco, no se
		sentirá solo, incluso si no va a ninguna parte (o se hunde).  No
		estoy insinuando que todas las metodologías no llevan a ningún
		lado, pero hay que estar armado hasta los dientes con
		herramientas mentales que ayuden a seguir en el modo de
		experimentación (<quote>Esto no funciona, vamos a probar otra
		cosa</quote>) y no en el de negación (<quote>No, no es
		problema. Todo va maravillosamente, no necesitamos
		cambiar</quote>). Creo que los libros siguientes, leídos antes
		de elegir un método, le proporcionarán esas herramientas.
	 </para>
	 <para>
		<quote><emphasis>Software Creativity</emphasis></quote>, por
		Robert Glass (Prentice-Hall, 1995).Ese es el mejor libro que he
		leído que describa una visión de conjunto sobre el debate de las
		metodologías. Consta de una serie de ensayos cortos y artículos
		que Glass ha escrito o comprado (P.J.  Plauger es uno de los que
		contribuyen al libro), que reflejan sus numerosos años dedicados
		a pensar y estudiar el tema. Son amenos y de la longitud justa
		para decir lo necesario; no divaga ni aburre al lector. Pero
		tampoco vende simplemente aire; hay centenares de referencias a
		otros artículos y estudios.  Todos los programadores y jefes de
		proyecto deberían leer ese libro antes de caer en el espejismo
		de las metodologías.
	 </para>
	 <para>
		<quote><emphasis>Software Runaways: Monumental Software
		Disasters</emphasis></quote>, por Robert Glass (Prentice-Hall
		1997).Lo realmente bueno de ese libro es que expone a la luz lo
		que nunca contamos: la cantidad de proyectos que no solo
		fracasan, sino que lo hacen espectacularmente. Veo que la
		mayoría de nosotros aún piensa <quote>Eso no me va a pasar a
		mí</quote> (o <quote>Eso no volverá a pasarme</quote>) y creo
		que eso nos desfavorece. Al tener siempre en mente que las cosas
		pueden salir mal, se está en mejor posición para hacerlas ir
		bien.
	 </para>
	 <para>
		<quote><emphasis>Object Lessons</emphasis></quote> por Tom Love
		(SIGS Books, 1993).  otro buen libro para tener
		<quote>perspectiva</quote>.
	 </para>
	 <para>
		<quote><emphasis>Peopleware</emphasis></quote> , por Tom Demarco
		y Timothy Lister (Dorset House, 2ª edición 1999).A pesar de que
		tiene elementos de desarrollo de software, ese libro trata de
		proyectos y equipos de trabajo en general. Pero el énfasis está
		puesto en las personas y sus necesidades, y no en las
		tecnologías. Se habla de crear un entorno en el que la gente
		esté feliz y productiva, en lugar de decidir las reglas que
		deben seguir para convertirse perfectos engranajes de una
		máquina. Esta última actitud, pienso yo, es lo que más
		contribuye a que los programadores sonrían y digan sí con la
		cabeza cuando un método es adoptado y sigan tranquilamente
		haciendo lo mismo que siempre.
	 </para>
	 <para>
		<quote><emphasis>Complexity</emphasis></quote>, by M. Mitchell
		Waldrop (Simon &amp; Schuster, 1992). Relata el encuentro entre
		un grupo de científicos de diferentes disciplinas en Santa Fe,
		Nuevo Méjico, para discutir sobre problemas reales que como
		especialistas no podían resolver aisladamente (el mercado
		bursátil en economía, la formación inicial de la vida en
		biología, por qué la gente se comporta de cierta manera en
		sociología, etc.). Al reunir la física, la economía, la química,
		las matemáticas, la informática, la sociología, y otras
		ciencias, se está desarrollando un enfoque multidisciplinar a
		esos problemas. Pero más importante aun, una nueva forma de
		pensar en esos problemas extremadamente complejos está
		apareciendo: alejándose del determinismo matemático y de la
		ilusión de poder escribir una fórmula que prediga todos los
		comportamientos, hacia la necesidad de observar primero y buscar
		un patrón para después intentar emularlo por todos los medios
		posibles. (El libro cuenta, por ejemplo, la aparición de los
		algoritmos genéticos). Ese tipo de pensamiento, creo yo, es útil
		a medida que investigamos formas de gestionar proyectos de
		software cada vez más complejos.
	 </para>
  </sect1>
</chapter>
