% TUTORIAL DE C
%
%
%
%
%
%
%

\documentclass[a4paper, twoside]{book}
\frenchspacing
\usepackage[spanish]{babel}
\usepackage{makeidx}
\usepackage{graphicx}
\makeindex
\pagestyle{headings}
\title{Lenguaje C}

\begin{document}
\maketitle

He empezado a escribir esto por distintas razones. La primera porque
siempre he estado buscando un libro un poco decente de aprendizaje de
alg\'un lenguaje de programaci\'on. En el mercado existen muchos, pero 
la mayor\'{\i}a creo que los conocemos todos; programaci\'on de C++,
programaci\'on de C++, programaci\'on de Visual C++, programaci\'on 
de C++, y todos por el mismo estilo; a parte de costarte el m\'as 
barato sobre unas 5.000 pesetas pasando por 7.000, 10.000, etc., cosa 
que sigo viendo abusiva no s\'olo en estos libros sino en el resto y
contando que lo \'unico que nos ofrecen son un mont\'on de p\'aginas
fotocopiadas, eso s\'{\i}, encuadernados (que algunos dejan mucho que
desear); y luego un CDROM donde la mayor parte de los archivos y 
programas son completamente in\'utiles. Luego existen por ah\'{\i} 
multitud de tutoriales que est\'an incompletos, mal redactados, 
en formato HTML y sobre todo shareware que no est\'a  completo.

En segundo lugar, creo que puedo ofrecer en lo que pueda un verdadero
libro que se pueda imprimir poco a poco seg\'un cada uno la posibilidad
que tenga y sus necesidades. El porque de este libro es simplemente la
p\'erdida de tiempo que yo he tenido buscando por la red librer\'{\i}as
y dem\'as lugares y porque creo que aprender un lenguaje como este no
deber\'{\i}a costarte 10.000 pesetas y eso s\'olo para comenzar.
Ahora existe la posibilidad de tener un compilador como es \texttt{gcc}
sin tener que pagar las absurdas cantidades que nos piden las 
compa\~n\'{\i}as por un compilador, aparte de tener que tragar con sus
librer\'{\i}as.

En tercer lugar tengo que decir que estoy en un momento en el que yo
mismo soy el que aprendo, y no s\'olo C, sino tambi\'en \LaTeX{} por
lo que habr\'a  errores de  todo tipo, ``paciencia''.

Tengo que decir que la informaci\'on de este libro en su mayor parte
est\'a recopilada de otros libros, tutoriales, etc. y de mis no muy 
grandes conocimientos, que yo he intentado
ir colocando de una forma que considero de la mejor forma para un
 principiante y que no se pierda, eso s\'{\i}, no entro en detalles
matem\'aticos tales como hexadecimales, binarios, definiciones de
bucles y todo lo relacionado con principios  de programaci\'on, que 
se podr\'an obtener de otros libros. Lo mismo puedo decir de los 
ejemplos ya que si no el libro podr\'{\i}a tener unas dimensiones 
considerablemente absurdas.

Estoy abierto a cualquier sugerencia, incluso si alguien quiere
 continuarlo porque cree que lo puede hacer mejor que yo, que no
quiere decir que lo yo lo deje. Pero esto ir\'a a la velocidad que
me pueda permitir. Tambi\'en estoy abierto a sugerencias de tipo
sint\'actico o sem\'antico debido a que hace tiempo que no leo un
libro, algo que tengo que remediar lo antes posible, y \'ultimamente
tengo un vocabulario un tanto escaso.

En un principio y como le promet\'{\i} o eso creo a un colaborador
de Linux es mandarlo lo m\'as r\'apido posible, y empezar\'e por lo
que ya tengo hecho, los dos primeros temas, sin tablas de contenido
ni \'{\i}ndices, \ldots, no hasta que est\'e un poco m\'as completo.

Para cualquier comentario, duda, inter\'es o quien sabe qu\'e, voy a
dar dos direcciones de correo, una la de un amigo que es donde sea 
m\'as sencillo encontrarme si no tiene el correo saturado o no 
vuelve a cambiar por en\'esima vez de ISP y es afios@lander.es
y la otra la que tengo en la universidad
q42derem@lucano.uco.es

Espero que pueda servir de ayuda a alguien.

\chapter{Introducci\'on al Lenguaje C}

\textsf{El objetivo de este tutorial es el aprendizaje del lenguaje C, en el que
se incluir\'{a}n problemas al final de cada cap\'{\i}tulo (que para una
mayor comprensi\'on deber\'{\i}an hacerse). Intentar\'e en lo m\'as posible
referirme al C para sistemas basados en UN*X y concretamente en Linux.}

\section{Or\'{\i}genes de C}

C es un lenguaje de prop\'osito general, control de flujo y de estructuras
de datos con un rico conjunto de operadores. C no es un \emph{lenguaje de
alto nivel} y no est\'a especializado en ning\'un \'area de aplicaci\'on 
especial.

Originalmente fue desarrollado por y como una implementaci\'on del sistema
operativo UN*X para que corriera sobre las m\'aquinas DEC PDP--11 por 
Dennis Ritchie. C no es espec\'{\i}fico de ning\'un hardware en particular 
o sistema, sin embargo, es f\'acil escribir programas que se ejecutar\'an
sin cambios en cualquier m\'aquina que soporte C, o a veces s\'olo se
tendr\'an que hacer algunos peque\~nos cambios para portarlo; se
 intentar\'a explicar los tipos de funciones y otros aspectos 
fundamentales de este tipo durante el curso del libro.

C se ha escrito para ser en lo posible los m\'as ameno, expresivo y
 vers\'atil posible  para una gran variedad de programas. Es f\'acil
\footnote{En comparaci\'on con otros, claro est\'a}
y se aprende sobre todo con la experiencia.
\footnote{Es importante entender en lo posible los
ejemplos e intentar hacer la mayor\'{i}a de los ejercicios}

Normalmente el lenguaje C se ha asociado al sistema operativo UN*X, muchas
de las ideas importantes de este provienen del lenguaje BCPL desarrollado
por Martin Richard; a su vez \'este precede indirectamente del lenguaje B, 
escrito por Ken Thompson en 1970 para el primer UN*X en la DEC PDP--7. Su
nombre es un sarcasmo de los anteriores lenguajes que se llamaron A y B.

BCPL y B son lenguajes \emph{bajo tipo}. En contraste, C suministra
una gran variedad de tipos de datos, de los cuales los fundamentales
son caracteres, enteros y n\'umeros de coma flotante de varios 
tama\~nos. Hay una jerarqu\'{\i}a de tipos de datos derivados creados 
con punteros, vectores, estructuras y uniones. Las expresiones est\'an 
formadas por operadores y operandos; cualquier expresi\'on, incluida una
asignaci\'on o una llamada a una funci\'on puede ser una declaraci\'on.
Los punteros son suministrados para la aritm\'etica de direcciones 
independientemente de la m\'aquina. M\'as tarde, debido al surgimiento
de distintas variedades de C se defini\'o un est\'andar que hoy en 
d\'{\i}a est\'a representado por el ANSI C.

C suministra las construcciones elementales para un control de flujo 
requerido para una buena estructuraci\'on de los programas: agrupaci\'on de
declaraciones, toma de decisiones (\texttt{if-else}), selecci\'on de 
posibles casos (\texttt{switch}), lazos (\texttt{while, for, do}) y salida
de estos (\texttt{break}). 

Las funciones pueden devolver valores de tipos b\'asicos, estructuras, uniones
 o punteros. Las variables locales normalmente son \emph{autom\'aticas}.
La definici\'on de las funciones puede que no est\'en anidadas pero las
variables se pueden declarar en bloques estructurados. Las funciones pueden
existir en distintos ficheros que se compilar\'an por separado. Las variables 
pueden ser internas a la funci\'on o externas,  reconocidas
dentro del propio fichero o visibles para todo el programa.

Los preprocesos son macro sustituciones en programas de texto que incluyen 
otros ficheros fuente y una compilaci\'on condicional.

C relativamente es un lenguaje de \emph{bajo nivel}, pero esto es una 
definici\'on un tanto ambigua, significa que C trata con el mismo orden
los objetos tal como la mayor\'{\i}a de las computadoras, nombrando
caracteres, n\'umeros y direcciones. Esto puede ser combinado y transladado
con los operadores aritm\'eticos y l\'ogicos implantados en m\'aquinas
reales.

C no trata a las operaciones directamente con una composici\'on de objetos
como cadenas de caracteres, conjuntos, listas o vectores; no hay operaciones
que manipulen cadenas o vectores por completo, aunque las estructuras se
pueden copiar como unidades. Por \'ultimo no suministra facilidades de E/S, no
\footnote{entrada/salida o I/O del ingl\'es input/output}
existen declaraciones como READ o WRITE \footnote{LECTURA o ESCRITURA} y 
ninguna construcci\'on de acceso a ficheros. Esto se hace mediante llamadas
a funciones.

Con todo esto dicho hasta ahora vamos a comenzar con una introducci\'on 
de las bases del lenguaje que se desarrollar\'an con mayor amplitud en 
cap\'{\i}tulos posteriores. As\'{\i} daremos algunas nociones sobre distintos
conceptos y definiciones para que se familiarice con el lenguaje sin entrar
en detalles.

\section{Uso de C}

Los pasos que hay que seguir desde que se empieza a escribir un programa
hasta que se ejecuta son los siguientes:

\begin{itemize}
\item \textbf{Escribirlo:} El programa se tiene que escribir en un editor 
de testos est\'andar que no genere c\'odigos de control o caracteres no 
imprimibles (puedes elegir una gran variedad tales como emacs, vi, ed, etc. \
). Los ficheros fuente son aquellos que contiene el c\'odigo fuente que 
ser\'an leidos por el compilador. Si son peque\~nos ocupar\'an un fichero,
pero a medida que crecen ser\'a necesario distribuirlo en m\'as de uno. Los
ficheros tiene que acabar con la extensi\'on en \texttt{.c}.

\item \textbf{Compilarlo:} El compilador produce ficheros objeto, que contienen
c\'odigo objeto, e.d., ficheros con c\'odigo m\'aquina y que son utilizados
como entrada  al enlazador. En el caso de Linux se producen cuando la 
compilac\'on se realiza para m\'as de un fichero.
La forma de compilarlo es con el comando 
\texttt{cc}, \texttt{gcc} o con el \'ultimo compilador que se ha desarrollado
para Linux \texttt{egcs}. En el caso de un \'unico
fichero dar\'a como resultado un fichero ejecutable llamado \texttt{a.out}.
La extensi\'on de los ficheros objeto es \texttt{.o}.

\item \textbf{Enlazarlo:} El enlazador produce un fichero ejecutable a 
partir de los ficheros objeto. Los ficheros ejecutables contienen c\'odigo
m\'aquina y se pueden ejecutar directamente por el sistema operativo. La
palabra inglesa que da origen a la denominaci\'on de enlace es \emph{link}.

\item \textbf{Ejecutarlo:} El programa se puede ejecutar directamente
ejecutando su nombre (\texttt{./a.out}) en la l\'{\i}nea de comandos.

\end{itemize}

\section{Primeros Pasos}

La mejor forma de aprender C, como la mayor\'{\i}a de los lenguajes es 
escribir programas desde un principio para tener una noci\'on de estos
y una mayor comprensi\'on. ?`Y por que no?, empezaremos con el ejemplo
m\'as t\'{\i}pico de todos. La impresi\'on del texto \emph{hola, mundo}.

\begin{quotation}
\begin{verbatim}

#include <stdio.h>

main()
{
   printf("hola, mundo\n");
}

\end{verbatim}
\end{quotation}

Para ejecutar este programa ejecutamos el 
comando  \texttt{gcc fichero.c}. Si 
todo est\'a bien, se producir \'a la compilaci\'on
y dar\'a lugar a  un fichero ejecutable llamado
 \texttt{a.out}, que si lo ejecutas produce la salida

\begin{quotation}
\begin{verbatim}

hola, mundo

\end{verbatim}
\end{quotation}

en otros sistemas las reglas pueden ser diferentes, pero normalmente
en Linux es de esta manera.

Ahora vamos a explicar el programa. Un programa en C consiste en \emph{funciones}
y \emph{variables}. Una funci\'on contiene \emph{declaraciones} que especifican 
la forma en que se har\'a la computaci\'on. En el ejemplo, la funci\'on se 
llama \texttt{main}
\index{main} 
(principal) y es una funci\'on especial--el programa 
comienza ejecut\'andose
al principio de  \texttt{main}, lo que significa que cada programa tiene que tener 
una funci\'on  \texttt{main} en alg\'un lugar. Esta funci\'on normalmente llama a 
otras funciones para aydar a ejecutar su trabajo, de lo que has escrito y de las 
librer\'{\i}as que se te suministran.


Las funciones pueden comunicar datos suministrando una lista de valores que va entre 
par\'entesis, estos son llamados \emph{argumentos} hacia la funci\'on llamada. En 
este ejemplo la funci\'on no tiene argumentos, esto se indica con los par\'entesis
vac\'{\i}os.


La primera l\'{\i}nea del programa

\begin{quotation}
\begin{verbatim}

#include <stdio.h>

\end{verbatim}
\end{quotation}

\index{include}

le dice al compilador que incluya informaci\'on sobre la librer\'{\i}a de E/S
est\'andar; esta l\'{\i}nea aparece al comienzo de la mayor parte de los
 programas de C. Una l\'{\i}nea que comienza con \# en realidad no es una 
instrucci\'on del lenguaje C, sino que son l\'{\i}neas que se manipulan 
por el preprocesador. El preprocesador realiza algunas tareas antes de 
empezar a actuar con el compilador. Esta l\'{\i}nea incluye la informaci\'on 
que hay en el fichero \texttt{stdio.h} en el programa, en este fichero se 
encuentra la definci\'on de la  funci\'on \texttt{printf}. Si no 
pusi\'eramos este \texttt{include} en el programa el compilador nos 
dar\'{\i}a un error al no saber como es la funci\'on \texttt{printf}.


Las declaraciones de una funci\'on est\'an encerradas entre 
llaves \{ \}. La funci\'on \texttt{main} contiene una sola declaraci\'on,

\begin{quotation}
\begin{verbatim}

printf("hola, mundo\n");

\end{verbatim}
\end{quotation}

\index{printf}

A una funci\'on se la llama nombr\'andola, seguida por unos par\'entesis entre los 
que hay una lista de argumentos. Esta funci\'on imprime la salida, que en este caso
es una \emph{cadena de caracteres}, se llama  as\'{\i} a los caracteres que van entre
comillas dentro de la funci\'on.


En la cadena hay una secuencia al final de la forma 
\texttt{$\backslash$n}, a estos caracteres se
 les llama \emph{secuencias de 
escape} y en este caso  es la notaci\'on en C es el car\'acter de
\emph{car\'acter de nueva l\'{\i}nea}, avanza la salida al margen izquierdo en 
la siguiente l\'{\i}nea. Si no se coloca no habr\'a avance de l\'{\i}nea a la salida
del programa. Este ejemplo se podr\'{\i}a haber escrito como


\begin{quotation}
\begin{verbatim}

#include <stdio.h>

main()
{
   printf("hola,");
   printf("mundo");
   printf("\n");
}



\end{verbatim}
\end{quotation}

dando el mismo resultado, debido al caracter de nueva l\'{\i}nea que no se encuentra
hasta la \'ultima funci\'on \texttt{printf}. Adem\'as de este car\'acter hay otros que
se explicar\'an en otro momento.

\section{Variables y Expresiones Aritm\'eticas}

El siguiente programa usa la f\'ormula C = (5/9)(F-32) para imprimir una tabla 1 de conversi\'on 
de temperaturas entre Fahrenheit y Celsius.

\begin{quotation}
\begin{verbatim}

0      -17
20     -6
40     4
60     15
80     26
100    37
120    48
140    60
160    71
180    82
200    93
220    104
240    115
260    126
280    137
300    148


\end{verbatim}
\end{quotation}

Ahora vemos el programa que produce esta salida, el cual s\'olo lleva una funci\'on, que es 
\texttt{main}, la misma que en el anterior. Aqu\'{\i} introducimos nuevas ideas
como comentarios, declaraciones, variables, expresiones aritm\'eticas, lazos y salida
formateada.

\begin{quotation}
\begin{verbatim}

#include <stdio.h>

/*impresion de una tabla Fahrenheit-Celsius
   para farh = 0, 20, ..., 300 */
main()
{
   int fahr, celsius;
   int inferior, superior, paso;
   
   inferior = 0;     /*limite mas bajo en tabla*/
   superior = 300;   /*limite superior*/
   paso = 20;        /*tamano del paso*/
   
   fahr = inferior;
   while (fahr <= superior) {
      celsius = 5 * (fahr-32) / 9;
      printf("%d\t%d\n", fahr, celsius);
      fahr = fahr + paso;
   }
}

\end{verbatim}
\end{quotation}

Las dos l\'{\i}neas

\begin{quotation}
\begin{verbatim}

/*impresión de una tabla Fahrenheit-Celsius
   para farh = 0, 20, ..., 300 */

\end{verbatim}
\end{quotation}

son \emph{comentarios}. Cualquier car\'ater que est\'e encerrado entre
los s\'{\i}mbolos \texttt{/*} y \texttt{*/} es ignorado por el compilador;
se recurre a ellos para dar detalles sobre cualquier operaci\'on llevada 
a cabo en el programa, haci\'endolo m\'as legible por el lector. Los 
comentarios pueden aparecer en cualquier lugar.

En C, todas las variables \emph{tienen que declararse antes de ser usadas},
normalmente se hace al principio de la funci\'on, antes de cualquier declaraci\'on
ejecutable. Una \emph{declaraci\'on} nos comunica las propiedades de las 
variables, consiste en un tipo de variable y una lista de variables como en

\begin{quotation}
\begin{verbatim}

int fahr, celsius;
int inferior, superior, paso;

\end{verbatim}
\end{quotation}

El tipo \texttt{int} significa que las variables que vienen a continuaci\'on
son enteras, otro tipo ser\'{\i}a {texttt{float}, que es un n\'umero en 
coma flotante, e.d., un n\'umero con parte fraccionaria. Sobre los tipos 
de variables y sus longitudes se comentar\'a en el siguiente cap\'{\i}tulo.
Las variables son posiciones en memoria donde el valor de su contenido
puede variar a lo largo del programa.

De momento diremos que el tama\~no de los objetos es dependiente del tipo
de m\'aquina, lo que podr\'{\i}a hacerlo no portable.

La computaci\'on en el programa de conversi\'on de temperaturas comienza
con las \emph{sentencias de asignaci\'on}

\begin{quotation}
\begin{verbatim}

inferior = 0;
superior = 300;
paso = 20;
fahr = inferior;

\end{verbatim}
\end{quotation}

que pone a las variables sus valores iniciales. Las declaraciones individuales
terminan con un punto y coma ``\texttt{;}''.

Cada l\'{\i}nea del programa es computado de la misma forma,  usamos un lazo
que repite una por una las l\'{\i}neas de salida

\begin{quotation}
\begin{verbatim}

while (fahr <= superior) {
    ...
}

\end{verbatim}
\end{quotation}

\index{while}

El lazo \texttt{while} opera de la siguiente manera: La condici\'on entre 
par\'entesis es evaluada, si es cierta (\texttt{fahr} es menor o igual que
\texttt{superior}), el cuerpo del lazo (las tres declaraciones encerradas 
entre llaves) se ejecuta. Luego la condici\'on es reevaluada y si es cierta
se vuelve a ejecutar. Cuando el la condici\'on es falsa, el lazo termina y
la ejecuci\'on contin\'ua con la siguiente declaraci\'on que sigue al lazo.
En este programa no hay m\'as declaraciones, por lo que termina.
El cuerpo del un lazo \texttt{while} puede tener una o m\'as declaraciones 
encerradas entre llaves.

En este momento vamos a hacer una peque\~na sugerencia para el lector, y es que
es importante seguir unas pautas en la construcci\'on de un programa, e.d.,
que debemos utilizar una determinada tipograf\'{\i}a. Normalmente existen
programas en los que se puede editar un programa y ellos mismos van creando
una forma de situar cada l\'{\i}nea para hacerlo lo m\'as legible posible tal
como \texttt{jed}, \texttt{xwpe}, \ldots en Linux. Lo mejor es elegir una
forma, la que m\'as te guste y mantenerla.

Pasamos a la siguiente l\'{\i}nea

\begin{quotation}
\begin{verbatim}

celsius = 5 * (fahr-32) / 9;

\end{verbatim}
\end{quotation}

como a primera vista parece es simplemente la definici\'on de una funci\'on que
se computar\'a y nos dar\'a unos resultados; es de forma aproximada la 
f\'ormula de conversi\'on de temperatura entre Fahrenheit y Celsius. Una cosa
que en  un primer momento llama la atenci\'on es que primero se multiplica por
5 y despu\'es al final se divide por 9, en lugar de multiplicar directamente
por 5/9. Esto es porque en C, como en otros lenguajes, la divisi\'on de enteros
est\'a truncada: cualquier parte fraccionada es descartada. Al ser 5 y 9 dos
enteros, 5/9 nos dar\'{\i}a como resultado 0 y la conversi\'on de todas las 
temperaturas ser\'{\i}a cero.

Este ejemplo tambi\'en nos muestra algo m\'as de la funci\'on \texttt{printf},
esta es una funci\'on de prop\'osito general que nos da la salida de una 
funci\'on formateada, que se describir\'a con m\'as detalle en posteriores
cap\'{\i}tulos. Su primer argumento ya es conocido por el programa anterior,
se trata de una cadena de caracteres que ser\'an impresos en este caso por 
pantalla. Pero entre ellos hay unos caracteres distintos en un principio a 
todos los dem\'as, que son dos s\'{\i}mbolos de la forma \texttt{\%d}.
Su prop\'osito es provocar la salida de las variables que siguen a 
continuaci\'on despu\'es de las comillas, e.d., el valor que tendr\'an en este
paso. as\'{\i} el primer  \texttt{\%d} corresponde a la variable \texttt{fahr}
y el segundo a la variable \texttt{celsius}. Estos argumentos son del tipo
entero (por que lo que los sigue es una \texttt{d}), pero hay otros como
 \texttt{\%f},  \texttt{\%c}, que corresponde a coma flotante y tipo 
car\'acter respectivamente. M\'as tarde en el siguiente cap\'{\i}tulo se 
comentar\'an con m\'as amplitud.

En este programa nos encontramos con algunos problemas. El primero es que la
salida no es muy vistosa y podr\'{\i}a estar mejor formateada como por ejemplo,
alineada a la derecha. Esto se puede mejorar f\'acilmente con m\'as argumentos
sobre \texttt{\%d}. Se podr\'{\i}a hacer

\begin{quotation}
\begin{verbatim}

printf(``%d3d %6d\n'', fahr, celsius);

\end{verbatim}
\end{quotation}

que imprime los primeros n\'umeros de cada l\'{\i}nea en un campo de amplitud 
de tres d\'{\i}gitos y los segundos en un campo de seis d\'{\i}gitos, tal como

\begin{quotation}
\begin{verbatim}

  0   -17
 20    -6
 40     4
 60    15
 80    26
100    37
...

\end{verbatim}
\end{quotation}

El siguiente problema es que hemos usado aritm\'etica de enteros, y las
temperaturas Celsius no est\'an ajustadas; por ejemplo,  0  grados  F 
ser\'{\i}an -17.8  grados
 C y no -17. Para solucionar este problema utilizamos la aritm\'etica
de coma flotante en lugar de los enteros. Esto requiere algunos cambios 
en el programa. Vemos una segunda versi\'on:

\begin{quotation}
\begin{verbatim}

#include <stdio.h>

/*impresión de una tabla Fahrenheit-Celsius
   para farh = 0, 20, ..., 300, versión de float */
main()
{
   float fahr, celsius;
   int inferior, superior, paso;
   
   inferior = 0;     /*limite más bajo de la tabla de temperatura*/
   superior = 300;   /*limite superior*/
   paso = 20;        /*tamaño del paso*/
   
   fahr = inferior;
   while (fahr <= superior) {
      celsius = (5.0/9.0) * (fahr-32.0);
      printf("%3.0f %6.1f\n", fahr, celsius);
      fahr = fahr + paso;
   }
}

\end{verbatim}
\end{quotation}

Aqu\'{\i} \texttt{fahr} y \texttt{celsius} son declaradas como \texttt{float}, 
y la f\'ormula se escribe de una manera m\'as natural. No se va a usar la forma
5/9 porque puede dar una divisi\'on de enteros dando lugar al valor de cero.
Un punto decimal en una constante indica que es coma flotante por lo que
5.0/9.0 no es truncado debido a que es el resultado de dos valores fraccionarios.

Si un operador aritm\'etico tiene operandos enteros, entonces se ejecuta una
operaci\'on de enteros; si tiene un operando de coma flotante y otro entero, este
\'ultimo se transforma en coma flotante antes de la ejecuci\'on de la operaci\'on.
as\'{\i} al escribir \texttt{(fahr-32)}, el 32 autom\'aticamente se convierte
en coma flotante. Esto se cubrir\'a en el siguiente cap\'{\i}tulo.

La especificaci\'on de conversi\'on \texttt{\%3.0f} en \texttt{printf} nos dice 
que un n\'umero de coma flotante ser\'a imprimido con al menos tres caracteres 
de amplitud, sin parte fraccionaria y sin punto decimal. \texttt{\%6.1f} describe
otro n\'umero que se imprime con al menos seis d\'{\i}gitos, con un d\\'{\i}gito
despu\'es del punto decimal. La salida de este programa es:

\begin{quotation}
\begin{verbatim}

  0   -17.8
 20    -6.7
 40     4.4
...

\end{verbatim}
\end{quotation}

Entre otros, \texttt{printf} reconoce \texttt{\%o} para octal, \texttt{\%x} para 
hexadecimal, \texttt{\%c} para car\'acter y otros que se describen en el siguiente
cap\'{\i}tulo.

\begin{itemize}

\item \textbf{Ejercicio 1}. Modifica el programa de temperaturas para que imprima
una cabecera encima de la tabla.

\item \textbf{Ejercicio 2}. Escribe un programa que imprima la tabla correspondiente
de transformaci\'on de Celsius en Fahrenheit.

\end{itemize}

\include{capitulo2}

\end{document}
