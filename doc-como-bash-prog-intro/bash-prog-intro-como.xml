<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V4.2//EN" "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">

<article>

<articleinfo>

<title>Programación en BASH - COMO de introducción</title>

<author>
	<firstname>Mike</firstname>
	<surname>G</surname>
	<affiliation><address><email>mikkey AT dynamo.com.ar</email></address></affiliation>
</author>
<othercredit>
	<firstname>Gabriel</firstname>
	<surname>Rodríguez Alberich</surname>
	<affiliation><address><email>chewie@asef.us.es</email></address></affiliation>
	<contrib>Traducción</contrib>
</othercredit>

<pubdate> 	jueves, 27 de julio de 2000, a las 09:36:18 ART
    </pubdate>

<abstract>

<para>
     Este artículo pretende ayudarle a comenzar a programar shell
    scripts a un nivel básico/intermedio. No pretende ser un documento
    avanzado (vea el título). NO soy un experto ni un gurú de la
    programación en shell. Decidí escribir esto porque aprenderé mucho
    con ello y puede serle útil a otras personas. Cualquier aportación
    será apreciada, especialmente en forma de parche :)
    
</para>

</abstract>

</articleinfo>

<sect1>
<title>Introducción</title>

<sect2>
<title>Obteniendo la última versión</title>

<para>
<ulink
url="http://www.linuxdoc.org/HOWTO/Bash-Prog-Intro-HOWTO.html"
>http://www.linuxdoc.org/HOWTO/Bash-Prog-Intro-HOWTO.html</ulink
>
</para>

</sect2>

<sect2>
<title>Requisitos
          </title>

<para>
 Le será útil tener una cierta familiaridad con la línea de 
comandos de GNU/Linux y con los conceptos básicos de la programación.       
Aunque esto no es una introducción a la programación, explica   
(o al menos lo intenta) muchos conceptos básicos.
</para>

<para>
 
</para>

</sect2>

<sect2>
<title>Usos de este documento
          </title>

<para>
 Este documento intenta ser útil en las siguientes 
situaciones

<itemizedlist>
<listitem>

<para>
 Si tiene alguna idea de programación y quiere empezar a
programar algunos shell scripts.
</para>
</listitem>
<listitem>

<para>
 Si tiene una idea vaga de programar en shell y quiere algún
tipo de referencia.
</para>
</listitem>
<listitem>

<para>
 Si quiere ver algunos scripts y comentarios para empezar a
escribir los suyos propios.
</para>
</listitem>
<listitem>

<para>
 Si está migrando desde DOS/Windows (o ya lo ha hecho) y quiere
hacer procesos "por lotes".
</para>
</listitem>
<listitem>

<para>
 Si es un completo novato y lee todo COMO disponible.
</para>
</listitem>

</itemizedlist>

</para>

</sect2>

</sect1>

<sect1>
<title>Scripts muy sencillos
    </title>

<para>
 Este COMO tratará de darle algunos consejos sobre la programación
de shell scripts, basándose profundamente en ejemplos.
</para>

<para>
 En esta sección encontrará varios scripts pequeños que
esperanzadamente le ayudarán a entender algunas técnicas.
</para>

<sect2>
<title>Típico script `hola mundo'
	</title>

<para>

<screen>
	  #!/bin/bash          
	  echo Hola Mundo 
	
</screen>

</para>

<para>
 
</para>

<para>
 Este script tiene sólo dos líneas.
La primera le indica al sistema qué programa 
usar para ejecutar el fichero.
</para>

<para>
 La segunda línea es la única acción realizada por este
script, que imprime 'Hola Mundo' en la terminal.
</para>

<para>
 Si le sale algo como <emphasis remap="it">./hello.sh: Comando desconocido.</emphasis>,
probablemente la primera línea, '#!/bin/bash', está mal. Ejecute
<literal remap="tt">whereis bash</literal>, o vea 'encontrando el bash' para saber cómo
debe escribir esta línea.
</para>

</sect2>

<sect2>
<title>Un script de copia de seguridad muy simple
        </title>

<para>

<screen>
	#!/bin/bash          
	tar -cZf /var/my-backup.tgz /home/yo/
	
</screen>

</para>

<para>
 En este script, en vez de imprimir un mensaje en la terminal,
creamos un tar-ball del directorio home de un usuario. Esto NO
pretende ser un script útil; más tarde se ofrece un script de
copia de seguridad más útil.
</para>

</sect2>

</sect1>

<sect1>
<title>Todo sobre redirección
	</title>

<sect2>
<title>Teoría y referencia rápida
	</title>

<para>
 Existen 3 descriptores de ficheros: stdin, stdout y stderr 
(std=estándar).
</para>

<para>
Básicamente, usted puede:

<orderedlist>
<listitem>

<para>
 redirigir stdout a un fichero
</para>
</listitem>
<listitem>

<para>
 redirigir stderr a un fichero
</para>
</listitem>
<listitem>

<para>
 redirigir stdout a stderr 
</para>
</listitem>
<listitem>

<para>
 redirigir stderr a stdout 
</para>
</listitem>
<listitem>

<para>
 redirigir stderr y stdout a un fichero
</para>
</listitem>
<listitem>

<para>
 redirigir stderr y stdout a stdout 
</para>
</listitem>
<listitem>

<para>
 redirigir stderr y stdout a stderr
</para>
</listitem>

</orderedlist>

El número 1 'representa' a stdout, y 2 a stderr.
</para>

<para>
 Una pequeña nota para ver todo esto: con el comando less puede
visualizar stdout (que permanecerá en el búfer) y stderr, que se
imprimirá en la pantalla, pero será borrado si intenta leer el
búfer.
</para>

</sect2>

<sect2>
<title>Ejemplo: stdout a un fichero
	</title>

<para>
 Esto hará que la salida de un programa se escriba en un fichero.

<screen>
	ls -l &gt; ls-l.txt
	
</screen>

En este caso, se creará un fichero llamado 'ls-l.txt' que contendrá lo
que se vería en la pantalla si escribiese el comando 'ls -l' y lo
ejecutase.
</para>

</sect2>

<sect2>
<title>Ejemplo: stderr a un fichero
	</title>

<para>
 Esto hará que la salida stderr de un programa se escriba en un
fichero.

<screen>
	grep da * 2&gt; errores-de-grep.txt
	
</screen>

En este caso, se creará un fichero llamado 'errores-de-grep.txt' que
contendrá la parte stderr de la salida que daría el comando 'grep da *'.
</para>

</sect2>

<sect2>
<title>Ejemplo: stdout a stderr
	</title>

<para>
 Esto hará que la salida stdout de un programa se escriba en el mismo 
descriptor de fichero que stderr.

<screen>
	grep da * 1&gt;&amp;2 
	
</screen>

En este caso, la parte stdout del comando se envía a stderr; puede
observar eso de varias maneras.
</para>

</sect2>

<sect2>
<title>Ejemplo: stderr a stdout
	</title>

<para>
 Esto hará que la salida stderr de un programa se escriba en el mismo
descriptor de fichero que stdout.

<screen>
	grep * 2&gt;&amp;1
	
</screen>

En este caso, la parte stderr del comando se envía a stdout. Si hace una 
tubería con less, verá que las líneas que normalmente 'desaparecen' (al
ser escritas en stderr), ahora permanecen (porque están en el stdout).
</para>

</sect2>

<sect2>
<title>Ejemplo: stderr y stdout a un fichero
	</title>

<para>
Esto colocará toda la salida de un programa en un fichero. A veces,
esto es conveniente en las entradas del cron, si quiere que un comando se
ejecute en absoluto silencio.

<screen>
	rm -f $(find / -name core) &amp;&gt; /dev/null 
	
</screen>

Esto (pensando en la entrada del cron) eliminará todo archivo llamado 
`core' en cualquier directorio. Tenga en cuenta que tiene que estar muy 
seguro de lo que hace un comando si le va a eliminar la salida.
</para>

</sect2>

</sect1>

<sect1>
<title>Tuberías
	</title>

<para>
 Esta sección explica de una manera muy sencilla y práctica cómo
utilizar tuberías, y por qué querría utilizarlas.
</para>

<sect2>
<title>Qué son y por qué querrá utilizarlas
		</title>

<para>
 Las tuberías le permiten utilizar (muy sencillo, insisto) la salida 
de un programa como la entrada de otro.
</para>

</sect2>

<sect2>
<title>Ejemplo: una tubería sencilla con sed
	</title>

<para>
 Ésta es una manera muy sencilla de utilizar tuberías.

<screen>
	ls -l | sed -e "s/[aeio]/u/g"	
	
</screen>

En este caso, ocurre lo siguiente: primero se ejecuta el comando ls -l,
y luego su salida, en vez de imprimirse en la pantalla, se envía
(entuba) al programa sed, que imprime su salida correspondiente.
</para>

</sect2>

<sect2>
<title>Ejemplo: una alternativa a ls -l *.txt 	</title>

<para>
 Probablemente ésta es una manera más difícil de hacer un ls -l
*.txt, pero se muestra para ilustrar el funcionamiento de las tuberías,
no para resolver ese dilema.

<screen>
	ls -l | grep "\.txt$"
	
</screen>

En este caso, la salida del programa ls -l se envía al programa grep,
que imprimirá las líneas que concuerden con la regex
(expresión regular) "\.txt$".
</para>

</sect2>

</sect1>

<sect1>
<title>Variables
        </title>

<para>
 Puede usar variables como en cualquier otro lenguaje de
programación. No existen tipos de datos. Una variable de bash puede
contener un número, un caracter o una cadena de caracteres.
</para>

<para>
 No necesita declarar una variable. Se creará sólo con asignarle un
valor a su referencia.
</para>

<sect2>
<title>Ejemplo: ¡Hola Mundo! utilizando variables
            </title>

<para>
 

<screen>
	    #!/bin/bash          
	    CAD="¡Hola Mundo!"
	    echo $CAD    
	    
</screen>

</para>

<para>
 La segunda línea crea una variable llamada STR y le asigna la
cadena "¡Hola Mundo!". Luego se recupera el VALOR de esta variable
poniéndole un '$' al principio. Por favor, tenga en cuenta (¡inténtelo!)
que si no usa el signo '$', la salida del programa será diferente, y
probablemente no sea lo que usted quería.
</para>

</sect2>

<sect2>
<title>Ejemplo: Un script de copia de seguridad muy simple (algo mejor)
	   </title>

<para>
 

<screen>
	   #!/bin/bash          
	   OF=/var/mi-backup-$(date +%Y%m%d).tgz
	   tar -cZf $OF /home/yo/
	   
</screen>

</para>

<para>
 Este script introduce algo nuevo. Antes que nada, debería
familiarizarse con la creación y asignación de variable de la línea 2.
Fíjese en la expresión '$(date +%Y%m%d)'. Si ejecuta el script se dará
cuenta de que ejecuta el comando que hay dentro de los paréntesis,
capturando su salida.
</para>

<para>
 Tenga en cuenta que en este script, el fichero de salida será
distinto cada día, debido al formato pasado al comando date (+%Y%m%d).
Puede cambiar esto especificando un formato diferente.
</para>

<para>
 Algunos ejemplos más:
</para>

<para>
 echo ls
</para>

<para>
 echo $(ls)
</para>

</sect2>

<sect2>
<title>Variables locales
	</title>

<para>
 Las variables locales pueden crearse utilizando la palabra clave
<emphasis remap="it">local</emphasis>.
</para>

<para>

<screen>
		#!/bin/bash
		HOLA=Hola
		function hola {
			local HOLA=Mundo
			echo $HOLA
		}
		echo $HOLA
		hola
		echo $HOLA
	
</screen>

</para>

<para>
 Este ejemplo debería bastar para mostrarle el uso de una variable
local.
</para>

</sect2>

</sect1>

<sect1>
<title>Estructuras Condicionales
    </title>

<para>
 Las estructuras condicionales le permiten decidir si se realiza una
acción o no; esta decisión se toma evaluando una expresión.
</para>

<sect2>
<title>Pura teoría
        </title>

<para>
 Los condicionales tienen muchas formas. La más básica es:
<emphasis remap="bf">if</emphasis> <emphasis remap="it">expresión</emphasis> <emphasis remap="bf">then</emphasis> <emphasis remap="it">sentencia</emphasis>
donde 'sentencia' sólo se ejecuta si 'expresión' se evalúa como
verdadera. '2&lt;1' es una expresión que se evalúa falsa, mientras
que '2&gt;1' se evalúa verdadera.
</para>

<para>
 Los condicionales tienen otras formas, como:
<emphasis remap="bf">if</emphasis> <emphasis remap="it">expresión</emphasis> 
<emphasis remap="bf">then</emphasis> <emphasis remap="it">sentencia1</emphasis> <emphasis remap="bf">else</emphasis> <emphasis remap="it">sentencia2</emphasis>.
Aquí 'sentencia1' se ejecuta si 'expresión' es verdadera. De otra
manera se ejecuta 'sentencia2'.
</para>

<para>
 Otra forma más de condicional es:
<emphasis remap="bf">if</emphasis> <emphasis remap="it">expresión1</emphasis> 
<emphasis remap="bf">then</emphasis> <emphasis remap="it">sentencia1</emphasis> 
<emphasis remap="bf">else if</emphasis> <emphasis remap="it">expresión2</emphasis> <emphasis remap="bf">then</emphasis> <emphasis remap="it">sentencia2</emphasis> 
<emphasis remap="bf">else</emphasis> <emphasis remap="it">sentencia3</emphasis>.
En esta forma sólo se añade "ELSE IF 'expresión2' THEN 'sentencia2'",
que hace que sentencia2 se ejecute si expresión2 se evalúa verdadera.
El resto es como puede imaginarse (véanse las formas anteriores).
</para>

<para>
 Unas palabras sobre la sintaxis:
</para>

<para>
 La base de las construcciones 'if' es ésta:
</para>

<para>
 if &lsqb;expresión];
</para>

<para>
 then
</para>

<para>
    código si 'expresión' es verdadera.
</para>

<para>
 fi
</para>

</sect2>

<sect2>
<title>Ejemplo: Ejemplo básico de condicional if .. then
            </title>

<para>
 

<screen>
	    #!/bin/bash
	    if [ "petete" = "petete" ]; then
	       echo expresión evaluada como verdadera
	    fi
	    
</screen>

</para>

<para>
 El código que se ejecutará si la expresión entre corchetes es
verdadera se encuentra entre la palabra 'then' y la palabra 'fi', que
indica el final del código ejecutado condicionalmente.
</para>

</sect2>

<sect2>
<title>Ejemplo: Ejemplo básico de condicional if .. then ... else
	    </title>

<para>

<screen>
	    #!/bin/bash	    if [ "petete" = "petete" ]; then
	       echo expresión evaluada como verdadera
	    else
	       echo expresión evaluada como falsa
	    fi
	    
</screen>

</para>

</sect2>

<sect2>
<title>Ejemplo: Condicionales con variables
	    </title>

<para>
 

<screen>
	    #!/bin/bash
	    T1="petete"
	    T2="peteto"
	    if [ "$T1" = "$T2" ]; then
	        echo expresión evaluada como verdadera
	    else
	        echo expresión evaluada como falsa
	    fi
	    
</screen>

</para>

</sect2>

<sect2>
<title>Ejemplo: comprobando si existe un fichero
	    </title>

<para>
 un agradecimiento más a mike

<screen>
	    #!/bin/bash
	    FILE=~/.basrc
	    if [ -f $FILE ]; then
	        echo el fichero $FILE existe
	    else
	        echo fichero no encontrado
	    fi
	    if [ 'test -f $FILE']
	    
</screen>

</para>

</sect2>

</sect1>

<sect1>
<title>Los bucles for, while y until
    </title>

<para>
 En esta sección se encontrará con los bucles for, while y until.
</para>

<para>
 El bucle <emphasis remap="bf">for</emphasis> es distinto a los de otros lenguajes de
programación. Básicamente, le permite iterar sobre una serie de
`palabras' contenidas dentro de una cadena.
</para>

<para>
 El bucle <emphasis remap="bf">while</emphasis> ejecuta un trozo de códico si la expresión
de control es verdadera, y sólo se para cuando es falsa (o se encuentra
una interrupción explícita dentro del código en ejecución).
</para>

<para>
 El bucle <emphasis remap="bf">until</emphasis> es casi idéntico al bucle loop, excepto en
que el código se ejecuta mientras la expresión de control se evalúe como
falsa.
</para>

<para>
 Si sospecha que while y until son demasiado parecidos, está en
lo cierto.
</para>

<sect2>
<title>Por ejemplo
        </title>

<para>
 

<screen>
        #!/bin/bash
        for i in $( ls ); do
            echo item: $i
        done
        
</screen>

</para>

<para>
 
</para>

<para>
 En la segunda línea declaramos i como la variable que
recibirá los diferentes valores contenidos en $( ls ).
</para>

<para>
 La tercera línea podría ser más larga o podría haber más
líneas antes del done (4).
</para>

<para>
 `done' (4) indica que el código que ha utilizado el valor de
$i ha acabado e $i puede tomar el nuevo valor.
</para>

<para>
 Este script no tiene mucho sentido, pero una manera más útil
de usar el bucle for sería hacer que concordasen sólo ciertos
ficheros en el ejemplo anterior.
</para>

</sect2>

<sect2>
<title>for tipo-C
	</title>

<para>
 Fiesh sugirió añadir esta forma de bucle. Es un bucle for más
parecido al for de C/perl...

<screen>
	#!/bin/bash
	for i in `seq 1 10`;
	do
		echo $i
	done	
	
</screen>

</para>

</sect2>

<sect2>
<title>Ejemplo de while
         </title>

<para>
 
<screen>
         #!/bin/bash 
         CONTADOR=0
         while [  $CONTADOR -lt 10 ]; do
             echo El contador es $CONTADOR
             let CONTADOR=CONTADOR+1 
         done
         
</screen>

</para>

<para>
 Este script 'emula' la conocida (C, Pascal, perl, etc) estructura
`for'.
</para>

</sect2>

<sect2>
<title>Ejemplo de until
         </title>

<para>
 
<screen>
         #!/bin/bash 
         CONTADOR=20
         until [  $CONTADOR -lt 10 ]; do
             echo CONTADOR $CONTADOR
             let CONTADOR-=1
         done
	 
</screen>

</para>

</sect2>

</sect1>

<sect1>
<title>Funciones
     </title>

<para>
 Como en casi todo lenguaje de programación, puede utilizar
funciones para agrupar trozos de código de una manera más lógica, o
practicar el divino arte de la recursión.
</para>

<para>
 Declarar una función es sólo cuestión de escribir function
mi_func &lcub; mi_código &rcub;.
</para>

<para>
 Llamar a la función es como llamar a otro programa, sólo hay que
escribir su nombre.
</para>

<sect2>
<title>Ejemplo de funciones
           </title>

<para>
 
<screen>
	   #!/bin/bash 
	   function salir {
	       exit
	   }
	   function hola {
	       echo ¡Hola!
	   }
	   hola
	   salir
	   echo petete 
	   
</screen>

</para>

<para>
 Las líneas 2-4 contienen la función 'salir'. Las líneas 5-7
contienen la función 'hola'. Si no está completamente seguro de lo que
hace este script, por favor, ¡pruébelo!.
</para>

<para>
 Tenga en cuenta que una función no necesita que sea declarada en
un orden específico.
</para>

<para>
 Cuando ejecute el script se dará cuenta de que: primero se llama
a la función 'hola', luego a la función 'quit', y el programa nunca llega
a la línea 10.
</para>

</sect2>

<sect2>
<title>Ejemplo de funciones con parámetros
           </title>

<para>
 
<screen>
		#!/bin/bash 
		function salir {
 		   exit
		}  
		function e {
		    echo $1 
		}  
		e Hola
		e Mundo
		salir
		echo petete 

	   
</screen>

</para>

<para>
 Este script es casi idéntico al anterior. La diferencia principal
es la función 'e'. Esta función imprime el primer argumento que recibe.
Los argumentos, dentro de las funciones, son tratados de la misma manera
que los argumentos suministrados al script.
</para>

</sect2>

</sect1>

<sect1>
<title>Interfaces de usuario
     </title>

<sect2>
<title>Utilizando select para hacer menús sencillos
	   </title>

<para>

<screen>
	   #!/bin/bash
	   OPCIONES="Hola Salir"
	   select opt in $OPCIONES; do
	       if [ "$opt" = "Salir" ]; then
	   	echo done
	   	exit
	       elif [ "$opt" = "Hola" ]; then
	   	echo Hola Mundo
	       else
	   	clear
	   	echo opción errónea
	       fi
	   done
	  
</screen>
 
</para>

<para>
 Si ejecuta este script verá que es el sueño de un 
programador para hacer menús basados en texto. Probablemente se dará 
cuenta de que es muy similar a la construcción 'for', sólo que en vez de 
iterar para cada 'palabra' en $OPCIONES, se lo pide al usuario.
</para>

</sect2>

<sect2>
<title>Utilizando la línea de comandos
         </title>

<para>

<screen>
	  #!/bin/bash        
          if [ -z "$1" ]; then 
              echo uso: $0 directorio
              exit
          fi
          SRCD=$1
          TGTD="/var/backups/"
          OF=home-$(date +%Y%m%d).tgz
          tar -cZf $TGTD$OF $SRCD
	 
</screen>

</para>

<para>
 Lo que hace este script debería estar claro para usted. La 
expresión del primer condicional comprueba si el programa ha recibido 
algún argumento ($1) y sale si no lo ha recibido, mostrándole al usuario 
un pequeño mensaje de uso. El resto del script debería estar claro.
</para>

</sect2>

</sect1>

<sect1>
<title>Miscelánea
         </title>

<sect2>
<title>Leyendo información del usuario
         </title>

<para>
 En muchas ocasiones, puede querer solicitar al usuario
alguna información, y existen varias maneras para hacer esto. Ésta es
una de ellas:

<screen>
		#!/bin/bash
		echo Por favor, introduzca su nombre
		read NOMBRE
		echo "¡Hola $NOMBRE!"
	
</screen>

</para>

<para>
 Como variante, se pueden obtener múltiples valores con read. Este
ejemplo debería clarificarlo.

<screen>
		#!/bin/bash
		echo Por favor, introduzca su nombre y primer apellido
		read NO AP 
		echo "¡Hola $AP, $NO!"
	
</screen>

</para>

</sect2>

<sect2>
<title>Evaluación aritmética
         </title>

<para>
 Pruebe esto en la línea de comandos (o en una shell):
</para>

<para>
 echo 1 + 1
</para>

<para>
 Si esperaba ver '2', quedará desilusionado. ¿Qué hacer si quiere
que BASH evalúe unos números? La solución es ésta:
</para>

<para>
 echo $((1+1))
</para>

<para>
 Esto producirá una salida más 'lógica'. Esto se hace para evaluar
una expresión aritmética. También puede hacerlo de esta manera:
</para>

<para>
 echo $&lsqb;1+1]
</para>

<para>
 Si necesita usar fracciones, u otras matemáticas, puede utilizar bc
para evaluar expresiones aritméticas.
</para>

<para>
 Si ejecuta "echo $&lsqb;3/4]" en la línea de comandos, devolverá 0,
porque bash sólo utiliza enteros en sus respuestas. Si ejecuta "echo
3/4|bc -l", devolverá 0.75.
</para>

</sect2>

<sect2>
<title>Encontrando el bash
        </title>

<para>
 De un mensaje de mike (vea los agradecimientos):
</para>

<para>
 siempre usas #!/bin/bash .. a lo mejor quieres dar un ejemplo
</para>

<para>
 de cómo saber dónde encontrar el bash.
</para>

<para>
 `locate bash' es preferible, pero no todas las máquinas
</para>

<para>
 tienen locate.
</para>

<para>
 `find ./ -name bash' desde el directorio raíz funcionará,
</para>

<para>
 normalmente.
</para>

<para>
 Sitios donde poder buscar:
</para>

<para>
         ls -l /bin/bash
</para>

<para>
         ls -l /sbin/bash
</para>

<para>
         ls -l /usr/local/bin/bash
</para>

<para>
         ls -l /usr/bin/bash
</para>

<para>
         ls -l /usr/sbin/bash
</para>

<para>
         ls -l /usr/local/sbin/bash
</para>

<para>
 (no se me ocurre ningún otro directorio...  lo he encontrado
</para>

<para>
 la mayoría de estos sitios en sistemas diferentes).
</para>

<para>
 También puedes probar 'which bash'.
</para>

</sect2>

<sect2>
<title>Obteniendo el valor devuelto por un programa
        </title>

<para>
 En bash, el valor de retorno de un programa se guarda en una
variable especial llamada $?.
</para>

<para>
 Esto ilustra cómo capturar el valor de retorno de un programa. Supongo
que el directorio <emphasis remap="it">dada</emphasis> no existe. (Esto también es sugerencia de
Mike).

<screen>
	#!/bin/bash
	cd /dada &amp;&gt; /dev/null
	echo rv: $?
	cd $(pwd) &amp;&gt; /dev/null
	echo rv: $?
	 
</screen>

</para>

</sect2>

<sect2>
<title>Capurando la salida de un comando
         </title>

<para>
 Este pequeño script muestra todas las tablas de todas las
bases de datos (suponiendo que tenga MySQL instalado).
Considere también cambiar el comando 'mysql' para que use un nombre de
usuario y clave válidos.

<screen>
	#!/bin/bash
	DBS=`mysql -uroot  -e"show databases"`
	for b in $DBS ;
	do
	        mysql -uroot -e"show tables from $b"
	done
	
</screen>

</para>

</sect2>

</sect1>

<sect1>
<title>Tablas
    </title>

<sect2>
<title>Operadores de comparación de cadenas
    </title>

<para>
<variablelist>

<varlistentry>
<term>s1 = s2</term>
<listitem>
<para>
s1 coincide con s2
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>s1 != s2</term>
<listitem>
<para>
s1 no coincide con s2
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>s1 &#60; s2</term>
<listitem>
<para>
s1 es alfabéticamente anterior a s2, con el 
<emphasis remap="it">locale</emphasis> actual
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>s1 &#62; s2</term>
<listitem>
<para>
s1 es alfabéticamente posterior a s2, con el 
<emphasis remap="it">locale</emphasis> actual
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>-n s1</term>
<listitem>
<para>
s1 no es nulo (contiene uno o más caracteres)
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>-z s1</term>
<listitem>
<para>
s1 es nulo
</para>
</listitem>
</varlistentry>
</variablelist>
</para>

</sect2>

<sect2>
<title>Ejemplo de comparación de cadenas
	</title>

<para>
 Comparando dos cadenas

<screen>
	#!/bin/bash
	S1='cadena'
	S2='Cadena'
	if [ $S1!=$S2 ];
	then
	        echo "S1('$S1') no es igual a S2('$S2')"
	fi
	if [ $S1=$S1 ];
	then
	        echo "S1('$S1') es igual a S1('$S1')"
	fi
	
</screen>

</para>

<para>
 Cito aquí el consejo de un correo enviado por Andreas Beck, referido
al uso de <emphasis remap="it">if &lsqb; $1 = $2 ]</emphasis>.
</para>

<para>
  Esto no es buena idea, porque si $S1 o $S2 son vacíos, aparecerá un
<emphasis remap="it">parse error</emphasis>. Es mejor: x$1=x$2 or "$1"="$2"
</para>

</sect2>

<sect2>
<title>Operadores aritméticos
    </title>

<para>
 + (adición)
</para>

<para>
 - (sustracción)
</para>

<para>
 * (producto)
</para>

<para>
 / (división)
</para>

<para>
 % (módulo)
</para>

</sect2>

<sect2>
<title>Operadores relacionales aritméticos
    </title>

<para>
 -lt (&#60;) 
</para>

<para>
 -gt (&#62;)
</para>

<para>
 -le (&#60;=)
</para>

<para>
 -ge (&#62;=)
</para>

<para>
 -eq (==)
</para>

<para>
 -ne (!=)
</para>

<para>
 Los programadores de C tan sólo tienen que corresponder el
operador con su paréntesis.
</para>

</sect2>

<sect2>
<title>Comandos útiles
         </title>

<para>
 Esta sección ha sido reescrita por Kees (véanse agradecimientos)
</para>

<para>
 Algunos de estos comandos contienen lenguajes de programación
completos. Sólo se explicarán las bases de estos comandos. Para una
descripción más detallada, eche un vistazo a las páginas man de cada uno.
</para>

<para>
<emphasis remap="bf">sed</emphasis> (editor de flujo)
</para>

<para>
 Sed es un editor no interactivo. En vez de alterar un fichero 
moviendo el cursor por la pantalla, se utiliza una serie de instrucciones 
de edición de sed, y el nombre del fichero a editar. También se puede 
describir a sed como un filtro. Miremos algunos ejemplos:
</para>

<para>

<screen>
	$sed 's/a_sustituir/sustituto/g' /tmp/petete
	
</screen>

</para>

<para>
 Sed sustituye la cadena 'a_sustituir' por la cadena 'sustituto', 
leyendo del fichero /tmp/petete. El resultado se envía a stdout 
(normalmente la consola), pero se puede añadir '&#62; captura' al final de la 
línea de arriba para que sed envíe la salida al fichero 'capture'.
</para>

<para>

<screen>
   	$sed 12, 18d /tmp/petete
	
</screen>
	
</para>

<para>
 Sed muestra todas las líneas de /tmp/petete excepto la 12 y la 
18. El fichero original no queda alterado por este comando.
</para>

<para>
<emphasis remap="bf">awk</emphasis> (manipulación de bases de datos, extracción y proceso de texto)
</para>

<para>
 Existen muchas implementaciones del lenguaje de programacin AWK 
(los intérpretes más conocidos son gawk de GNU, y el 'nuevo awk' mawk). 
El principio es sencillo: AWK busca un patrón, y por cada patrón de 
búsqueda que coincida, se realiza una acción.
</para>

<para>
 Si tenemos un fichero /tmp/petete con las siguientes líneas:
</para>

<para>
 <emphasis remap="it">"prueba123</emphasis>
</para>

<para>
 <emphasis remap="it">prueba</emphasis>
</para>

<para>
 <emphasis remap="it">pprruueebbaa"</emphasis>
</para>

<para>
 y ejecutamos:

<screen>
	$awk '/prueba/ {print}' /tmp/petete
	
</screen>

</para>

<para>
 test123
</para>

<para>
 test
</para>

<para>
 El patrón que busca AWK es 'prueba' y la acción que realiza
cuando encuentra una línea en /tmp/petete con la cadena 'prueba' es
`print'.
</para>

<para>

<screen>
	$awk '/prueba/ {i=i+1} END {print i}' /tmp/petete
	
</screen>

</para>

<para>
 3
</para>

<para>
 Cuando se utilizan muchos patrones, se puede reemplazar el texto
entre comillas por '-f fichero.awk', y poner todos los patrones y
acciones en 'fichero.awk'.
</para>

<para>
<emphasis remap="bf">grep</emphasis> (impresión de líneas que coinciden con un patrón de
búsqueda)
</para>

<para>
 Ya hemos visto ejemplos del comando grep en los capítulos
anteriores, que muestra las líneas que concuerdan con un patrón. Pero
grep puede hacer más que eso.

<screen>
   	$grep "busca esto" /var/log/messages -c
	
</screen>

</para>

<para>
 12
</para>

<para>
 Se ha encontrado 12 veces la cadena "busca esto" en el fichero
/var/log/messages.
</para>

<para>
 &lsqb;vale, este ejemplo es falso, el fichero /var/log/messages está
alterado :-)]
</para>

<para>
<emphasis remap="bf">wc</emphasis> (cuenta líneas, palabras y bytes)
</para>

<para>
 En el siguiente ejemplo, vemos que la salida no es lo que 
esperábamos. El fichero petete utilizado en este ejemplo contiene el 
texto siguiente:
</para>

<para>
<emphasis remap="it">"programación en bash</emphasis>

<emphasis remap="it">como de introducción"</emphasis>
</para>

<para>

<screen>
	$wc --words --lines --bytes /tmp/petete
	
</screen>

</para>

<para>
 2 5 41 /tmp/petete
</para>

<para>
 Wc no tiene en cuenta el orden de los parámetros. Wc siempre los 
imprime en un orden estándar, que es, como se puede ver: líneas, 
palabras, bytes y fichero.
</para>

<para>
<emphasis remap="bf">sort</emphasis> (ordena líneas de ficheros de texto)
</para>

<para>
 Esta vez, el fichero petete contiene el texto siguiente:
</para>

<para>
<emphasis remap="it">"b</emphasis>

<emphasis remap="it">c</emphasis>

<emphasis remap="it">a"</emphasis>

<screen>
	$sort /tmp/petete
	
</screen>

</para>

<para>
 Esto es lo que muestra la salida:
</para>

<para>
<emphasis remap="it">a</emphasis>

<emphasis remap="it">b</emphasis>

<emphasis remap="it">c</emphasis>
</para>

<para>
 Los comandos no deberían ser tan fáciles :-)
</para>

<para>
<emphasis remap="bf">bc</emphasis> (un lenguaje de programación de cálculos matemáticos)
</para>

<para>
 Bc acepta cálculos desde la línea de comandos (entrada desde un 
fichero, pero no desde una redirección o una tubería), y también desde 
una interfaz de usuario. La siguiente demostración expone algunos de los 
comandos. Note que  ejecuto bc con el parámetro -q para evitar el mensaje 
de bienvenida.
</para>

<para>

<screen>
   $bc -q
	
</screen>

</para>

<para>
 <emphasis remap="it">1 == 5</emphasis>
</para>

<para>
 <emphasis remap="it">0</emphasis>
</para>

<para>
 <emphasis remap="it">0.05 == 0.05</emphasis>
</para>

<para>
 <emphasis remap="it">1</emphasis>
</para>

<para>
 <emphasis remap="it">5 != 5</emphasis>
</para>

<para>
 <emphasis remap="it">0</emphasis>
</para>

<para>
 <emphasis remap="it">2 &circ; 8</emphasis>
</para>

<para>
 <emphasis remap="it">256</emphasis>
</para>

<para>
 <emphasis remap="it">sqrt(9)</emphasis>
</para>

<para>
 <emphasis remap="it">3</emphasis>
</para>

<para>
 <emphasis remap="it">while (i != 9) &lcub;</emphasis>
</para>

<para>
 <emphasis remap="it">i = i + 1;</emphasis>
</para>

<para>
 <emphasis remap="it">print i</emphasis>
</para>

<para>
 <emphasis remap="it">&rcub;</emphasis>	
</para>

<para>
 <emphasis remap="it">123456789</emphasis>
</para>

<para>
 <emphasis remap="it">quit</emphasis>
</para>

<para>
<emphasis remap="bf">tput</emphasis> (inicializa una terminal o consulta la base de datos de
terminfo)
</para>

<para>
 Una pequeña demostración de las capacidades de tput:

<screen>
	$tput cup 10 4
	
</screen>

</para>

<para>
 La línea de comandos aparece en (y10,x4).

<screen>
	$tput reset
	
</screen>

</para>

<para>
 Limpia la pantalla y la línea de comandos aparece en (y1,x1).
Observe que (y0,x0) es la esquina superior izquierda.

<screen>
	$tput cols
	
</screen>

<emphasis remap="it">80</emphasis>
</para>

<para>
 Muestra el número de caracteres que caben en la dirección x.
</para>

<para>
 Es muy recomendable familiarizarse con estos programas (al menos). 
Hay montones de programillas que le permitirán hacer virguerías en la 
línea de comandos.
</para>

<para>
 &lsqb;algunos ejemplos están copiados de las páginas man o los PUFs]
</para>

</sect2>

</sect1>

<sect1>
<title>Más scripts
     </title>

<sect2>
<title>Aplicando un comando a todos los ficheros de un directorio.
     </title>

<para>
 
</para>

</sect2>

<sect2>
<title>Ejemplo: Un script de copia de seguridad muy simple (algo mejor)
	   </title>

<para>

<screen>
	    #!/bin/bash          
	    ORIG="/home/"
	    DEST="/var/copias_de_seguridad/"
	    FICH=home-$(date +%Y%m%d).tgz
	    tar -cZf $DEST$FICH $ORIG
	   
</screen>
 
</para>

</sect2>

<sect2>
<title>Re-nombrador de ficheros
          </title>

<para>

<screen>
          
             #!/bin/sh
             # renom: renombra múltiples ficheros de acuerdo con ciertas
             # reglas
             # escrito por Felix Hudson  Enero - 2000
             
             # primero comprueba los distintos 'modos' que tiene este
             # programa
             # si la primera ($1) condición coincide, se ejecuta esa parte
             # del programa y acaba
             
             # comprueba la condición de prefijo
             if [ $1 = p ]; then
             
             # ahora nos libramos de la variable de modo ($1) y ponemos $2
             # de prefijo
               prefijo=$2 ; shift ; shift
             
             # una rápida comprobación para ver si se especificó algún
             # fichero
             # si no, hay cosas mejores que hacer que renombrar ficheros
             # inexistentes!!
               if [$1 = ]; then
                  echo "no se especificaron ficheros"
                  exit 0
               fi
             
             # este bucle for itera a lo largo de todos los ficheros que
             # le hemos especificado al programa
             # renombra cada uno de ellos
               for fichero in $*
                 do
                 mv ${fichero} $prefijo$fichero
               done
             
             # ahora salimos del programa
               exit 0
             fi
             
             # comprueba si es un renombramiento con sufijo
             # el resto es casi idéntico a la parte anterior
             # lea los comentarios anteriores
             if [ $1 = s ]; then
               sufijo=$2 ; shift ; shift
             
                if [$1 = ]; then
                 echo "no se especificaron ficheros"
                exit 0
                fi
             
              for fichero in $*
               do
                mv ${fichero} $fichero$sufijo
              done
             
              exit 0
             fi
             
             # comprueba si es una sustitución
             if [ $1 = r ]; then
             
               shift
             
             # he incluído esto para no dañar ningún fichero si el
             # usuario no especifica que se haga nada
             # tan sólo una medida de seguridad             
               if [ $# -lt 3 ] ; then
                 echo "uso: renom r [expresión] [sustituto] ficheros... "
                 exit 0
               fi
             
             # elimina el resto de información
               VIEJO=$1 ; NUEVO=$2 ; shift ; shift
             
             # este bucle for itera a lo largo de todos los ficheros que
             # le hemos especificado al programa
             # renombra cada fichero utilizando el programa 'sed'
             # es un sencillo programa desde la línea de comandos que
             # analiza la entrada estándar y sustituye una expresión por
             # una cadena dada
             # aquí le pasamos el nombre del fichero (como entrada
             # estándar)
               for fichero in $*
               do
                 nuevo=`echo ${fichero} | sed s/${VIEJO}/${NUEVO}/g`
                 mv ${fichero} $nuevo
               done
             exit 0
             fi
             
             # si se llega a esta parte es que no se le pasó nada
             # apropiado al programa, por lo que le decimos al usuario
             # cómo hacerlo
             echo "uso:"
             echo " renom p [prefijo] ficheros.."
             echo " renom s [sufijo] ficheros.."
             echo " renom r [expresión] [sustituto] ficheros.."
             exit 0
             
             # hecho!
             
	  
</screen>

</para>

</sect2>

<sect2>
<title>Re-nombrador de ficheros (sencillo)
     </title>

<para>

<screen>
     #!/bin/bash
     # renombra.sh
     # renombrador de ficheros básico

     criterio=$1
     expresion=$2
     sustituto=$3
     
     for i in $( ls *$criterio* ); 
     do
         orig=$i
         dest=$(echo $i | sed -e "s/$expresion/$sustituto/")
	 mv $orig $dest
     done
     
</screen>

</para>

</sect2>

</sect1>

<sect1>
<title>Cuando algo va mal (depuración)
     </title>

<sect2>
<title>Maneras de llamar a BASH           </title>

<para>
 Una buena idea es poner esto en la primera línea:

<screen>
	  #!/bin/bash -x
	  
</screen>

</para>

<para>
 Esto producirá información interesante.
</para>

</sect2>

</sect1>

<sect1>
<title>Sobre el documento
     </title>

<para>
 Siéntase libre para hacer sugerencias/correcciones, o lo que
crea que sea interesante que aparezca en este documento. Intentaré
actualizarlo tan pronto como me sea posible.
</para>

<sect2>
<title>(sin) Garantía
          </title>

<para>
 Este documento no lleva garantía de ningún tipo.
</para>

</sect2>

<sect2>
<title>Traducciones
     	</title>

<para>
 Italiano: por William Ghelfi (wizzy está en tiscalinet.it).
<ulink
url="http://web.tiscalinet.it/penguin_rules"
>http://web.tiscalinet.it/penguin_rules</ulink
>
</para>

<para>
 Francés: por Laurent Martelli 
<ulink
url="http://"
>¿?</ulink
>
</para>

<para>
 Coreano: Minseok Park 
<ulink
url="http://kldp.org"
>http://kldp.org</ulink
>
</para>

<para>
 Corean: Chun Hye Jin 
<ulink
url=""
>Desconocido</ulink
>
</para>

<para>
 Spanish: Gabriel Rodríguez Alberich
<ulink
url="http://www.insflug.org"
>http://www.insflug.org</ulink
>
</para>

<para>
 Supongo que habrá más traducciones, pero no tengo información
sobre ellas. Si las tiene, por favor, envíemelas para que actualice esta
sección.
</para>

</sect2>

<sect2>
<title>Agradecimientos
     </title>

<para>

<itemizedlist>
<listitem>

<para>
 A la gente que ha traducido este documento a otras lenguas
(sección anterior).
</para>
</listitem>
<listitem>

<para>
 A Nathan Hurst por enviar montones de correcciones.
</para>
</listitem>
<listitem>

<para>
 A Jon Abbott por enviar comentarios sobre la evaluación de
expresiones aritméticas.
</para>
</listitem>
<listitem>

<para>
 A Felix Hudson por escribir el script <emphasis remap="it">renom</emphasis>
</para>
</listitem>
<listitem>

<para>
 A Kees van den Broek (por enviar tantas correcciones y reescribir
la sección de comandos útiles)
</para>
</listitem>
<listitem>

<para>
 Mike (pink) hizo algunas sugerencias sobre la localización del
bash y la comprobación de los ficheros
</para>
</listitem>
<listitem>

<para>
 Fiesh hizo una buena sugerencia sobre la sección de bucles.
</para>
</listitem>
<listitem>

<para>
 Lion sugirió mencionar un error común (./hello.sh: Comando no
encontrado.)
</para>
</listitem>
<listitem>

<para>
 Andreas Beck hizo varias correcciones y comentarios.
</para>
</listitem>

</itemizedlist>

</para>

</sect2>

<sect2>
<title>Historia
	</title>

<para>
 Añadidas nuevas traducciones y correcciones menores.
</para>

<para>
 Añadida la sección de comandos útiles reescrita por Kess.
</para>

<para>
 Incorporadas más correcciones y sugerencias.
</para>

<para>
 Añadidos ejemplos sobre la comparación de cadenas.
</para>

<para>
 v0.8 abandono del versionamiento. Supongo que con la fecha es
suficiente.
</para>

<para>
 v0.7 Más correcciones y algunas secciones TO-DO escritas.
</para>

<para>
 v0.6 Correcciones menores.
</para>

<para>
 v0.5 Añadida la sección de redireccionamiento.
</para>

<para>
 v0.4 desaparición de su sitio debido a mi ex-jefe. Este documento
tiene un nuevo sitio en: http://www.linuxdoc.org.
</para>

<para>
 Anteriores: no me acuerdo y no he usado rcs ni cvs :(
</para>

</sect2>

<sect2>
<title>Más recursos
          </title>

<para>
 Introducción a bash (bajo BE)
<ulink
url="http://org.laol.net/lamug/beforever/bashtut.htm"
>http://org.laol.net/lamug/beforever/bashtut.htm</ulink
>
</para>

<para>
 Programación en Bourne Shell
http://207.213.123.70/book/ 
</para>

</sect2>

</sect1>

</article>
