<HTML>
<HEAD>
<TITLE>Tutorial de Perl Captilo 3 Seccion 4</TITLE>
</HEAD>
<BODY>
<center>
<H1><A href="http://lince.dgsca.unam.mx:8080/daniel/lacertus/tutorial_perl.html">Tutotial de Perl</A></H1>
</center>
<blockquote>
<h2><A href="#3.4"> Tabla de contenidos<br> Seccion 3.4- Expresiones Regulares</A></h2><BR>
<blockquote>
<h3><A href="#3.4.1">3.4.1- S&iacute;mbolos Normales</h3></A><BR>
<blockquote>
<h4><A href="#3.4.1.1">3.4.1.1- Individuales</h4></A><BR>
<h4><A href="#3.4.1.2">3.4.1.2- Gen&eacute;ricos</h4></A><BR>
</blockquote>
<h3><A href="#3.4.2">3.4.2- S&iacute;mbolos Especiales</h3></A><BR>
<h3><a href="#3.4.3">3.4.3- Uso de Expresiones regulares</a></h3>.<BR>
<blockquote>
<h4><a href="#3.4.3.1">3.4.3.1- B&uacute;squeda</a></h4><BR>
<h4><a href="#3.4.3.2">3.4.3.2- Substituci&oacute;n</h4></a><BR>
</blockquote>
<h3><a href="#3.4.4">3.4.4- Variables</a></h3><BR>
<blockquote>
<h4><a href="#3.4.4.1">3.4.4.1- Variables de entrada</a></h4><BR>
<h4><a href="#3.4.4.2">3.4.4.2- Variables de salida</h4></a><P>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<i>Version 2.1, Lunes 14 de Abril de 1997</i>
<h3><a href="http://lince.dgsca.unam.mx:8080/cgi-bin/daniel/hola"> Daniel Sol Llaven</a></h3>
<HR>
<blockquote><A NAME="3.4"><H2>3.4- Expresiones Regulares</H2></A><BR></blockquote>

Una de las caracter&iacute;sticas mas &uacute;tiles de Perl es el proceso que da
 a sus escalares. Y las cadenas de caracteres reciven especial atenci&oacute;n.<BR>
Una de las tareas mas comunes al trabajar con cadenas es el extraer 
subcadenas o reconocer cadenas de una u otra estructura.<BR>
Perl se basa en los conceptos de cadenas regulares para brindar un poderoso
manejo de las cadenas de caracteres, para aquellos que no recuerden que son las 
cadenas regulares, estas son descripciones abstractas de conjuntos de cadenas.<BR>

Las definiciones esenciales para las cadenas regulares, ya que una 
discusi&oacute;n medianamente seria de ellas es materia de estudios mas bien 
largos; se reducen a:<P>

S&iacute;mbolo- Es un elemento, &uacute;nico y distinguible de cualquier otro, para Perl son caracteres 
(especiales y normales) y en lo sucesivo usaremos los t&eacute;rminos caracter y
s&iacute;mbolo indistintamente,<BR>
<i>Cadena</i> Es una serie finita de caracteres.<BR>
<i>Lenguaje</i> Es un conjunto de cadenas.<BR>
<i>Expresi&oacute;n regular</i> Es la descripci&oacute;n abstracta de un lenguaje, en forma de una cadena.<BR>
<i>Lenguaje Regular</i> Es aquel lenguaje que puede ser descrito mediante expresiones regualres.<P>

Aunque esto puede resultar un tanto complejo, la idea central es simple, mediante un conjunto de s&iacute;mbolos 
describiremos grupos de cadenas, a los que llamamos lenguajes, las descripciones, no son sino series de 
s&iacute;mbolos, por lo que a fin de cuentas son tambi&eacute;n cadenas, pero para evitar confusiones les
 llamaremos expresiones regulares.<BR>
Nota: No todos los conjuntos imaginables de cadenas son describibles por lenguajes regualres, de
 ah&iacute; surgen los lenguajes naturales y muchos ortos, pero el estudio de los lenguajes es una rama
 fascinante pero compleja de la matem&aacute;tica moderna que no trataremos aqu&iacute;.<P>

A pesar de las promesas de complejidad, el manejo de cadenas regualres lejos de dificultar las cosas, las
 simplifica sobremanera, aunque suele restar legibilidad al programa, bueno, para contrarrestar esto,
 recomiendo colocar al menos un comentario por cada expresi&oacute;n regular (de mas de 5 caracteres)
 que se use.<P>

Los s&iacute;mbolos que en Perl usaremos para construir nuestras expresiones regulares los dividiremos
 en dos grandes grupos; normales y especiales, los primeros simplemente representaran un caracter mientras
 que los segundos dar&aacute;n descripciones de cadenas formadas con esos s&iacute;mbolos.<P>

Solo resta recordar que Perl determina las cadenas regualres como aquellas que se encuentran entre "/", de
 modo que /hola/ Ser&aacute; para Perl una cadena regular. Y a lo largo de este capitulo pondremos las
 cadenas regulares en el formato de Perl.<P>

<blockquote><blockquote><blockquote><A NAME="3.4.1"><H3>3.4.1- S&iacute;mbolos Normales</H3></A>
<blockquote><BR>
<A NAME="3.4.1.1"><H4>3.4.1.1- Individuales</H4></A><P>
</blockquote></blockquote></blockquote></blockquote>

Los s&iacute;mbolos mas usuales para formar parte de nuestras cadenas son los alfab&eacute;ticos (en
 may&uacute;sculas y min&uacute;sculas) y los d&iacute;gitos, y estos s&iacute;mbolos se colocan tal
 cual.<P>

por ejemplo:<BR>
/hola/<BR>
Esta expresi&oacute;n regular indica que las cadenas as&iacute; referidas contienen los s&iacute;mbolos
 "h", "o", "l", y "a" en ese estricto orden.<BR>
En matem&aacute;ticas formales esta expresi&oacute;n dar&iacute;a origen a un lenguaje con una
&uacute;nica cadena "hola", pero en Perl, esta expresi&oacute;n regular genera un lenguaje que contiene
todas las cadenas que CONTIENEN "hola" en cualquier lugar en su interior. N&oacute;tese que Perl no
"genera" el lenguaje, pues eso a menudo es una tarea imposible, pero si reconoce a las cadenas que
pertenezcan al lenguaje.<P>

Todo caracter que se desee incluir que no sea alfab&eacute;tico, o num&eacute;rico, deber&aacute;
 anteponerse de un backslash "\" , as&iacute; por ejemplo:<P>

El lenguaje que reconozca todas las cadenas que contengan "656-31-74.34" se puede representar por la
 siguiente cadena regular:<P>

/656\-31\-74\.34/<P>

Adem&aacute;s, se pueden reconocer, entre otros, los siguientes caracteres especiales:<P>

<table>
<tr><td>\s</td><td>Espacio en blanco</td></tr>
<tr><td>\t</td><td>Tabulador</td></tr>
<tr><td>\n</td><td>Vuelta de carro + Avance de l&iacute;nea</td></tr>
<tr><td>\r</td><td>Vuelta de carro</td></tr>
<tr><td>\0xx</td><td>Caracter octal xx (i.e. /\062/ para el caracter ASCII 50)</td></tr>
<tr><td>\xXX</td><td>Caracter Hexadecimal XX (i.e. /\x1B/ para el caracter 27)</td></tr>
<tr><td>\cX</td><td>Caracter Control+X (i.e. \cC para Ctrl-C)</td></tr>
</table>
<P>
<blockquote><blockquote><blockquote><blockquote>
<A NAME="3.4.1.2"><H4>3.4.1.2- Gen&eacute;ricos</H4></A><P>
</blockquote></blockquote></blockquote></blockquote>
Adem&aacute;s, es com&uacute;n que deseemos reconocer una serie de s&iacute;mbolos de alg&uacute;n
 tipo, entendiendo como tipo de caracter a un conjunto de caracteres, por ejemplo, podemos hablar de los
 caracteres alfab&eacute;ticos, que el conjunto de los caracteres de la "a" a la "z" min&uacute;sculas y de
 la "A" a la "Z" (may&uacute;sculas).<P>

Perl define los siguientes grupos de caracteres, adem&aacute;s de que con s&iacute;mbolos especiales
podemos emplear grupos arbitrarios.<P>

<table>
<tr><td>.</td><td>Cualquier caracter (acepta a cualquiera)</td></tr>
<tr><td>\w</td><td>Caracter de palabra (alfanum&eacute;rico y "_")</td></tr>
<tr><td>\W</td><td>Caracter que no es de palabra (todos menos alfanum&eacute;ricos o "_")</td></tr>
<tr><td>\d</td><td>D&iacute;gito (0 a 9)</td></tr>
<tr><td>\D</td><td>Caracter que no es D&iacute;gito (todos menos 0 al 9)</td></tr>
</table>
<P>
Adem&aacute;s, define como caracteres especiales, las siguientes condiciones (que en realidad no se
 refieren a ning&uacute;n caracter).<P>
<table>
<tr><td>\b</td><td>Limite de una palabra</td></tr>
<tr><td>\A ^</td><td>Principio de cadena (puede usarse indistintamente "^" o "\A"</td></tr>
<tr><td>\Z $</td><td>Fin de l&iacute;nea</td></tr>
</table>
<P>
La diferencia entre "\A" y "^" o de "\Z" y "$" es que las versiones con "\" se refieren exclusivamente al
 inicio o fin de la cadena, y las versiones con un &uacute;nico s&iacute;mbolo se refieren a las diversas
 l&iacute;neas dentro de la cadena (si las hay), pero para que estas funcionen de esta forma deberemos
 usar la opci&oacute;n "/m" e la cadena regular. En casos convencionales son id&eacute;nticas. <P>

<blockquote><blockquote><blockquote>
<A NAME="3.4.2"><H3>3.4.2- S&iacute;mbolos Especiales</H3></A><BR>
</blockquote></blockquote></blockquote>

Adem&aacute;s de los s&iacute;mbolos que representan caracteres o series de caracteres
tenemos toda una familia de s&iacute;mbolos que representan caracter&iacute;sticas de las series de
caracteres que ya hemos especificado.<P>

Siendo S un s&iacute;mbolo normal o gen&eacute;rico y E un s&iacute;mbolo especial:<BR>
<table>
<tr><td>(SS)</td><td>Agrupa los s&iacute;mbolos</td></tr>
<tr><td>S|S</td><td>Alternaci&oacute;n ( "a" o "b" => /a|b/ )</td></tr>
<tr><td>[S]</td><td>Clase de caracteres ( puntuaci&oacute;n => /[.,;:]/ )</td></tr>
<tr><td>S*</td><td>Cero, una, dos o cualquier numero de veces</td></tr>
<tr><td>S+</td><td>Una, dos, o cualquier numero de veces (pero al menos una vez)</td></tr>
<tr><td>S(n)</td><td>Exactamente n veces (i.e. /a(5)/ Ser&aacute; equivalente a /aaaaa/ )</td></tr>
<tr><td>S(n,m)</td><td>Al menos n veces y no mas de m veces (i.e. /a(2,4)/ =&gt /(aa)|(aaa)|(aaaa)/ )</td></tr>
<tr><td>S?</td><td>cero o una vez</td></tr>
<tr><td>SE?</td><td>Modifica al s&iacute;mbolo especial para que no sea "acaparador"</td></tr>
</table><P>
Estos, como podr&aacute; verse, son los mas poderosos ( y menos claros), por lo que a continuaci&oacute;n
 damos una larga lista de ejemplos que emplean uno o varios de ellos.<P>

Palabras:<BR>
<B><tt>/\w*/</B></tt><BR>
Son simplemente, todos los caracteres alfanum&eacute;ricos (y "_") que est&eacute;n juntos.<P>

N&uacute;meros (naturales)<BR>
<B><tt>/\d*/</tt></B><BR>
Es una serie de d&iacute;gitos simple y sencilla.<P>

N&uacute;meros reales (positivos sin mas adornos)<BR>
<B><tt>/\d*\.\d*/</tt></B><BR>
N&oacute;tese que el "." necesita ponerse como "<B><tt>\.</B></tt>"<P>

Por ejemplo, para reconocer los tel&eacute;fonos que est&eacute;n dados en alguno de los formatos:<BR>
###-##-## o ###-#### o #####-## o #######, no admitiendo nada antes o despu&eacute;s:<BR>
<B><tt>/^\d(3)\-?\d(2)\-?d(2)$/</B></tt><BR>
Lo que, en castellano seria: <BR>
Inicio de cadena, luego tres d&iacute;gitos, uno o cero "-", dos d&iacute;gitos, uno o cero "-", dos
 d&iacute;gitos y final de la cadena.<P>

Para reconocer: Nombre Apellido Apellido, dando por hecho que Nombre y los Apellidos son
 alfab&eacute;ticos y est&aacute;n separados por espacios:<BR>
<B><tt>/\w*\s\w*\s\w*/</B></tt><P>

N&oacute;tese que encontrara al nombre aun si esta dentro de alguna cadena, por ejemplo "674.52.64
 Daniel Sol Llaven. Tibet #32" pues la cadena regular descrita si esta presente y no requiri&oacute; ni inicio
 ni fin de cadena.<BR>
Para encontrar la primera palabra y otra palabra al final, en cualquier cadena:<BR>
<B><tt>/^.*?\w*.*?\w*$/</B></tt><BR>
Traducido: Busca el inicio de la cadena, seguido de cualquier numero de caracteres cualesquiera, pero
siendo este el m&iacute;nimo numero que no haga fallar la expresi&oacute;n, seguidos de cualquier numero
de caracteres de una palabra, seguidos de otra vez, cualquier numero m&iacute;nimo de caracteres
cualesquiera, seguidos de cualquier numero de caracteres de palabra, seguidos del fin de l&iacute;nea.<P>

No es evidente el que el patr&oacute;n no realice la operaci&oacute;n deseada sin los "<B><tt>?</B>
</tt>", para ejemplificarlo, vemos el siguiente ejemplo:<BR>
para la cadena: "<B><tt>2342:Esta es la cadena que usamos para probar, si, esta</B></tt>"<P>

con la expresi&oacute;n:<BR>
<B><tt>/^.*\w*.*\w*$/</B></tt> <BR>
De hecho encuentra la expresi&oacute;n una cadena del lengaje, pero la divide de modo incorrecto
 (mas adelante veremos como usar las expresiones regualres para extraer segmentos de las cadenas,
 ahora solo revisemos como se comportan los s&iacute;mbolos especiales).<BR>
usemos la siguiente leyenda para indicar a quien asocia cada parte de la cadena regular:<P>
<table>
<tr><td><b><tt>^ </b></tt></td><td>inicio de la cadena, no la indicamos.</td></tr>
<tr><td><b><tt>.*</b></tt></td>
  <td>"...." debajo de la parte que es reconocida por estos s&iacute;mbolos.</td></tr>
<tr><td><b><tt>\w*</b></tt></td><td>"11111" debajo de la primera palabra.</td></tr>
<tr><td><b><tt>.*</b></tt></td><td>"****" debajo de la segunda separaci&oacute;n</td></tr>
<tr><td><b><tt>\w*</b></tt></td><td>"debajo de la segunda palabra (que esta al final de la cadena).</td></tr>
<tr><td><b><tt>$ </b></tt></td><td>Fin de la l&iacute;nea, no la indicamos.</td></tr>
</table>
<P>
<b><tt>2342:Esta es la cadena que usamos para probar, si, esta</b></tt><BR>
<b><tt>.....................................................12</b></tt><P>

N&oacute;tese que la primera serie "cualquier caracter de cero a cualquier numero" representada por "<b>.</b>"
 absorbe casi toda la cadena, esto es porque el "<b>*</b>" de la expresi&oacute;n regular es acaparador, y 
tomara tantos caracteres como le sea posible sin que la expresi&oacute;n no sea reconocida. Se distingue
 adem&aacute;s que no hay una segunda serie de "cualesquiera caracteres" entre las dos palabras, esto es
 porque el "<b>*</b>" permite desde cero hasta cualquier numero de caracteres, en esta ocasi&oacute;n, 
toma la opci&oacute;n te adquirir cero caracteres.<BR>
As&iacute; pues, para que reconozca las palabras como deseamos, debemos hacer que las separaciones
 no sean acaparadoras, es decir, tomen el m&iacute;nimo numero de caracteres posible, para que dejen a
 nuestras palabras los mas posibles. Para lograr esto, ponemos "<b>?</b>" a continuaci&oacute;n de los 
 "<b>*</b>" que no deseamos sean acaparadores, resultando la expresi&oacute;n regular:<P>

<B><tt>/^.*?\w*.*?\w*$/</B></tt><P>

Usando la misma leyenda para ilustrar como reconoce la cadena:<P>

<b><tt>2342:Esta es la cadena que usamos para probar, si, esta</b></tt><BR>
<b><tt>.....1111******************************************2222</tt></b><P>

Funciono como esper&aacute;bamos esta vez, porque: <BR>
La primera secuencia de "cualesquiera caracteres" toma la m&iacute;nima cantidad de caracteres que dejan
 una palabra a continuaci&oacute;n (para que la expresi&oacute;n no falle), luego, el "<b><tt>\w*</b></tt>"
 toma todos los caracteres alfab&eacute;ticos a su alcance (no hay "_") . La segunda parte "<b><tt>.*?</b>
</tt>" toma el m&iacute;nimo de caracteres que dejen a continuaci&oacute;n una palabra Y que a
 continuaci&oacute;n de esta palabra este el fin de l&iacute;nea (esta condici&oacute;n del fin de
 l&iacute;nea evita que termine por ejemplo en el "probar, " pues aunque si es una palabra lo que sigue,
 no termina en un fin de l&iacute;nea, sino en espacio).<P>

No permita el lector que la aparente complejidad, y patente obscuridad de estas expresiones lo asuste, en
 el &aacute;mbito de la programaci&oacute;n real siempre hay tiempo de probar que las cadenas regulares
 que planteamos funcionen, y en su oportunidad, escribirlas mediante un m&eacute;todo de aut&eacute;ntica
 "prueba y error".<P>

<blockquote><blockquote><blockquote>
<h3><a name="3.4.3">3.4.3- Uso de Expresiones regualres.</a></h3><P>
</blockquote></blockquote></blockquote>

Como mencionamos en la secci&oacute;n de operadores, los operadores principales para usar las
 expresiones regualres son s/// y m//, pero no ahondamos en los usos que les podemos dar, que no son ni
 mucho menos, tan patentes como los usos de los operadores convencionales.<P>

Por su utilidad, podemos dividir los principales usos de las expresiones regulares en tres categor&iacute;as: <BR>
<table>
<tr><td>B&uacute;squeda</td><td>Donde el objetivo es verificar la existencia de un patr&oacute;n en una
cadena (ver si la cadena pertenece al lenguaje especificado).</td></tr>
<tr><td>Substituci&oacute;n</td><td>Reemplazar una cadena (o lenguaje) por otro, muy &uacute;til para 
modificar sistem&aacute;ticamente una cadena en una serie de archivos (usando Perl en l&iacute;nea).</td></tr>
<tr><td>Extracci&oacute;n</td><td>Tambi&eacute;n se pueden utilizar para extraer subcadenas que cumplan 
con ciertas caracter&iacute;sticas dentro de las cadenas que proporcionemos, que pertenezcan al
lenguaje.</td></tr>
</table></P>
<blockquote><blockquote><blockquote><blockquote>
<h4><a name="3.4.3.1">3.4.3.1- B&uacute;squeda</a></h4><P>
</blockquote></blockquote></blockquote></blockquote>

Esta es por mucho la mas sencilla de las aplicaciones, simplemente verifica que una cadena cumpla con
 el lenguaje especificado y regresa un valor l&oacute;gico para indicar el &eacute;xito o el fracaso de la
 cadena. El uso t&iacute;pico de esta funci&oacute;n, es el elaborar una espacie de grep en Perl.<P>

Pasando directamente a los ejemplos:<P>

Si deseamos imprimir solamente las l&iacute;neas de comentario de un programa en Perl, podr&iacute;amos
 escribir el siguiente script.<P>
<B><PRE>
#/usr/bin/perl
open(AE,"ARGV[0]");	#Abrimos para lectura el archivo dado como primer par&aacute;metro.
while($reng=&lt;AE&gt;)
{
  if($reng=~m/^\#/)	#Estrictamente las l&iacute;neas que inicien con #
  {
    print $reng;
  }
}
close(AE);
</B></PRE>
Como se puede ver, este script imprimir&aacute; todas las l&iacute;neas del archivo original que inicien con
 "<B><tt>#</B></tt>", esto ignora los comentarios al final de las l&iacute;neas, pero este detalle se
 correge con eliminar el "<b><tt>^</tt></b>" del inicio de la expresi&oacute;n regular.<P>

Si deseamos hacer un demigrep, o supergrep (como se desee) que responda a la siguiente
 invocaci&oacute;n:<BR>
grep.pl archivo patr&oacute;n, siendo el patr&oacute;n una cadena regular, imprimiendo del archivo dado
 como par&aacute;metro las l&iacute;neas que cumplan con el.<P>
<B><PRE>
#/usr/bin/Perl
open(AE,"ARGV[0]");	#Abrimos para lectura el archivo dado como primer par&aacute;metro.
while($reng=&lt;AE&gt;)
{
  if($reng=~m/$ARGV[1]/)	#En efecto, al igual que en las "" se substituyen las vairables entre //
  {
    print $reng;
  }
}
close(AE);
</B></PRE>
La caracter&iacute;stica de formaci&oacute;n din&aacute;mica de las cadenas regulares funciona tanto
 para Perl4 como para Perl5. y puede ser de gran utilidad cuando el patr&oacute;n que los renglones deben
 cumplir depende de la informaci&oacute;n contenida en el mismo archivo. Esta caracter&iacute;stica la
revisamos a fondo en la <a href="#3.4.4.1">secci&oacute;n 3.4.4.1</a><P>

<blockquote><blockquote><blockquote><blockquote>
<a name="3.4.3.2"><h4>3.4.3.2- Substituci&oacute;n</h4></a><BR>
</blockquote></blockquote></blockquote></blockquote>

El uso mas com&uacute;n de las expresiones regualres es el cambiar una cadena por otra cuando
 as&iacute; se requiere (dondequiera que este en la cadena original). con lo que se resumen grandes
 segmentos de c&oacute;digo sobretodo en el filtrado de largos archivos de texto.<P>

Esta funci&oacute;n se basa en el operador s/// , su sintaxis es:<BR>
<b><tt>s/EXP1/EXP2/MOD</b></tt><BR>
donde:<BR>
<b><tt>EXP1</b></tt>	Es la expresi&oacute;n que buscamos y que de encontrarla
 ser&aacute; substituida<BR>
<b><tt>EXP2</b></tt>	Es la expresi&oacute;n por la que hemos de substituir la expresi&oacute;n
 buscada<BR>
<b><tt>MOD</b></tt>	Es un modificador de la operaci&oacute;n del s/// usualmente "g"<P>

As&iacute; como el modificador se agrega al final de <b><tt>s///</b></tt> , se puede agregar al final
 de la expresi&oacute;n <b><tt>m//</b></tt> , para revisar los modificadores recomiendo que se consulte
 la referencia en el capitulo de operadores PERLOP y de cadenas regualres PERLRE.<P>

El primer ejemplo, sea el comando de Perl en l&iacute;nea de comando que cambiar&iacute;a en todos los
 programas .pl del directorio la ruta de Perl (tarea com&uacute;n cuando se migra un programa de una
 maquina a otra).<P>

<b><tt>/usr/leng/Perl -pi.bak -e "s/\/usr\/bin\/perl/\/usr\/leng\/perl/g";</b></tt><P>

En resumen, lo que hace este comando es que todas las ocurrencias de "/usr/bin/Perl" (los / se anteceden
 de un \ para evitar que se confundan con el final de la expresi&oacute;n regular), sean reemplazadas por
 "/usr/leng/Perl" cuantas veces aparezcan en un rengl&oacute;n (esa es la funci&oacute;n del modificador
 "g" que no solo se realice una substituci&oacute;n si hay mas de una ocurrencia en la misma cadena).<P>

<blockquote><blockquote><blockquote>
<h3><a name="3.4.4">3.4.4- Variables</a></h3><BR>
</blockquote></blockquote></blockquote>

Las expresiones regulares se vuelven extremadamente poderosas al agregarles variables, estas aparecen
 tanto de entrada como de salida.<P>
Las variables de entrada son reemplazadas (como se reemplazan en las cadenas que est&aacute;n entre
 comillas "") en las expresiones regulares, esto nos da la posibilidad de emplear cadenas regualres
 determinadas en tiempo de corrida.<BR>Las variables de salida son variables constantes (no podemos
 modificar sus valores directamente) en las que se colocan las diversas coincidencias de las cadenas
 regulares con la cadena de prueba, estas nos dan la posibilidad de extraer informaci&oacute;n de nuestras
 cadenas de prueba en base a cadenas regulares.<P>

<blockquote><blockquote><blockquote><blockquote>
<h4><a name="3.4.4.1">3.4.4.1- Variables de entrada</a></h4><BR>
</blockquote></blockquote></blockquote></blockquote>

Hasta ahora, las expresiones regualres a evaluar son constantes, esto es, entre ejecuciones del programa
siempre buscamos el mismo lenguaje de la cadena de prueba. Esto es solo un caso particular para Perl,
pues determina las expresiones regualres a evaluar en tiempo de corrida, lo que nos da la posibilidad de
elaborar expresiones regulares que respondan a las necesidades de cada corrida.<BR>
Para esto, Perl substituye el valor de las variables que especifiquemos entre <b>//</b> de modo similar
a como lo hace en las cadenas entre par&eacute;ntesis.<P>
Por ejemplo:<p>

<b>
$cadena="1321323palabra"; #Damos valor a la cadena de prueba<BR>
$cadena=~s/\w+//g";       #Le aplicamos la expresion regular \w+<p>
</b>

Es funcionalmente equivalente a:<BR>
<b>
$cadena="1321323palabra"; #Damos valor a la cadena de prueba<BR>
$expresion="\w+";<BR>     #Una cadena que formar&aacute; parte de la expresion regular
$cadena=~s/$expresion//g";#aplicamos la expresion regular a la cadena de prueba<p>
</b>
Esto, porque en el segundo c&oacute;digo, la expresi&oacute;n regular identifica a <b>$expresion</b>
 como una variable y substituye su valor en la expresi&oacute;n regular, en este caso <b>\w*</b> , de
 modo que ambos c&oacute;digos reemplazaran las "palabras" (o grupos de caracteres alfab&eacute;ticos
 contiguos) por la cadena vac&iacute;a, quitando las "palabras" de la cadena de prueba 
<b>$cadena</b>.<P>

A primera vista puede no ser muy evidente el uso de esta funcionalidad, pero nos permite diseñar los
 lenguajes que buscaremos en las cadenas sobre datos obtenidos en tiempo de corrida y actuar acorde
 a ellos.<P>

Para ejemplificar esta funcionalidad, escribamos un segundo programa para cambiar la ruta al programa
 de Perl en los propios programas de Perl (aunque no en el presente por supuesto, de modo que
 habr&iacute;a que ejecutarlo pasando el programa como par&aacute;metro a Perl).<BR>
Pare esto requeriremos dos par&aacute;metros, la vieja ruta y la nueva ruta, y en ellos debemos hacer
 una consideraci&oacute;n especial, si tenemos:<P>
<b>
$ruta1="/usr/bin/Perl";<BR>
$ruta2="/usr/leng/Perl";<BR>
$renglon=~s/$ruta1/$ruta2/g;<P>
</b>
Al substituir las rutas en la expresi&oacute;n de substituci&oacute;n obtendr&iacute;amos un
 c&oacute;digo equivalente al siguiente:<P>
<b>
$renglon=~s//usr/bin/perl//usr/leng/perl/g;<P>
</b>
Que es err&oacute;neo!!!!<BR>
Como se puede apreciar, no colocamos los <b>\</b> antes de los <b>/</b> de modo que los
 <b>/</b> de las rutas ser&iacute;an interpretados como delimitadores de la cadena regular.<P>

Para corregir este problema existen dos posibles soluciones, uno, emplear alg&uacute;n otro caracter en
 lugrar de <b>/</b> para delimitar las expresiones regulares, pero por claridad y potencial fallo en caso
 de que alg&uacute;n posible valor de las variables empleara este nuevo caracter prefiero no emplearlo, para
 ver como opera recomiendo consultar la referencia en la secci&oacute;n del operador <b>s///</b>.<P>

La segunda posibilidad, que es la que empleamos en el primer script de este prop&oacute;sito que
 hicimos (<a href="#3.4.3.1">en la secci&oacute;n 3.4.3.1</a>) es el colocar <b>\</b> antes de
 cada <b>/</b> en la expresi&oacute;n regular de modo que no haya confusi&oacute;n en los limites
 de nuestra expresi&oacute;n.<BR>
Esto podr&iacute;amos hacerlo con expresiones regulares constantes, pero siendo una tarea muy
 com&uacute;n, Perl ha implementado una funci&oacute;n que realiza el trabajo por nosotros, esta
 funci&oacute;n es <b>quotemeta</b>, cuya sintaxis es:<P>
<b>
quotemeta EXPRESIÓN</b><BR>
donde:<BR>
<b>EXPRESIÓN</b> es la expresi&oacute;n en la que antecederemos \ a cada caracter que pueda tener
 alguna interpretaci&oacute;n especial en alg&uacute;n tipo de cadena.<P>

Debe notarse que si la emple&aacute;ramos en una expresi&oacute;n como "<b>\w*</b>"
 el resultado seria "<b>\\w\*</b>" de modo que seria completamente inocuo como expresi&oacute;n regular
 (solo implicar&iacute;a la secuencia literal de los tres caracteres "<b>\</b>","<b>w</b>" y
 "<b>*</b>".<BR>
Sin embargo, para el ejemplo que nos ocupa es justo lo que necesitamos.<P>

Adem&aacute;s, para hacer mas breve el programa, hag&aacute;moslo operar solo sobre un archivo cuyo
 nombre (y ruta completa en caso de requerirlo) le pasamos como tercer par&aacute;metro.<P>

Aclarado esto, pasemos al c&oacute;digo.<P>
<b><PRE>
#!/usr/bin/Perl
#Esta es una ruta tentativa, supongamos que es correcta o que eludimos usarla.
#recibimos en $ARGV[0] la ruta original
# y en $ARGV[1] la nueva ruta.

$ruta1=quotemeta($ARGV[0]);
$ruta2=$ARGV[1];

system("mv $ARGV[2] $ARGV[2].old");
open(PROG_OR,"&lt;$ARGV[2].old");
open(PROG_N,"&gt;$ARGV[2]");
while($renglon=&lt;PROG_OR&gt;)
{
  $renglon=~s/$ruta1/$ruta2/; #solo una substituci&oacute;n por rengl&oacute;n.
  print PROG_N $renglon;
}
close PROG_OR;
close PROG_N;
</b></PRE>
Expliquemos ahora, por l&iacute;neas el funcionamiento de este programa:<P>
<b>
#!/usr/bin/Perl<BR>
#Esta es una ruta tentativa, supongamos que es correcta o que eludimos usarla.<BR>
#recivimos en $ARGV[0] la ruta original<BR>
#y en $ARGV[1] la nueva ruta.<P>
</b>
Para fines pr&aacute;cticos, podemos considerar esto como un mero comentario inicial, pues no estamos
 seguros de que la posici&oacute;n de Perl sea esta, por lo que habr&aacute; de ejecutar este programa 
como Perl nombre del programa parametro1 parametro2 parametro3 ,n&oacute;tese que requiere de Perl5.<P>
<b>
$ruta1=quotemeta($ARGV[0]);<P>
</b>
Esta instrucci&oacute;n copia el valor del primer argumento a la variable <b><tt>$ruta1</tt></b>, teniendo la 
precauci&oacute;n de colocar \ antes de todo caracter especial para que pueda ser empleado como 
expresi&oacute;n regular.<P>
<b>
$ruta2=$ARGV[1];<P>
</b>
El segundo par&aacute;metro lo copiamos tal cual, habr&aacute; que tener precauci&oacute;n al usarlo 
para que las / que contengan no interfieran, pero no podr&aacute; ser empleado como expresi&oacute;n 
regular.<P>
<b>
system("mv $ARGV[2] $ARGV[2].old");<P>
</b>
Movemos el archivo a editar a uno nuevo con el mismo nombre y la extensi&oacute;n ".old" a semejanza 
del script de la <a href="#3.4.3.1">secci&oacute;n 3.4.3.1</a>.<P>
<b>
open(PROG_OR,"&lt;$ARGV[2].old");<P>
</b>
Abrimos como archivo de entrada el archivo original bajo su nuevo nombre.<P>
<b>
open(PROG_N,"&gt;$ARGV[2]");<P>
</b>
Y abrimos como archivo de salida un archivo reci&eacute;n creado con el nombre original del archivo a 
editar.<P>
<b>
while($renglon=&lt;PROG_OR&gt;){<P>
</b>
Iniciamos un ciclo t&iacute;pico para revisar todas las l&iacute;neas del programa.<P>
<b>
  $renglon=~s/$ruta1/$ruta2/; #solo una substituci&oacute;n por rengl&oacute;n.<P>
</b>
Realizamos la substituci&oacute;n, debe recordarse que solo la primera parte del operador <b>s///</b> 
es una expresi&oacute;n regular, y la segunda es solo una cadena que se coloca en lugar de aquellas 
cadenas que correspondan con la expresi&oacute;n regular.<P>

De modo que <b>$ruta1</b> efectivamente es empleada como la expresi&oacute;n regular que 
determina que cadena reemplazar, y <b>$ruta2</b> solo especifica la cadena a poner en su lugar 
(no es una expresi&oacute;n regular), como Perl sabe que <b>$ruta2</b> es solo una cadena no es 
necesario un manejo especial de esta, Esto no ser&iacute;a cierto si escribiesemos el valor de la
expresi&oacutre;n, pues no habr&iacute;a modo de saber cuales <b><tt>/</tt></b> son delimitadores.<BR>
Debe quedar bien claro que el operador <b>s///</b> solo emplea una expresi&oacute;n regular que 
es <b>$ruta1</b>, y que <b>$ruta2</b> es una simple cadena que el operador emplea en la 
substituci&oacute;n.<P>
<b>
  print PROG_N $renglon;}<P>
</b>
Ultima instrucci&oacute;n del ciclo por l&iacute;nea, que imprime la l&iacute;nea ya trabajada por el 
operador s/// en el archivo de salida.<P>
<b>
close PROG_OR;<BR>
close PROG_N;<P>
</b>
Cerramos los archivos tanto de entrada como de salida al final del programa.<P>

Como se ve, este es un programa muy sencillo, la mayor dificultad que tiene radica en comprender el uso 
que el operador da a sus operandos, y recomiendo que para una mayor claridad se consulte la referencia 
en la secci&oacute;n PERLOP en lo referente al operador <b>s///</b>.<P>

Los usos que se le puedan dar a esta caracter&iacute;stica de las cadenas regualres quedan a la 
imaginaci&oacute;n del programador, pero conf&iacute;o que en cuanto adquiera cierto dominio del 
lenguaje y se enfrente a problemas mas complejos hallara muchos y muy interesantes usos para esta 
caracter&iacute;stica y la siguiente.<P>

<blockquote><blockquote><blockquote><blockquote>
<a name="3.4.4.2"><h4>3.4.4.2- Variables de salida</h4></a><P>
</blockquote></blockquote></blockquote></blockquote>

Como he mencionado desde la <a href="#3.4.3">secci&oacute;n 3.4.3</a> una de las caracter&iacute;sticas mas 
interesantes de las expresiones regulares es su capacidad de extraer informaci&oacute;n de las cadenas 
seg&uacute;n su forma expresada en expresiones regualres.<P>

El uso de las variables de salida es muy sencillo, cuando planteamos una expresi&oacute;n regular en 
la que existan par&eacute;ntesis, las secciones de la cadena de prueba que correspondan con las 
sub-expresiones regulares contenidas en los par&eacute;ntesis ir&aacute;n siendo colocadas en las 
variables <b>$1, $2, $3</b>, etc.<P>

As&iacute; por ejemplo, para sacar la parte entera y fraccionaria de un numero como 4532431.243 
probar&iacute;amos:<P>
<b>
$numero="8942389.523";<BR>
$numero=~/(\d*)\.(\d*)/<BR>
$entero=$1;<BR>
$fraccion=$2;<P>
</b>
expliquemos este ejemplo l&iacute;nea por l&iacute;nea:<P>
<b>
$numero="8942389.523";<P>
</b>
Creamos el numero a revisar, recordemos que las expresiones regualres trabajan sobre cadenas, 
as&iacute; que a pesar de representar un valor num&eacute;rico, ahorramos el paso de la 
conversi&oacute;n y la especificamos directamente como cadena.<P>
<b>
$numero=~/(\d*)\.(\d*)/<P>
</b>
Realizamos una b&uacute;squeda del expresi&oacute;n regular, la expresi&oacute;n regular traducida al 
castellano es:<P>

busca una cadena de cero o mas d&iacute;gitos y agr&uacute;palos, luego, busca un punto y luego 
busca un segundo grupo de cero o mas d&iacute;gitos y agr&uacute;palos.<BR>
N&oacute;tese que los dos grupos quedan indicados por las partes de la expresi&oacute;n regular que esta 
entre par&eacute;ntesis.<P>
<b>
$entero=$1;<P>
</b>
Aqu&iacute; tomamos el valor de la variable constante <b>$1</b>, que contiene la parte de la cadena 
de prueba que se verifico con el primer grupo de la expresi&oacute;n regular.<BR>
en este caso el valor en cuesti&oacute;n es "8942389"<P>
<b>
$fraccion=$2;<P>
</b>
Y despu&eacute;s tomamos el valor del segundo grupo de la expresi&oacute;n regular y lo colocamos en 
la variable fracci&oacute;n, en este caso "523"<P>

Debe notarse que en este ejemplo el "." no se incluyo en ninguno de los grupos, por lo que no figura en 
ninguna variable $1,$2, etc.<P>

En este ejemplo el numero de grupos esta claramente definido desde el principio. Lo que no siempre es el 
caso, por ejemplo, supongamos que deseamos extraer los diversos elementos de un nombre e irlos 
imprimiendo uno por uno.<P>
<b><PRE>
$nombre="David Jonathan Sol Llaven";
while($nombre =~ /(\w+)\s*/g)
{
  print $1;
}
</PRE>
</b>
Debe notarse de este ejemplo que al emplear el modificador <b>/g</b> del operador <b>m//</b> 
se van obteniendo las coincidencias una por una, en este caso, y el operador va recordando la 
posici&oacute;n en que ocurri&oacute; la ultima ocurrencia para proseguir con la b&uacute;squeda en una 
ocasi&oacute;n posterior, de no incluir el modificador /g cada nueva vuelta del ciclo while regresar&iacute;a 
el mismo elemento, el primero.<P>

Una segunda opci&oacute;n, consisten en obtener el resultado de la expresi&oacute;n en su conjunto, este 
puede usarse en contexto escalar o en contexto de arreglo, este refinamiento es muy &uacute;til si 
deseamos, por ejemplo, obtener los elementos sacados de la cadena de prueba en grupos, sin embargo, la 
aplicaci&oacute;n resulta un poco mas dif&iacute;cil de comprender y para no confundir los progresos 
logrados prefiero dejarlo a la investigaci&oacute;n del lector.<P>

As&iacute; pues, para comprender el funcionamiento de la obtenci&oacute;n de los valores de una 
verificaci&oacute;n de expresiones regulares recomiendo revisar la secci&oacute;n de operadores de la 
referencia, PERLOP, en lo concerniente al operador <b>m//</b> aunado con una saludable dosis de 
experimentaci&oacute;n.<P>

No olvide el lector que como casi cualquier otra caracter&iacute;stica de Perl, las expresiones regualres 
est&aacute;n ah&iacute; para facilitar las tareas a realizar, por lo que deben de emplearse para resumir 
largos procesos de b&uacute;squeda y separaci&oacute;n de cadenas o para atacar problemas de 
revisi&oacute;n de cadenas.<P>
<hr>
En esta secci&oacute;n , dada su hostilidad, agradecer&eacute; los comentarios y ejemplos que ayuden 
a la comprensi&oacute;n de esta caracter&iacute;stica de Perl.
</BODY>
</HTML>
